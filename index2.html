<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="ocean.css" />
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      /* new */
      .example { background-color: #007ebc}
      .example h2 { color: #00394f; font-weight: bold; line-height: 0;}
      .example h1 { color: #fff; font-weight: bold; background-color: #00394f; padding: 10px }

      .codeonly { padding: 1em; background-color: #2b303b }
      .codeonly pre { margin: 0 }

      .remark-code-line-highlighted { background-color: #2d9967; color: white}
      .remark-code-line-highlighted * { color: white !important; }

      .remark-slide-scaler { -webkit-box-shadow: 0 !important; box-shadow: none !important; }
      .remark-slide-container {background-color: #2b303b}
      /* new end */
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }

      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Part II

---
class: center, middle, example
# Application aka Service layer

---
## - defines a use case, what the system does

--

## - defines a use case contract (input / output)

--

## - defines transaction boundary

--

## - never ever to be confused with a domain service

---
class: codeonly

.crap[
```java
interface MemberPermissionService {

  void grantPermission(String memberId, String permissionId);

  PermissionsDto listPermissions(String memberId);

}
```
]

--

.crap[
```java
@Transactional
class MemberPermissionServiceImpl implements MemberPermissionService {

  @Override
  public void grantPermission(String memberId, String permissionId) { ... }

  @Override
  public PermissionsDto listPermissions(String memberId) { ... }

}
```
]

---
class: bad

## - tend to grow like hell

--

## - no single entry point

--

## - always blocking

--

## - hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...

---
class: codeonly
.nice[
```java
interface Command<T extends Command.R> {
    interface R {
      class Void implements Command.R {
      }
    }
}
```
]

--

.nice[
```java
interface Reaction<C extends Command<R>, R extends Command.R> {
    R react(C $);
}
```
]

--
.nice[
```java
interface Now {
    <C extends Command<R>, R extends Command.R> R execute(C command);
}
```
]
???
a funnel finds and executes appropriate impl for a command using generics

--
.nice[
```java
@Remote(Protocol.PROTOBUFS)
interface Now {
    <C extends Command<R>, R extends Command.R> R execute(C command);
}
```
]

--

.nice[
```java
interface Future {
    <C extends Command<R>, R ...> CompletableFuture<R> schedule(C command);
}```
]

--

.nice[
```java
interface Rx {
    <C extends Command<R>, R ...> Observable<R> observe(C command);
}
```
]

--

.nice[
```java
interface Durable {
    <C extends Command> void enqueue(C command);
}
```
]

---
class: codeonly
.nice[
```java
class GrantPermission implements Command<Command.R.Void> {

    private final String memberId, permissionId;

    public GrantPermission(String memberId, String permissionId) { ... }

    public String memberId() {
        return memberId;
    }

    public String permissionId() {
        return permissionId;
    }
}
```
]

--
.nice[
```java
class GrantPermissionReaction implements Reaction<GrantPermission, Command.R.Void> {

    private final Members members;
    private final Permissions permissions;

    public GrantPermissionReaction(Permissions permissions, Members members) { ... }

    @Override
    public Command.R.Void react(GrantPermissionCommand $) {
        MemberId memberId = new MemberId($.memberId());
        Member member = members.byId(memberId);

        PermissionId permissionId = new PermissionId($.permissionId());
        Permission permission = permissions.byId(permissionId);

        member.grantPermission(permission);
        return new Command.R.Void();
    }
}
```
]

---
class: codeonly
```java
@RestController
class GrantPermissionEndpoint {

    @Autowired
    Now now;

    @PostMapping("/users/{memberId}/permissions")
    Command.R.Void accept(@PathVariable String memberId, @RequestParam String permissionId) {
        GrantPermission grantPermission = new GrantPermission(memberId, permissionId);
        return now.execute(grantPermission);
    }
```

--

```java
    ...

    @Autowired
    Future future;

    future.schedule(grantPermission)
      .thenAccept(System.out::println)
      .thenAccept(...)
```

--

```java
    ...

    @Autowired
    Rx rx;

    rx.observe(grantPermission).subscribe(System.out::println);
```

--

```java
    ...

    @Autowired
    Durable durable;

    durable.enqueue(grantPermission);
```

---
class: codeonly
```java
interface Command<T extends Command.R> {

    default T execute(Now now) {
        return now.execute(this);
    }

    default CompletableFuture<T> schedule(Future future) {
        return future.schedule(this);
    }

    default Observable<T> observe(Rx rx) {
        return rx.observe(this);
    }

    default void enqueue(Durable durable) {
        durable.enqueue(this);
    }
}
```

--
```java
GrantPermission grantPermission = new GrantPermission("memba", "permission");

grantPermission.execute(now);
```

--

```java
grantPermission.schedule(future);
```

--

```java
grantPermission.observe(rx);
```

--

```java
grantPermission.enqueue(durable);
```

---
class: codeonly
```java
class Try<C extends Command<R>, R extends Command.R> implements Command<R> {

    private final C origin;

    private long times = 3;

    public Try(C origin) {
        this.origin = origin;
    }

    public Command<R> origin() {
        return origin;
    }


    public Try<C, R> times(long times) {
        this.times = times;
        return this;
    }

    public long times() {
        return times;
    }
}
```

---
class: codeonly
```java
class TryReaction<C extends Command<R>, R extends Command.R>
                                          implements Reaction<Try<C, R>, R> {

    private final Reactions reactions;

    @Override
    public R react(Try<R> $) {

        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
        retryPolicy.setMaxAttempts($.times());

        RetryTemplate template = new RetryTemplate();
        template.setRetryPolicy(retryPolicy);

        return template.execute(context -> {
            Command<R> origin = $.origin();
            Reaction<Command<R>, R> reaction = reactions.byCommand(origin);
            return reaction.react(origin);
        });
    }
}
```

--

```java
new Try<>(
  new GrantPermission(...))
      .times(5)
      .execute(now);
```

---
class: codeonly
```java
@Component
class Reactions {

    private final LoadingCache<Type, Reaction> cachedReactions;

    @Autowired
    public Reactions(ListableBeanFactory beanFactory) {
        this.cachedReactions = Caffeine.newBuilder()
            .build(commandType -> reactions(beanFactory)
                .stream()
                .filter(reaction -> reaction.commandType().isSupertypeOf(commandType))
                .findFirst()
                .orElseThrow(() -> new NoReactionFound(commandType)));
    }

    private Collection<Reaction> reactions(ListableBeanFactory beanFactory) {
        return beanFactory.getBeansOfType(Reaction.class).values();
    }

    public <C extends Command<R>, R extends Command.R> Reaction<C, R> byCommand(C command) {
        return cachedReactions.get(command.type());
    }
}
```

--

```java


interface Reaction<C extends Command<R>, R extends Command.R> {

    R react(C $);

    default TypeToken<C> commandType() {
        return new TypeToken<C>(getClass()) {
        };
    }
}
```

---
class: center, middle
## Bundle advanced functionality into separate objects. Functionality is hidden unless such objects are requested.
### â€” *Scott Meyers*

---

## .strike[Tend to grow like hell]

--

## .strike[No single entry point]

--

## .strike[Always blocking]

--

## .strike[Hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...]

---
class: center, middle
## Centralized Transaction management?

---
class: codeonly
```java
interface Command<T extends Command.R> {

    interface R {
        class Void implements R {

        }
    }

    interface TxFlag {

        TxFlag READ_ONLY = tx -> tx.setReadOnly(true);

        void apply(TransactionTemplate tx);
    }

    default Collection<TxFlag> txFlags() {
        return Collections.emptyList();
    }
}
```

--

```java
class GetMobileNumbers implements Command<GetMobileNumbers, MobileNumbers>

    @Override
    public Collection<TxFlag> txFlags() {
        return ImmutableList.of(TxFlag.READ_ONLY);
    }

}
```

---
class: codeonly
```java
@Component
class TransactionalNow implements Now {

    private final Reactions reactions;

    private final PlatformTransactionManager txManager;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = reactions.byCommand(command);

*       TransactionTemplate tx = new TransactionTemplate(txManager);
*       command.txFlags().forEach(flag -> flag.apply(tx));

        R response = tx.execute(txStatus -> reaction.react(command));

        return response;
    }
}
```

---
class: center, middle
## Logging?

---
class: codeonly
```java
@Component
class TransactionalAndLoggingNow implements Now {

    private final Reactions reactions;

    private final PlatformTransactionManager txManager;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = reactions.byCommand(command);

        TransactionTemplate tx = new TransactionTemplate(txManager);
        command.txFlags().forEach(flag -> flag.apply(tx));

*       log.info(">>> {}", command.toLogString());
        R response = tx.execute(txStatus -> reaction.react(command));
*       log.info("<<< {}", response.toLogString());

        return response;
    }
}
```

---
class: center, middle
## Logging correlation?

---
class: codeonly
```java
@Component
class CommandCorrelationId {

    private static final String MDC_KEY = "ccid";

    private final AtomicLong counter = new AtomicLong();

    @Value("${unique.node.id}")
    private private String node;


    public void storeForLogging() {
        MDC.put(MDC_KEY, next());
    }

    public void stashFromLogging() {
        MDC.remove(MDC_KEY);
    }

    private String next() {
        return node + counter.incrementAndGet() % 1000;
    }
}
```

---
class: codeonly
```java
@Component
class GrowingNow implements Now {

    private final Reactions reactions;

    private final PlatformTransactionManager txManager;

    private final CommandCorrelationId correlationId;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = reactions.byCommand(command);

*       correlationId.storeForLogging();

        TransactionTemplate tx = new TransactionTemplate(txManager);
        command.txFlags().forEach(flag -> flag.apply(tx));

        log.info(">>> {}", command.toLogString());
        R response = tx.execute(txStatus -> reaction.react(command));
        log.info("<<< {}", response.toLogString());

*       correlationId.stashFromLogging();

        return response;
    }
}
```

---
class: center, middle
## Refactoring to decorators

---
class: codeonly
```java
@Component
class PipedNow implements Now {

    private final Reactions reactions;

    private final PlatformTransactionManager txManager;

    private final CommandCorrelationId correlationId;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Now pipe = new Correlable(
                      new Loggable(
                         new Transactional(
                            new Reacting())));

        return pipe.execute(command);
    }
```

--
```java
    private class Correlable implements Now {

        private final Now origin;

        public Correlable(Now origin) {
            this.origin = origin;
        }

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            correlationId.storeForLogging();
            R response = origin.execute(command);
            correlationId.stashFromLogging();
            return response;
        }
    }
```

---
class: codeonly
```java
@Component
class PipedNow implements Now {

    ...

    private class Loggable implements Now {

        private final Logger log = LoggerFactory.getLogger(Loggable.class);

        private final Now origin;

        public Loggable(Now origin) {
            this.origin = origin;
        }

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            log.info(">>> {}", command.toLogString());
            R response = origin.execute(command);
            log.info(">>> {}", command.toLogString());
            return response;
        }
    }

```

--

```java
    private class Transactional implements Now {

        private final Now origin;

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            TransactionTemplate tx = new TransactionTemplate(txManager);
            command.txFlags().forEach(flag -> flag.apply(tx));
            return tx.execute(txStatus -> origin.execute(command));
        }
    }
```

---
class: codeonly
```java
@Component
class PipedNow implements Now {

    ...

    private class Reacting implements Now {

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            Reaction<C, R> reaction = reactions.byCommand(command);
            return reaction.react(command);
        }
    }

}
```

---
# Commands are also great, because:

--

### - new info can be passed downstream w/o changing the interface

--

### - funnels can read command @Annotations

--

### - flexible composition at command, reaction and funnel side

--

### - favours composion over jdk/javassist/bytebuddy proxying

---
class: center, middle
## Concurrency at the application layer

---
class: codeonly
```java
@Immutable
@Enclosing
interface GetSocialAccounts extends Command<GetSocialAccounts.R> {

    String networkerId();

    @Immutable
    interface R extends Command.R {
        List<SocialAccount> socialAccounts();
    }
}
```

--
```java
@Immutable
interface SocialAccount {
    SocialAccountType type(); // FB, TW, LN
    String username();
}
```

--

```java
class GetSocialAccountsReaction implements Reaction<GetSocialAccounts, GetSocialAccounts.R> {

    public GetSocialAccounts.R react(GetSocialAccounts $) {
        SocialAccount facebook = ImmutableSocialAccount.builder()
          .type(SocialAccountType.FB)
          .username("facebook@devchampions.com")
          .build();

        SocialAccount twitter = ImmutableSocialAccount.builder()
          .type(SocialAccountType.TW)
          .username("twitter@devchampions.com")
          .build();

        return R.builder()
          .addSocialAccounts(facebook, twitter)
          .build();
    }
}
```

---
class: codeonly
```java
@Immutable
@Enclosing
interface GetSocialConnections extends Command<GetSocialConnections.R> {

    SocialAccount socialAccount();

    @Immutable
    interface R extends Command.R {
        List<SocialConnection> connections();
    }
}
```

--

```java
@Immutable
interface SocialConnection {
    String emailAddress();
}
```

--

```java
class GetSocialConnectionsReactionStub implements Reaction<GetSocialConnections, ...> {

    @Override
    public GetSocialConnections.R react(GetSocialConnections $) {
        return R.builder()
                .addConnections(randomConnection())
                .addConnections(randomConnection())
                .addConnections(randomConnection())
                .build();
    }

    private ImmutableSocialConnection randomConnection() {
        return ImmutableSocialConnection.builder()
                .emailAddress(random())
                .build();
    }
}
```

---
class: center, middle
## Fetching social connections concurrenty

---

class: codeonly
```java
return ImmutableGetSocialAccounts
        .builder()
        .networkerId(WHATEVER_NETWORKER_ID)
        .build()
        .schedule(future)
```

--

```java
        .thenApply(GetSocialAccounts.R::socialAccounts)
```

--

```java
        .thenCompose(socialAccounts -> socialAccounts
            .stream()
            .map(account -> ImmutableGetSocialConnections
                .builder()
                .socialAccount(account)
                .build()
                .schedule(future))
```

--

```java
            .collect(new FuturesCollector<>()))
```

--

```java
        .thenApply(onceAllDone -> onceAllDone
            .stream()
            .map(GetSocialConnections.R::connections)  // a stream of many collections

```

--

```java
            .flatMap(connections -> connections
                .stream()
                .map(SocialConnection::emailAddress))) // a stream of collection elements

```

--

```java
        .thenApply(emailAddresses -> emailAddresses
            .distinct()
            .count())
```

--

```java
        .get();                                        // finally blocks
```

---
class: codeonly
```java
@Component
class PipedFuture implements Future {

    @Retention(RenentionPolicy.RUNTIME)
    public @interface Pool {
    }

    private final ExecutorService executor;

    public DefaultFuture(@Pool ExecutorService executor, ...) {
        ...
    }

    @Override
    public <C extends Command<R>, R extends Command.R> CompletableFuture<R> schedule(C command) {
        Now pipe = new Correlable(
                      new Loggable(
                         new Transactional(
                            new Reacting())));

        return CompletableFuture.supplyAsync(() -> pipe.execute(command), executor);
    }
}
```

--

```java
@Configuration
class PipedFutureConfiguration {

    @Bean
    @PipedFuture.Pool
    ExecutorService pool(@Value("${commands.future.pool_size}") long poolSize) {
        return Executors.newFixedThreadPool(poolSize);
    }
}
```

---
class: codeonly
```java
class FuturesCollector<T> implements Collector<CompletableFuture<T>,
                                     Collection<CompletableFuture<T>>,
                                     CompletableFuture<Collection<T>>> {

    public Supplier<Collection<CompletableFuture<T>>> supplier() {
        return ArrayList::new;
    }

    public BiConsumer<Collection<CompletableFuture<T>>, CompletableFuture<T>> accumulator() {
        return Collection::add;
    }

    public BinaryOperator<Collection<CompletableFuture<T>>> combiner() {
        return (one, another) -> ImmutableList.<CompletableFuture<T>>builder()
                .addAll(one)
                .addAll(another)
                .build();
    }

    public Function<...>, CompletableFuture<Collection<T>>> finisher() {
        return futures ->
                CompletableFuture.allOf(
                    futures
                        .stream()
                        .toArray(CompletableFuture[]::new))
                .thenApply(allOf -> allOf
                    .stream()
                    .map(CompletableFuture::join)
                    .collect(toList()));
    }

    public Set<Characteristics> characteristics() {
        return Collections.singleton(Characteristics.CONCURRENT);
    }
}
```

---
class: center, middle
## Let's see whether our concurrent code is testable

---
class: codeonly
```java
class SocialNetwork {

    private final Future future;

    public Networker networker(String networkerId) {
        return new Networker(networkerId);
    }

    class Networker {

        private final String id;

        public Networker(String id) {
            this.id = id;
        }

        public String id() {
            return id;
        }

        public long uniqueConnectionCount() {
            return ImmutableGetSocialAccounts
                    .builder()
                    .networkerId(id)
                    .build()
                    .schedule(future)

                    .thenApply(GetSocialAccounts.R::socialAccounts)

                    ...

                    .get();
        }
    }
}
```

---
class: codeonly
.crap[
```groovy
class SocialNetworkSpec extends Specification {

    Future future = Mock()

    @Subject
    SocialNetwork socialNetwork

    def "calculates unique connection count"() {
      given:
      def socialNetwork = new SocialNetwork(future)

      and:
      def networker = socialNetwork.networker(NETWORKER_ID)
```
]

--

.crap[
```groovy
      and: "making sure networker has twitter and facebook accounts"
      future.schedule(ImmutableGetSocialAccountsCommand
              .builder()
              .networkerId(NETWORKER_ID)
              .build()) >>
                  completedFuture(
                      ImmutableGetSocialAccountsCommand.R
                              .builder()
                              .addSocialAccounts(ImmutableSocialAccount
                                  .builder()
                                  .username("twitter@account.test")
                                  .type(TW)
                                  .build())
                              .addSocialAccounts(ImmutableSocialAccount
                                  .builder()
                                  .username("facebook@account.test")
                                  .type(FB)
                                  .build())
                              .build())
```
]

---
class: codeonly
.crap[
```groovy
class SocialNetworkSpec extends Specification {

    ...

    def "calculates unique connection count"() {
      given:
      ...
      and:
      ...
      and: "adding unique facebook connection"
      future.schedule(ImmutableGetSocialConnectionsCommand
              .builder()
              .username("facebook@account.test")
              .socialAccountType(FB)
              .build()) >>
                  completedFuture(
                      ImmutableGetSocialConnectionsCommand.R
                              .builder()
                              .addConnections(
                                  ImmutableSocialConnection
                                          .builder()
                                          .emailAddress("friend@facebook.com")
                                          .build())
                              .build())
```
]

---
class: codeonly
.crap[
```groovy
class SocialNetworkSpec extends Specification {

    ...

    def "calculates unique connection count"() {
      given:
      ...
      and:
      ...
      and: "adding duplicate twitter connection"
      future.schedule(ImmutableGetSocialConnectionsCommand
              .builder()
              .username("facebook@account.test")
              .socialAccountType(FB)
              .build()) >>
                  completedFuture(
                      ImmutableGetSocialConnectionsCommand.R
                              .builder()
                              .addConnections(
                                  ImmutableSocialConnection
                                          .builder()
                                          .emailAddress("friend2@twitter.com")
                                          .build(),
                                  ImmutableSocialConnection
                                          .builder()
                                          .emailAddress("friend2@twitter.com")
                                          .build())
                              .build())
```
]

---
class: codeonly
.crap[
```groovy
class SocialNetworkSpec extends Specification {

    ...

    def "calculates unique connection count"() {
      given:
      ...
      and: "adding unique facebook connection"
      ...
      and: "adding duplicate twitter connection"
      ...
      when:
      def uniqueConnections = networker.uniqueConnectionCount();

      then:
      uniqueConnections == 2L
    }
}
```
]

---
class: center, middle
## Refactoring to human readable specification

---
class: codeonly
```groovy
@Newify(SocialNetwork, SocialAccounts)
class SocialNetworkSpec extends Specification {

    def future = Mock(Future)

    def facebookAccount = SocialAccounts().someFacebook();
    def twitterAccount = SocialAccounts().someTwitter();

    @Subject
    def network = SocialNetwork(future);

    def networker = network.networker("NETWORKER_ID")

    def "calculates unique collection count"() {
        ...
    }
    ...
}
```

--

```java
class SocialAccounts {

    def someFacebook() {
      ImmutableSocialAccount {                          // groovy + Immutables magic
        username whatever()                             // groovy + Immutables magic
        type FB                                         // groovy + Immutables magic
      }
    }

    def someFacebook() {
      ImmutableSocialAccount {                          // groovy + Immutables magic
        username whatever()                             // groovy + Immutables magic
        type TW                                         // groovy + Immutables magic
      }
    }
}
```

---
class: codeonly
```groovy
class SocialNetworkSpec extends Specification {

    ...

    def "calculates unique connection count"() {
      given:
      networkerOwns(facebookAccount, twitterAccount);
    }

    ...
```

--

```java
    private networkerOwns(accounts) {
        future.schedule(queryForSocialAccounts()) >> returnsSocialAccounts(accounts).inFuture()
    }
```

--

```java
    private queryForSocialAccounts() {
        ImmutableGetSocialAccountsCommand {
            networkerId networker.id()
        }
    }
```

--

```java
    private returnsSocialAccounts(socialAccounts) {
        ImmutableGetSocialAccounts.R {
            addSocialAccounts(socialAccounts)
        }
    }
```

---
class: codeonly
```java
class CommandModule {

    static <T extends Command.R> CompletableFuture<T> inFuture(T self) {
        CompletableFuture.<T> completedFuture(self)
    }

}
```

```prop
// src/test/resources/META-INF/services/org.codehaus.groovy.runtime.ExtensionModule
moduleName=command-module
moduleVersion=1.0
extensionClasses=com.devchampions.jninja.modules.command.CommandModule
```

---
class: codeonly
```groovy
class SocialNetworkSpec extends Specification {

    ...

    def "calculates unique connection count"() {
      given:
      networkerOwns(facebookAccount, twitterAccount);

      and:
      networkerHasUniqueFacebookConnection()
    }

    ...
```

--

```java
    private networkerHasUniqueFacebookConnection(accounts) {
      future.schedule(queryForSocialConnections(facebookAccount.username(), FB))
          >> returnsSocialConnectionsWithEmails("u@ni.que").inFuture()
    }
```

--

```java
    private queryForSocialConnections(username, socialAccountType) {
        ImmutableGetSocialConnectionsCommand {
            username username
            socialAccountType socialAccountType
        }
    }
```

--

```java
    private returnsSocialConnectionsWithEmails(socialConnectionEmails) {
        ImmutableGetSocialConnectionsCommand.R {
            addAllConnections socialConnectionEmails.collect { socialConnection(it) }
        }
    }
```

--

```java
    private socialConnection(emailAddress) {
        ImmutableSocialConnection {
            emailAddress emailAddress
        }
    }
```

---
class: codeonly
```groovy
class SocialNetworkSpec extends Specification {

    ...

    def "calculates unique connection count"() {
      given:
      networkerOwns(facebookAccount, twitterAccount);

      and:
      networkerHasUniqueFacebookConnection()

      and:
      networkerHasDuplicateTwitterConnection()
    }

    ...
```

--

```java
    private networkerHasDuplicaTwitterConnection(accounts) {
      future.schedule(queryForSocialConnections(twitterAccount.username(), TW))
          >> returnsSocialConnectionsWithEmails("dupli@ca.te", "dupli@ca.te").inFuture()
    }
```

---
class: codeonly
```groovy
class SocialNetworkSpec extends Specification {

    ...

    def "calculates unique connection count"() {
      given:
      networkerOwns(facebookAccount, twitterAccount);

      and:
      networkerHasUniqueFacebookConnection()

      and:
      networkerHasDuplicateTwitterConnection()

      when:
      def uniqueConnections = networker.uniqueConnectionCount();

      then:
      uniqueConnections == 2L
    }

    ...
}
```

---
class: center, middle
## Fixing callback hell with CompletableFutures

---
class: codeonly
.crap[
```java
Firebase firebase = new Firebase("https://your-app.firebaseio.com");
Firebase expenses = firebase.child("expenses");

CountDownLatch firebaseWait = new CountDownLatch(1);

AtomicReference<DataSnapshot> snapshot = new AtomicReference<>();
AtomicReference<FirebaseError> exception = new AtomicReference<>();

expenses.addListenerForSingleValueEvent(new ValueEventListener() {
   @Override
   public void onDataChange(DataSnapshot dataSnapshot) {
       snapshot.set(dataSnapshot);
       firebaseWait.countDown();
   }

   @Override
   public void onCancelled(FirebaseError firebaseError) {
       exception.set(firebaseError);
       firebaseWait.countDown();
   }
});

firebaseWait.await(5, TimeUnit.SECONDS);

System.out.println(snapshot.get());
```
]

---
class: codeonly
```java
class RxFirebase {

  private final Firebase root;

  public RxFirebase(Firebase root) {
      this.root = root;
  }
```

--

```java
  public CompletableFuture<DataSnapshot> snapshot(String path) {
      Firebase children = root.child(path);
      CompletableFuture<DataSnapshot> completableFuture = new CompletableFuture<>();
      children.addListenerForSingleValueEvent(new Notify(completableFuture));
      return completableFuture;
  }
```

--

```java
  private class Notify implements ValueEventListener {

      private final CompletableFuture<DataSnapshot> completableFuture;

      public Notify(CompletableFuture<DataSnapshot> completableFuture) {
          this.completableFuture = completableFuture;
      }

      @Override
      public void onDataChange(DataSnapshot dataSnapshot) {
          completableFuture.complete(dataSnapshot);
      }

      @Override
      public void onCancelled(FirebaseError firebaseError) {
          completableFuture.completeExceptionally(firebaseError.toException());
      }
  }
}
```

---
class: codeonly
.nice[
```java
Firebase firebase = new Firebase("https://your-app.firebaseio.com");
```
]

--

.nice[
```java
RxFirebase rxFirebase = new RxFirebase(firebase);
```
]

--

.nice[
```java
CompletableFuture<DataSnapshot> expenses = rxFirebase.snapshot("expenses");
```
]

--

.nice[
```java
DataSnapshot snapshot = expenses.get(5, TimeUnit.SECONDS);
```
]

--

.nice[
```java
System.out.println(snapshot);
```
]

---
# vs.
### - RxJava
### - Spring Reactor
### - Reactive Streams

---
class: center, middle
## Few testing hints

---
class: codeonly
```java
CompletableFuture.complete(T value);
```

--

```java
CompletableFuture.completeExceptionally(Throwable ex);
```

--

```java
CompletableFuture.completedFuture(U u);
```

--

```java
CompletableFuture.get();
```

--

```java
@Test
void thisExampleUsesAwaitility() throws Exception {
    publishEvent(updateCustomerStatusEvent);
    await().atMost(5, SECONDS).until(eventStore::size(), is(1));
}
```

--

```java
@Test
void andThisOneToo() throws Exception {
    await().untilAtomic(atomic, equalTo(1));
}
```

---
class: codeonly
```java
@UsesGoogleThreadWeaver
class ThisTestRevealsSynchronizationIssues {

  private static final String HELLO = "Hello";

  private volatile UniqueList<String> uniqueList;

  @ThreadedBefore
  public void init() {
    uniqueList = new UniqueList<String>();
  }

  @ThreadedMain
  public void putHelloIfAbsent() {
    uniqueList.putIfAbsent(HELLO);
  }

  @ThreadedSecondary
  public void putAnotherHelloIfAbsent() {
    uniqueList.putIfAbsent(HELLO);
  }

  @ThreadedAfter
  public void check() {
    assertThat(uniqueList, hasSize(1));
    assertThat(uniqueList, contains(HELLO));
  }
}
```
???
exercises lines of putIfAbsent in diffent combinations in 2 threads.

---
class: center, middle, example
# Validation

---
class: center, middle
## Reject values with wrong type and format asap, before they do harm.
### Preferably, fail fast **before construction**.
???
because others can rely on it.

---
class: center, middle
## Let's see what JPA/Hibernate want you to do...


---
class: codeonly
.crap[
```java
class User {

    @Email
    private String email;                           // not really an email, liar

    @Strong
    private String password;                        // might not be strong

    private LocalDateTime registeredAt;

    public User(String email, String password) {
        this.email = email;
        this.password = password;
    }

    public void changePassword(String newPassword) {
        this.password = newPassword;
    }

    public void register() {
        this.registeredAt = LocalDateTime.now();
    }

    public String email() {
        return email;
    }
}
```
]

---

class: codeonly
.crap[
```java
class RegisterNewUserReaction implements Reaction<RegisterNewUser, Command.R.Void> {

    private final WelcomeNotification notification;

    @Override
    public Command.R.Void react(RegisterNewUser $) {
        User user = makeUser($);                    // broken at this point
```
]

--

.crap[
```java
        user.register();                            // still broken
```
]

--

.crap[
```java
        users.persist(user);                        // still broken, not flushed yet
```
]

--

.crap[
```java
        welcomeNotification.schedule(user);         // shit propagates further

        return new Command.R.Void();
    }
}
```
]

--

.crap[
```java
class WelcomeNotification {
    void schedule(User user) {
        user.email();                               // accepts lies and (hopefully) booms
    }
}
```
]
???
by default, Hibernate validates during FLUSH :-)

---
class: codeonly
```java
class Email {

  private final String text;

  public Email(Email.Unchecked email) {
      checkArgument(email.isValid(), "%s is not an RFC-5322 compliant email.", text);
      this.text = text;
  }

  public Email(String text) {
      this(new Email.Unchecked(text));
  }

  ...
```
---
class: codeonly
```java
class Email {

  ...

  static class Unchecked {

      private static final String LOCAL_PART = "^[\\w!#$%&â€™*+/=?`{|}~^-]+(?:\\.[\\w!#$%&â€™*+/=?`{|}~^-]+)*";
      private static final String AT_SIGN = "@";
      private static final String HOSTNAME_FOLLOWED_BY_DOT = "(?:[a-zA-Z0-9-]+\\.)+";
      private static final String COUNTRY_CODE = "[a-zA-Z]{2,6}";
      private static final String END_OF_LINE = "$";

      private final Pattern RFC_5322 = compile(
              LOCAL_PART + AT_SIGN + HOSTNAME_FOLLOWED_BY_DOT + COUNTRY_CODE + END_OF_LINE);

      private String rawText;

      public Text(String rawText) {
          this.rawText = rawText;
      }

      public boolean isValid() {
          return RFC_5322.asPredicate().test(rawText);
      }

      @Override
      public String toString() {
          return rawText;
      }
  }

}
```

---
class: codeonly
```java
@Override
public Command.R.Void react(RegisterNewUser $) {

   Email.Unchecked email = new Email.Unchecked($.email()));
   if (!email.isValid()) {
     throw new ValidationException("Dooh! The email " + $.email() + " is not valid");
   }

   User user = makeUser(new Email($.email()), ...);
   ...
}
```

--

```java
static class Unchecked {

   ...

   public Optional<Email> valid() {
       return isEmail() ? Optional.of(new Email(rawText)) : Optional.empty();
   }
}
```

---
class: codeonly
```java
@Override
public Command.R.Void react(RegisterNewUser $) {

   Email email = new Email.Unchecked($.email())
                     .valid()
                     .orElseThrow(() -> new ValidationException("Dooh! ..."));

   User user = makeUser(email, ...);
   ...
}
```

--

```java
@Override
public Command.R.Void react(RegisterNewUser $) {

  Email email = new Email.Unchecked($.email())
                    .valid()
                    .orElseThrow(() -> new ValidationException("o_O"));

  Password password = new Password($.password());
  if (password.isWeak()) {
      throw new ValidationException("Weak password, sorry fella");
  }

  ...

  return new Command.R.Void();
}
```

---
class: center, middle
## Let's avoid branching and make code more declarative

---
class: codeonly
```java
@Override
public Command.R.Void react(RegisterNewUser $) {

  Email.Unchecked email = new Email.Unchecked($.email());
  Password password = new Password($.password());
```

--

```java
  Validator validator = new FailFastValidator();
```

--

```java
  validator
          .whenNot(email, Email::isValid)
          .then("Sorry man, email (%s) is completely wrong.");
  validator
          .when(password, Password::isWeak)
          .then("Password is too weak. Make it secure by adding some weird characters.");
```

--

```java
  validator.throwFirst();

  ...

  return new Command.R.Void();
}
```

---
class: codeonly
```java
interface Validator {

    <T> IfCondition when(T value, Predicate<T> predicate);

    <T> IfCondition whenNot(T value, Predicate<T> predicate);

    void throwFirst();

}
```

--

```java
class IfCondition<T> {

    private final T item;
    private final Predicate<T> predicate;

    private String failureMessage;

    public IfCondition(T item, Predicate<T> predicate) {
        this.item = item;
        this.predicate = predicate;
    }

    void then(String failureMessage) {
        this.failureMessage = failureMessage;
    }

    boolean isTrue() {
        return predicate.test(item);
    }

    String message() {
        return failureMessage.replaceAll("%s", item.toString());
    }

}
```

---
class: codeonly
```java
class FailFastValidator implements Validator {

    private final Collection<IfCondition> ifConditions = new LinkedList<>();

    @Override
    public <T> IfCondition whenNot(T value, Predicate<T> predicate) {
        return when(value, predicate.negate());
    }
```

--

```java
    @Override
    public <T> IfCondition when(T value, Predicate<T> predicate) {
        IfCondition<T> ifCondition = new IfCondition<>(value, predicate);
        ifConditions.add(ifCondition);
        return ifCondition;
    }
```

--

```java
    @Override
    public void throwFirst() {
        IfCondition.stream()
                .filter(IfCondition::isTrue)
                .findFirst()
                .ifPresent(ifCondition -> {
                    throw new ValidationException(ifCondition.message());
                });

    }
}
```

--

```java
    @Override
    public void throwAll() {
        ...
    }
```

---
class: center, middle
## Adding business validation
### (email uniqueness check)

---
class: codeonly
```java
class Email {

    private final String text;

    public Email(String text) {
        ...
    }

    ...
```

--

```java
    interface Uniqueness {
      boolean guaranteed(Email email);
    }
}
```

--

```java
@Repository
interface Users {
    Optional<User> byEmail(Email email);
}
```

--

```java
@Component
class AmongUsers implements Email.Uniqueness {

    private final Users users;

    @Override
    public boolean guaranteed(Email email) {
        return !users.byEmail(email).isPresent();
    }
}
```

---
class: codeonly
```java
private final Uniqueness uniqueness;

@Override
public Command.R.Void react(RegisterNewUser $) {

  Email.Unchecked email = new Email.Unchecked($.email());
  Password password = new Password($.password());

  Validator validator = new FailFastValidator();
  validator
          .whenNot(email, Email::isValid)
          .then("Sorry man, email (%s) is completely wrong.");
  validator
*         .whenNot(email.valid(), uniqueness::guaranteed)          // lazy needed
*         .then("Argh, email is taken by some hacker.");
  validator
          .when(password, Password::isWeak)
          .then("Password is too weak. Make it secure by adding some weird characters.");

  validator.throwFirst();

  ...

  return new Command.R.Void();
}
```

---
class: codeonly
```java
private final Uniqueness uniqueness;

@Override
public Command.R.Void react(RegisterNewUser $) {

  Email.Unchecked email = new Email.Unchecked($.email());
  Password password = new Password($.password());

  Validator validator = new FailFastValidator();
  validator
          .whenNot(() -> email, Email::isValid)
          .then("Sorry man, email (%s) is completely wrong.");
  validator
          .whenNot(() -> email.valid(), uniqueness::guaranteed)
          .then("Argh, email is taken by some hacker.");
  validator
          .when(() -> password, Password::isWeak)
          .then("Password is too weak. Make it secure by adding some weird characters.");

  validator.throwFirst();

  ...

  return new Command.R.Void();
}
```

---
class: codeonly
```java
interface Validator {

    <T> IfCondition when(Supplier<T> value, Predicate<T> predicate);

    <T> IfCondition whenNot(Supplier<T> value, Predicate<T> predicate);

    void throwFirst();

}
```

--

```java
class IfCondition<T> {

    private final Supplier<T> item;
    private final Predicate<T> predicate;

    private String failureMessage;

    public IfCondition(Supplier<T> item, Predicate<T> predicate) {
        this.item = item;
        this.predicate = predicate;
    }

    void then(String failureMessage) {
        this.failureMessage = failureMessage;
    }

    boolean isTrue() {
        return predicate.test(item.get());
    }

    String message() {
        return failureMessage.replaceAll("%s", item.get().toString());
    }

}
```

---
class: codeonly
```java
class FailFastValidator implements Validator {

    private final Collection<IfCondition> ifConditions = new LinkedList<>();

    @Override
    public <T> IfCondition whenNot(Supplier<T> value, Predicate<T> predicate) {
        return when(value, predicate.negate());
    }
```

```java
    @Override
    public <T> IfCondition when(Supplier<T> value, Predicate<T> predicate) {
        IfCondition<T> ifCondition = new IfCondition<>(value, predicate);
        ifConditions.add(ifCondition);
        return ifCondition;
    }

    // everythige else stays absolutely the same
}
```


---
class: center, middle
## Some more examples

---
class: codeonly
```java
validator
        .whenNot(() -> $.affiliateId(), Optional::isPresent)
        .then("Omg, missing affiliate id!");

```

--

```java


class TooShort implements Predicate<Password> {

    @Override
    public boolean test(Password pw) {
        return pw.text().length() < 10;
    }
}

class Guessable implements Predicate<Password> {

    @Override
    public boolean test(Password pw) {
        return pw.text().equals("qwerty123");
    }
}

validator
        .when($.password(), new TooShort().or(new Guessable()))
        .then("Pick a better password, dude");
```

---
class: center, middle
## Do we need Hibernate Validator aka JSR-349 RI?

---

## - validation is not a rocket science

--

## - HV works out-of-the-box with stateful Java Beans

--

## - HV requires bloody getters for method validation

--

## - HV does not work well with immutables.github.io

--

## - HV is mess when it comes to non-Java Beans

---
class: codeonly
.crap[
```java
class Email {

    private final String text;

    public Email(String text) {
      ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
      ExecutableValidator validator = factory.getValidator().forExecutables();
      Constructor<Email> constructor = getConstructorIfAvailable(Email.class, String.class);

      validator
              .validateConstructorParameters(constructor, new Object[]{text})
              .stream()
              .findAny()
              .ifPresent(violation -> {
                  throw new IllegalArgumentException(violation.getMessage());
              });

      this.text = rawText;
    }
}
```
]
???
essentially, it is out of date. Could support Java 8 method and const references instead of reflection

---
class: center, middle
## And tolerable for stateful Java Beans...
### (but your app is not only a set of stateful Java Beans, hopefully)

---
class: codeonly
```java
@Documented
@Constraint(validatedBy = { ElonMuskValidator.class })
@Target({ TYPE })
@Retention(RUNTIME)
public @interface ElonMusk {

    String message() default "{com.devchampions.ElonMusk.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
}
```

--

```java
class ElonMuskValidator implements ConstraintValidator<ElonMusk, Hiree> {

    @Override
    public void initialize(ElonMusk annotation) {}

    @Override
    public boolean isValid(Hiree hiree, ConstraintValidatorContext context) {
        if (hiree == null) {
            return true;
        }
        return hiree.hasInvented(Invention.SPACEX);
    }
}
```

---
class: codeonly
```java
class ApplyForDreamJob implements Command<Command.R.Void> {

  @ElonMusk
  private Hiree hiree;

}
```

```java
class Validable implements Now {

  private final Validator validator;

  Validable() {
    this.validator = Validation
                          .buildDefaultValidatorFactory()
                          .getValidator();
  }
```

--

```java
  public <C extends Command<R>, R extends Command.R> R execute(C command) {}
    Set<ConstraintViolation<C>> violations = validator.validate(command);
    if (!violations.isEmpty()) {
        throw new ConstraintViolationException("Boom!", violations);
    }
  }


}
```

---
class: center, middle, example
# Persistence

---
# DAO aka Data Access Object (2001)

--

### - Encapsulates access to data behind a well-defined interface

--

### - Makes client code persistence agnostic (db, ldap, rest...)

--

### - Don't do this at home:

---
class: codeonly
.crap[
```java
interface CustomerDAO {

  UUID insert(Customer customer);

  UUID insert(CustomerDTO customer);

  Customer insert(String personalId, String fullName);

  boolean saveOrUpdate(Customer customer);

  boolean updateFullname(Customer customer, String newFullName);

  boolean delete(Customer customer);

  boolean deleteByPersonalId(String personalId);

  Customer findByPersonalId(String personalId);

  Collection<Customer> findAll();

  Collection<PhoneNumber> findMobileNumbers(String personalId);

  void merge(Customer detached);

  ...
}
```
]

---
class: center, middle
# **Repository** mediates between the domain and data mapping layers using a **collection-like interface** for accessing domain objects.
### â€” *Fowler, PoEAA*

---
class: codeonly
.crap[
```java
interface CustomerDAO {
  UUID insert(Customer customer);
  UUID insert(CustomerDTO customer);
  Customer insert(String personalId, String fullName);
  boolean saveOrUpdate(Customer customer);
  boolean updateFullname(Customer customer, String newFullName);
  boolean delete(Customer customer);
  boolean deleteByPersonalId(String personalId);
  Customer findByPersonalId(String personalId);
  Collection<Customer> findAll();
  Collection<PhoneNumber> findMobileNumbers(String personalId);
  void merge(Customer detached);
  ...
}
```
]

--

```java
@ImpliesUnitOfWorkPatternWithAutoFlush
interface Customers {
  void add(Customer customer);
  void delete(Customer customer);
  Collection<Customer> all();
}

```

---
class: center, middle
## Repository is not resposible for assigning ids
### (generate ids upon entity creation)

---
class: codeonly
.crap[
```java
class Account {

    @GeneratedValue(strategy= GenerationType.AUTO)
    private UUID id;

    private String iban;

    public Account(String iban) {
        this.iban = iban;
    }
}
```
]

--

.crap[
```java
class DontDoThisAtHomeRepository implements Repository<Account> {

    public UUID add(Account account) {
      entityManager.persits(account);
      entityManager.flush();
      return account.id();
    }
}
```
]

--

```java
Account offshore = new Account("DZ4000400174401001050486");
```

--

```java
Collection<Account> accounts = new HashSet<>();
accounts.add(offshore);
```

--

```java
accountRepository.add(offshore); // generates UUID
```

--
```java
accounts.contains(offshore)      // false
```

---
class: center, middle
## Use pre-generated UUIDs
### (consider stealing Cassandra's TimeUUID)

---
class: codeonly


.nice[
```java
interface Customers extends Repository<Customer> {
    void add(Customer customer);
}
```
]

.nice[
```java
@Entity
class Customer {

    @Id
    private UUID id = UUID.randomUUID();

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Customer other = (Customer) obj;
        return Objects.equals(this.id, other.id);
    }
```
]
???
now you can use the uuds before the persistance

---
class: center, middle
# Repository communicate design decisions about object access.
### â€” *Evans, DDD*
???
- you can't derive all your repos from a single CRUD repo
- you can't design repositories like java collections :-) which are modifiable

---
class: right, middle
### .fade[For each type of object that needs global access, create an object that can] provide the illusion of an in-memory collection .fade[ of all objects of that type. Set up access through a well-known global interface. Provide methods to add and remove objects, which will encapsulate the actual insertion of removal of data in the data store. Provide methods that select objects based on some criteria and return fully instantiated objects or collections of objects whose attribute values meet the criteria, thereby encapsulating the actual storage and query technology. ]Provide repositories only for aggregate roots .fade[that actually need direct access. Keep the client focused on the model, delegating all object storage and access to the Repositories.]
### â€” *Evans, DDD*

---
class: center, middle
# An aggregate is a cluster of domain objects that can be treated as a single unit. Any references from outside the aggregate should only go to the aggregate root.
### â€” *Fowler, Bliki*

---
class: center, middle
# Aggregate root ensures consistency of an aggregate.

---
class: codeonly
```java
@Entity
class BankAccount {

    @Id
    private UUID id = UUID.randomUUID();

    @Enumerated(EnumType.STRING)
    private Status status = Status.OPEN;

    @Embedded
    private WithdrawalLimit withdrawalLimit = WithdrawalLimit.DEFAULT;

    @ElementCollection
    @CollectionTable(name = "BANK_ACCOUNT_TX")
    private List<Transaction> transactions = new ArrayList<>();

    @Version
    private long version;

    ...

```

```java
@Embeddable
class Transaction {

    private DecimalNumber amount;

    private LocalDate bookedAt = LocalDate.now();

    @Enumerated(EnumType.STRING)
    private TransactionType type;

    ...
}
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private List<Transaction> transactions = new ArrayList<>();

```

--

```java
    public DecimalNumber balance() {
        DecimalNumber totalDeposited = transactions.stream()
                .filter(tx -> tx.type().equals(DEPOSIT))
                .map(Transaction::amount)
                .reduce(new Const(0), DecimalNumber::plus);

        return transactions.stream()
                .filter(tx -> tx.type().equals(WITHDRAWAL))
                .map(Transaction::amount)
                .reduce(totalDeposited, DecimalNumber::minus);
    }
```

--

```java
    public Transaction deposit(DecimalNumber amount) {
        Domain.ensure(!isClosed(), "Cannot deposit funds to closed account.");

        Transaction depositTx = new Transaction(DEPOSIT, amount);
        transactions.add(depositTx);

        return depositTx;
    }
```

--

```java
    private boolean isClosed() {
        return status.equals(Status.CLOSED);
    }

    public void close() {
        status = Status.CLOSED;
    }
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    public Transaction withdraw(DecimalNumber amount) {
        Domain.ensure(!isClosed(), "Cannot withdraw funds from closed account.");

        Transaction withdrawalTx = new Transaction(WITHDRAWAL, amount);
        transactions.add(withdrawalTx);

        ensurePositiveBalance();
        ensureDailyWithdrawalLimitIsNotExceeded();

        return withdrawalTx;
    }

    private void ensurePositiveBalance() {
        Domain.ensure(balance().isPositive(),
          "Cannot withdraw more funds than available on your account.");
    }

```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private void ensureDailyWithdrawalLimitIsNotExceeded() {
        DecimalNumber dailyLimit = withdrawalLimit.dailyLimit();
        DecimalNumber withdrawnToday = totalWithdrawn(now());
        boolean dailyLimitExceeded = withdrawnToday.isGreaterThan(dailyLimit);
        Domain.ensure(!dailyLimitExceeded,
          "Cannot withdraw funds. Daily withdrawal limit (%s) reached.", dailyLimit);
    }

    private DecimalNumber totalWithdrawn(LocalDate bookedAt) {
        return transactions.stream()
                .filter(tx -> tx.type().equals(WITHDRAWAL))
                .filter(tx -> tx.bookedAt().isEqual(bookedAt))
                .map(Transaction::amount)
                .reduce(new Const(0), DecimalNumber::plus);
    }
}
```

---
## BankAccount gives the following guarantees:

--

### - there is no way to create withdraw/deposit a CLOSED account

--
### - there is no way to withdraw more funds than available

--

### - there is no way to withdraw more funds than allowed by a daily limit

--

### - returned Transactions fulfill all rules imposed by BankAccount
???
PLEASE MAKE THE IMMUTABLE!!!

--

### - an aggregate is protected by a single optimistic lock

--

### - lifecycle of Transactions is bound to BankAccount

---
class: bottom, middle
background-image:url(thrones_aggregate.jpg)
background-size: 50%
???
Effective Aggregate Design by Vaughn Vernon (https://vaughnvernon.co/?p=838)

---
class: center, middle
# Aggregate root defines transactional boundaries.
### ...and can only be designed after careful transactional analysis.

---
class: codeonly
```java
@Entity
@GuardedByOptimisticLock
public class Customer extends DomainEntity {

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "EMAIL_ADDRESS"))
    private Email emailAddress;

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "PASSWORD"))
    private Password password;

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "ADDRESS"))
    private Address address;

    public Customer(Email emailAddress, Password password) {
        this.emailAddress = emailAddress;
        this.password = password;
    }

    private Customer() {
    }

    public void relocateTo(Address address) {
        this.address = address;
    }

    public void changePassword(Password newPassword) {
        this.password = newPassword;
    }

}
```

---
class: codeonly

```java
@Throws(org.springframework.orm.ObjectOptimisticLockingFailureException)
void boom() {

    Customer customer = new Customer(
      new Email("hello@devchampions.com"),
      new Password("qwerty123"));

    executeInTx(() -> entityManager.persist(customer));

    CyclicBarrier coordinator = new CyclicBarrier(2);

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(Customer.class, customer.id())
              .relocateTo(new Address("New York, Central Park"));
            coordinator.await();
        })
    ).start();

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(Customer.class, customer.id())
              .changePassword(new Password("whatever"));
            coordinator.await();
        })
    ).start();
}
```

---
class: center, middle
# Map aggregates by identity, not by pointer to avoid risk of modifying more than one aggregate per transaction.
### (concurrency exceptions can reach the point where the system becomes unusable)

---
class: codeonly
```java
@Entity
class Bank extends DomainEntity {

    private String name;

    @ElementCollection
    @CollectionTable(name = "BANK_TRANSFER_AGREEMENTS")
    private Collection<TransferAgreement> transferAgreements = new ArrayList<>();

    public void sign(TransferAgreement transferAgreement) {
        transferAgreements.add(transferAgreement);
    }

    public void rename(String name) {
        this.name = name;
    }
}
```

--

```java
@Entity
class BankAccount extends DomainEntity {

    @ManyToOne
    private Bank bank;

    public BankAccount(Bank bank) {
        this.bank = bank;
    }

    public void transfer(Bank newBank, LocalDate effectiveAt) {
        Bank currentBank = this.bank;
        newBank.sign(new TransferAgreement(currentBank.id(), effectiveAt));
        this.bank = newBank;
    }
```

---
class: codeonly
```java
@Throws(org.springframework.orm.ObjectOptimisticLockingFailureException)
void boom() {
    Bank swedbank = new Bank("Swedbank");
    Bank bankOfAmerica = new Bank("Bank of America");
    BankAccount account = new BankAccount(swedbank);

    executeInTx(() ->
      persist(swedbank, bankOfAmerica, account);
    );

    CyclicBarrier coordinator = new CyclicBarrier(2);

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(Bank.class, bankOfAmerica.id())
              .transfer(newBank, now().with(lastDayOfMonth()));
            coordinator.await();
        })
    ).start();

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(Bank.class, bankOfAmerica.id())
              .rename("The Royal Bank of America");
            coordinator.await();
        })
    ).start();
}
```

---
background-image:url(eventual.jpg)
background-size: 50%

---
class: codeonly
.crap[
```java
public void acidTransfer(Bank newBank, LocalDate effectiveAt) {
    Bank currentBank = this.bank;
    newBank.sign(new TransferAgreement(currentBank.id(), effectiveAt));
    this.bank = newBank;
}
```
]

--

.nice[
```java
public void baseTransfer(Bank newBank, LocalDate effectiveAt) {
    Bank currentBank = this.bank;

    DomainEvents.durable().publish(
        new BankAccountTransferred(
            id(),
            currentBank.id(),
            newBank.id(),
            effectiveAt));

    this.bank = newBank;
}
```
]

--

```java
@RunInASeparateTransaction
@RetryBeforePanic(times = 3)
class SignInterbankTransferAgreement implements SideEffect<BankAccountTransferred> {
    @Override
    public void occur(BankAccountTransferred $) {
        Bank oldBank = banks.findBy($.oldBankId());
        Bank newBank = banks.findBy($.newBankId());
        newBank.sign(new TransferAgreement(oldBank.id(), $.effectiveAt));
    }
}
```

---
class: codeonly
.crap[
```java
class EvilBankAccountThatHoldsRefereceToBank {
    @ManyToOne
    private Bank bank;

    public void transfer(Bank newBank, LocalDate effectiveAt) {
        Bank currentBank = this.bank;
        DomainEvents.durable().publish(
           new BankAccountTransferred(
               id(),
               currentBank.id(),
               newBank.id(),
               effectiveAt
           )
        );
        this.bank = newBank;
    }
}
```
]

--

.nice[
```java
class GoodBankAccountThatReferencesBankByIdentity {
    @Embedded
    private BankId bankId;

    public void transfer(BankId newBankId, LocalDate effectiveAt) {
        BankId currentBankId = this.bankId;
        DomainEvents.durable().publish(
           new BankAccountTransferred(
               id(),
               currentBankId,
               newBankId,
               effectiveAt
           )
        );
        this.bankId = newBankId;
    }
}
```
]


---
class: center, middle, example
## an example of
# ephemeral domain events

---
class: codeonly

```java
interface DomainEvent {

    default Type type() {
        return this.getClass();
    }
}
```

--

```java
interface SideEffect<E extends DomainEvent> {

    void occur(E $);

    default TypeToken<E> eventType() {
        return new TypeToken<E>(getClass()) {
        };
    }
}
```

--

```java
interface DomainEvents {

    void publish(DomainEvent event);

    static DomainEvents ephemeral() {
        return EphemeralDomainEvents.instance();
    }

    static DomainEvents durable() {
        return DurableDomainEvents.instance();
    }
}
```

---
class: codeonly
```java
class EphemeralDomainEvents implements DomainEvents {

    private static DomainEvents instance;

    @WhyWorkStealing("http://bit.ly/forkjoinj8")
    private final ExecutorService executor = Executors.newWorkStealingPool();

    private final TransactionTemplate tx;

    private final SideEffects sideEffects;

    public EphemeralDomainEvents(SideEffects sideEffects, TransactionTemplate tx) {
        EphemeralDomainEvents.instance = this;
        ...
    }
```

--

```java
    public void publish(DomainEvent event) {
        sideEffects.byEvent(event)
                .forEach(sideEffect -> inFuture(inTx(txStatus -> sideEffect.occur(event))));
    }

    private CompletableFuture<Void> inFuture(Runnable runnable) {
        return CompletableFuture.runAsync(runnable, executor);
    }

    private Runnable inTx(Consumer<TransactionStatus> consumer) {
        return () -> tx.execute(status -> { consumer.accept(status); return empty(); });
    }
```

--

```java
    public static DomainEvents instance() {
        return checkNotNull(instance, "Ephemeral domain events have not been initialized yet.");
    }
}
```

---
class: codeonly
```java
class SideEffects {

    private final LoadingCache<Type, Collection<SideEffect>> cachedSideEffects;

    public SideEffects(ListableBeanFactory beanFactory) {
        this.cachedSideEffects = Caffeine.newBuilder()
                .build(eventType -> sideEffects(beanFactory)
                        .stream()
                        .filter(sideEffect -> sideEffect.eventType().isSupertypeOf(eventType))
                        .collect(toList()));

    }

    private Collection<SideEffect> sideEffects(ListableBeanFactory beanFactory) {
        return beanFactory
                .getBeansOfType(SideEffect.class)
                .values();
    }

    public Collection<SideEffect> byEvent(DomainEvent event) {
        return cachedSideEffects.get(event.type());
    }
}
```

---
class: center, middle
# Repositories with Spring Data JPA in one slide

---
class: codeonly
```java
@Repository
interface Customers extends JpaRepository<Customer, UUID> {

```

--

```java
    Collection<Customer> findByLastnameAndFirstnameAllIgnoreCase();
```

--

```java
    Page<Customer> findByLastnameAndFirstnameAllIgnoreCase(Pageable pageable);
```

--

```java
    Page<Customer> findByLastnameAndFirstnameAllIgnoreCase(Pageable pageable, Sort sort);
```

--

```java
    Stream<Customer> findByLastnameAndFirstnameAllIgnoreCase(...);
```

--

```java
    Slice<Customer> findByLastnameAndFirstnameAllIgnoreCase(...);
```

--

```java
    Optional<Customer> findOne(UUID id);
```

--

```java
    CompletableFuture<Customer> findOne(UUID id);
```

--

```java
}

@Repository
interface Customers extends JpaRepository<Customer, UUID>, JpaSpecificationExecutor<Customer> {
}
```

--

```java
class LongTerm implements Specification<Customer> {
    @Override
    public Predicate toPredicate(Root<Customer> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
        LocalDate longTimeAgo = LocalDate.now().minusYears(2);
        return builder.lessThan(root.get("registeredAt"), longTimeAgo);
    }
}
```

--

```java
Stream<Customer> longTermCustomers = customers.findAll(new LongTerm());
```

---
class: center, middle
## A little type-safety never killed nobody
#### http://in.relation.to/2016/04/14/emulating-property-literals-with-java-8-method-references/


---
class: codeonly
```java
class LongTerm implements Specification<Customer> {
    @Override
    public Predicate toPredicate(Root<Customer> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
        LocalDate longTimeAgo = LocalDate.now().minusYears(2);
        return builder.lessThan(root.get("registeredAt"), longTimeAgo);
    }
}
```

--

```java
class LongTerm implements Specification<Customer> {
    @Override
    public Predicate toPredicate(Root<Customer> root, CriteriaQuery<?> query, CriteriaBuilder builder) {

        Customer $ = Expressions.of(Customer.class, root);
        Expression<LocalDate> registeredAt = $.expression($::registeredAt);

        LocalDate longTimeAgo = LocalDate.now().minusYears(2);
        return builder.lessThan(registeredAt, longTimeAgo);
    }
}
```

---
# What I don't like about Spring Data JPA:
### - method naming is not really repositorish (e.g. save())

--

### - save() method calls merge() if identifier is assigned

--

### - does not work with wrapped primary keys (e.g. UserId)
--

### - adds extra bugs on top of Hibernate

--

### - may not support the latest JPA/Hibernate features

---
class: center, middle
## Great repositories without Spring Data? Easy!

---
class: codeonly
```java
interface Repository<T, ID extends Id> {
```

--

```java
    T unique(ID id);
```

--

```java
    T unique(Criterion<T> criterion);
```

--

```java
    Optional<T> uniqueOptional(ID id);
```

--

```java
    Collection<T> all(Criterion<T> criterion);
```

--

```java
    void add(T entity);
```

--

```java
    void remove(T entity);
```

--

```java
    long count(Criterion<T> criterion);

    ...
}
```

--

```java
interface Criterion<T> {

    Predicate predicate(Root<T> root, CriteriaBuilder builder);

}
```

---
class: codeonly
```java
class JpaRepository<T, ID extends Id> implements Repository<T, ID> {

    private final EntityManager entityManager;
    private final Class<T> entityType;
```

--

```java
    @Override
    public T unique(ID id) {
        return uniqueOptional(id)
                .orElseThrow(() -> new DomainEntityNotFound(id));
    }
```

--

```java
    @Override
    public Optional<T> uniqueOptional(ID id) {
        T entity = entityManager.find(entityType, id.uuid());
        return Optional.ofNullable(entity);
    }
```

--

```java
    @Override
    public T unique(Criterion<T> criterion) {
        CriteriaBuilder builder = entityManager.getCriteriaBuilder();
        CriteriaQuery<T> query = builder.createQuery(entityType);
        Root<T> root = query.from(entityType);

        Predicate predicate = criterion.predicate(root, builder);
        query.where(predicate);
        query.select(root);

        return entityManager
                .createQuery(query)
                .getSingleResult();
    }

    ...
}
```

---
class: codeonly
```java
@CanBeAutoGenerated(see = org.spr.data.repository.config.RepositoryComponentProvider.class)
@Configuration
class CustomerJpaRepository {

    @Bean
    Repository<Customer, CustomerId> repository(EntityManager entityManager) {
        return new JpaRepository<>(entityManager, Customer.class);
    }
}

```

--

```java
@Autowired
Repository<Customer, CustomerId> customers;

void addition() {
  Customer customer = new Customer(...);
  customers.add(customer);
}

void uniqueFetch(CustomerId customerId) {
  Customer unique = customers.unique(customerId);
}

void allFetch() {
  Criterion<Customer> withoutPassword = (root, builder) -> {
      Customer $ = Expressions.of(Customer.class, root);
      Expression<Password> password = $.expression($::password);
      return builder.isNull(password);
  };

  customers
    .all(withoutPassword)
    .stream()
    ...
};
```

---
class: center, middle
## Achievement unlocked: single repository means a single repository test.
### (only Specifications deserve unique tests)

---
class: codeonly
```java
class CustomerId extends Id {

    public CustomerId(UUID uuid) { super(uuid); }

    public CustomerId(Id id) { super(id); }
}
```

--

```java
@AKittenWillBeKilledIfYouForgetToImplementHashCodeAndEquals
abstract class Id {

    private UUID uuid;

    public Id(UUID uuid) {
        this.uuid = uuid;
    }

    public Id(Id id) {
        this.uuid = id.uuid();
    }

    public UUID uuid() {
        return uuid;
    }

    public <T> T as(Function<Id, T> convert) {
        return convert.apply(this);
    }
}
```

--

```java
CustomerId customerId = new CustomerId();
RecipientId recipientId = customerId.as(RecipientId::new);
```

---
class: codeonly
```java
@Entity
public class Customer {

    @javax.persistence.Id
    private UUID id = UUID.randomUUID();

    ...

    public CustomerId id() {
        return new CustomerId(id);
    }
}
```

--

```java
@MappedSuperclass
abstract class DomainEntity<ID extends Id> {

    @javax.persistence.Id
    private UUID id = UUID.randomUUID();

    protected abstract Function<UUID, ID> typesafeId();
```

--

```java
@Entity
class Customer extends DomainEntity<CustomerId> {

    @Override
    protected Function<UUID, CustomerId> typesafeId() {
        return CustomerId::new;
    }
}
```

---
class: center, middle
## Repository is not the only way...

---
class: codeonly

```java
interface RegistrationCount {

    void increment(long diff);

    void decrement(long diff);

    void reset();
}
```

--

```java
class RedisRegistrationCount implements RegistrationCount {

    private static final String KEY = "total_registrations";

    private final RedisTemplate<String, Long> redis;

    @Override
    public void increment(long diff) {
        redis.opsForValue().increment(KEY, diff);
    }

    @Override
    public void decrement(long diff) {
        redis.opsForValue().increment(KEY, -diff);
    }

    @Override
    public void reset() {
        redis.opsForValue().set(KEY, 0L);
    }
}
```

---
class: center, middle
## Prepare yourself to very uncomfortable OO code...

---
class: codeonly
```java
class Post {

  private final DataSource source;
  private final int id;
  private final String content;

  public Post(DataSource source, int id, String content) {
    ...
  }

  public int id() {
    return this.id;
  }

  public Date date() {
    return new JdbcSession(this.source)
      .sql("SELECT date FROM post WHERE id = ?")
      .set(this.number)
      .select(new SingleOutcome<Utc>(Utc.class));
  }

  public String title() {
    return new JdbcSession(this.source)
      .sql("SELECT title FROM post WHERE id = ?")
      .set(this.number)
      .select(new SingleOutcome<String>(String.class));
  }

  public void rewrite(String content) {
    return new JdbcSession(this.source)
      .sql("UPDATE post SET content=? WHERE id=?")
      .set(content)
      .set(this.id)
      .update();
  }
}
```

---
background-image:url(testcontainers.png)

---
class: codeonly
```groovy
class RedisRegistrationCountIncSpec extends Specification {

    @Subject
    RedisRegistrationCount registrationCount
```

--

```java
    @ClassRule
    @Shared
    GenericContainer redis = new GenericContainer("redis:3.0.6").withExposedPorts(6379)

```

--

```java
    def setupSpec() {
        def connectionFactory = new JedisConnectionFactory().with {
          port = redis.getMappedPort(6379)
          hostname = redis.ipAddress
        }

        def redisTemplate = new RedisTemplate(connectionFactory: connectionFactory)

        registrationCount = new RedisRegistrationCount(redisTemplate)
    }
```

--

```groovy
    def "increments counter by provided diff"() {
        when:
        registrationCount.increment(inc)

        then:
        redisTemplate.opsForValue().get("total_registrations") == total

        where:
        inc || total
        0   || 0
        1   || 1
        2   || 3
    }

    ...
}
```

---
class: center, middle, example
# Stability Patterns
## Shed Load, Bulkheads, Timeouts and Circuit Breakers

---
class: center, middle
## Load Shedding and Bulkheads with Hystrix

---
class: codeonly
```java
@Component
class PipedNow implements Now {

    ...

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Now pipe =
*               new ConcurrencyLimited(
                        new Correlable(
                                new Loggable(
                                        new Transactional(
                                                new Reacting())))));

        return pipe.execute(command);
    }
```

---
class: codeonly
```java
private class ConcurrencyLimited implements Now {

       private final Now origin;

       Hystrix(Now origin) {
           this.origin = origin;
       }

       @Override
       public <C extends Command<R>, R extends Command.R> R execute(C command) {

         HystrixCommand.Setter commandOptions = hystrixOptions(command);
         HystrixCommand<R> hystrixCommand = new HystrixCommand<R>(commandOptions) {
               @Override
               protected R run() throws Exception {
                   return origin.execute(command);
               }
         };
         return hystrixCommand.execute();
       }
```
--

```java
       private HystrixCommand.Setter hystrixOptions(Command command) {
          int concurrencyLimit = command.concurrencyLimit().orElse(10);
          return HystrixCommand.Setter
                .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
                .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                      .withExecutionIsolationStrategy(SEMAPHORE)
                      .withExecutionIsolationSemaphoreMaxConcurrentRequests(concurrencyLimit));
        }
}
```

---
class: codeonly
```java
IntStream.range(1, 10).parallel().forEach(i -> {
      logOnError(()-> new GetTotalLikes().execute(now));
      logOnError(()-> new GetTotalShares().execute(now));
});
```

--
```java
@TwoOutOfTenCommandsWillEndWith
com.netflix.hystrix.exception.HystrixRuntimeException:
  GetTotalLikes could not acquire a semaphore for execution and no fallback available.

@TwoOutOfTenCommandsWillEndWith
com.netflix.hystrix.exception.HystrixRuntimeException:
  GetTotalShares could not acquire a semaphore for execution and no fallback available.
```

--

```java
public interface Reaction<C extends Command<R>, R extends Command.R> {

    R react(C $);

    default R fallback(C $) {
        throw new UnsupportedOperationException("No fallback available.");
    }

    ...
}
```

--

```java
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes fallback(GetTotalLikes $) {
        return new TotalLikes(10000000);
    }
```

---
class: codeonly
```java
private class HystrixGuarded implements Now {
    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Reaction<C, R> reaction = reactions.byCommand(command);

        HystrixCommand.Setter commandOptions = hystrixOptions(command);
        HystrixCommand<R> hystrixCommand = new HystrixCommand<R>(commandOptions) {
            @Override
            protected R run() throws Exception {
                return reaction.react(command);
            }

            @Override
            protected R getFallback() {
                return reaction.fallback(command);
            }

        };

        return hystrixCommand.execute();
    }
}
```

--
```java
@Override
public <C extends Command<R>, R extends Command.R> R execute(C command) {
    Now pipe =
            new Correlable(
                    new Loggable(
                            new Transactional(
                                    new HystrixGuarded())));

    return pipe.execute(command);
}
```

---

class: codeonly
```java
IntStream.range(1, 10).parallel().forEach(i -> {
      logOnError(()-> new GetTotalLikes().execute(now));
      logOnError(()-> new GetTotalShares().execute(now));
});
```

--
```java
@GetTotalLikesWillAlwaysSucceed
@TwoOutOfTenCommandsWillEndWith
@AllExceptionLeadToFallbackExcept(HystrixBadRequestException.class)
com.netflix.hystrix.exception.HystrixRuntimeException:
  GetTotalShares could not acquire a semaphore for execution and no fallback available.
```

---
class: center, middle
# Timeouts


---
class: codeonly
```java
@AllCommandsRunInTheCallingThread
@AllCallingThreadsWillBlockSoon
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes react(GetTotalLikesReaction $) {
      try {
          TimeUnit.SECONDS.sleep(30);
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
      }
    }

```

--
```java
@NowAllCommandsRunInASeparateThreadPool
@BulkheadsOnSteroids
private HystrixCommand.Setter hystrixOptions(Command command) {
    int concurrencyLimit = command.concurrencyLimit().orElse(10);
    return HystrixCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
            .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                    .withExecutionIsolationStrategy(THREAD)
                    .withExecutionTimeoutInMilliseconds(1000))
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(concurrencyLimit));
}
```
???
runs in a separate thread, because Hystrix must interrupt thread. You don't want to interrupt the whole request.

---
class: center, middle
# Circuit Breaking


---
class: codeonly
```java
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes react(GetTotalLikesReaction $) {
      try {
          TimeUnit.SECONDS.sleep(30);
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
      }
    }

```

--
```java
@FallsBackImmediatelyAfterThirdAttempt
private HystrixCommand.Setter hystrixOptions(Command command) {
    int concurrencyLimit = command.concurrencyLimit().orElse(10);
    return HystrixCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
            .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
*                   .withCircuitBreakerSleepWindowInMilliseconds(30000)
*                   .withCircuitBreakerRequestVolumeThreshold(2)
                    .withExecutionIsolationStrategy(THREAD)
                    .withExecutionTimeoutInMilliseconds(1000))
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(concurrencyLimit));
}
```

---

class: center, middle, example
# Logging

---
# Slf4j please.

--

### - Bridges for all common logging frameworks

--

### - Single dependency on `slf4-api`

---
# Logback please.
### - Native, zero-overhead implementation of Slf4j

--

### - Supports configuration via flexible Groovy DSL

--

### - Supports asynchonous logging via AsyncAppender

--

### - Supports {} to variables to avoid concatenation

--
### - log.isDebugEnabled() check is [almost] obsolete.
???
- Groovy can access your classpath. So you can do type-safe stuff.
- Consider log4j 2 - faster async via disruptor, custom log levels, custom formatters, lazy args.
- Lambda support in Slf4j is planned in the next release - 1.8.

---
class: codeonly
```java
void serve(HttpRequest request) {
  MDC.put("userId", new LoggedUserId(user));

  userIdIsAvailableInThisMethod();
  andInThisOneToo();

  MDC.remove("userId");
}
```

--

```groovy


import ch.qos.logback.classic.encoder.PatternLayoutEncoder
import ch.qos.logback.core.ConsoleAppender
appender("STDOUT", ConsoleAppender) {
    encoder(PatternLayoutEncoder) {
      pattern = "[%thread] %mdc{userId:-UNKNOWN} - %msg%n"
    }
}
root DEBUG, ["STDOUT"]
```
???
- so you don't have to pass userId every time you log the message.
- every log message will contain a userId information.

---
class: codeonly
```java
class Tx {

  static Marker CHATOPS = MarkerManager.getMarker("CHATOPS");

  void execute() {
    log.error(CHATOPS, "Oh sh%t, transaction failed", new Tx.Failed(cause));
  }
}
```

--

```groovy



import ch.qos.logback.classic.encoder.PatternLayoutEncoder
import ch.qos.logback.core.ConsoleAppender
appender("DEFAULT", ConsoleAppender) {
    encoder(PatternLayoutEncoder) {
        pattern = "%m%n"
    }
}
appender("CHATOPS", SlackAppender) {
    channel = "chatops"
    filter(EvaluatorFilter) {
        evaluator(OnMarkerEvaluator) { marker = "CHATOPS" }
        onMatch = "ACCEPT"
    }
}

root DEBUG, ["DEFAULT", "CHATOPS"]
```
???
- you also filter-out messages for a given marker (e.g. commands that do not need to be logged)

---
background-image:url(12factor.jpg)
???
- Software must write to sysout
- Fluentd

---
class: codeonly

.crap[
```java
class Command {

    String username;

    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }
}
```
]

--

.crap[
```java
log.info("Command received", command);
```
]

---

class: codeonly

.crap[
```java
class Command {

    String username;
    String password;

    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }
}

log.info("Command received", command);
```
]


---
class: codeonly
.nice[
```java
class Command implements Loggable {

    String username;
    String password;

    @Override
    public String toLogString() {
        return Joiner.on(' ').join(username, "********");
    }
}

log.info("Command received", command.toLogString());
```
]

---
class: codeonly
```java
@DoubleLoggingBecauseIDoBothLoggingAndThrowing
class Mailgun {
    void send(Email email) {
      try {
          // try to send email...
      } catch(IOException e) {
*           log.error("Mailgun is unavailable", e);
          throw new MailgunUnavailable("Mailgun is unavailable", e);
      }
    }
}

class SubscriptionReminder {
    Mailgun mailgun;
    void remind() {
        Email email = new Email(...);
        try {
          mailgun.send(email);
        } catch (MailgunUnavailable e) {
*         log(e);
          reschedule();
        }
    }
}
```
???
- MESS in log files. Same shit many times.
- VERY common and hard to make right.
- preserve exception cause hierarchy.

---
class: codeonly
```java
@LogOrRethrowAndNeverDoBoth
class Mailgun {
    void send(Email email) {
      try {
          // try to send email...
      } catch(IOException e) {
          throw new MailgunUnavailable("Mailgun is unavailable", e);
      }
    }
}

class SubscriptionReminder {
    Mailgun mailgun;
    void remind() {
        Email email = new Email(...);
        try {
          mailgun.send(email);
        } catch (MailgunUnavailable e) {
*         log(e);
          reschedule();
        }
    }
}
```
???
- Hei, fucking handle me, calle!
- This why the idea of CHECKED exception is not THAT bad :-)
- log(e) and reschedule() level of abstraction!!!

---
class: codeonly
```java
@LoggingCanBeTested
class Vault {

    private final Logger log;
    private final String accessToken;

    public Vault(String accessToken) {
        this(accessToken, LoggerFactory.getLogger(Vault.class));
    }
```

--

```java
    @VisibleForTesting
    Vault(String accessToken, Logger log) {
        this.accessToken = accessToken;
        this.log = log;
    }

}
```

--

```groovy
class VaultSpec extends Specification {

    def logger = Mock(Logger.class)

    @Subject
    def vault = new Vault("someToken", logger);

    def "rules the world" {
        expect:
        1 * logger.info("The world is mine")
    }

}
```

---
class: codeonly
```java
 @Rule
 public LogbackVerifier logbackVerifier = new LogbackVerifier();

    private MyTestedService service = new MyTestedService();

    @Test
    public void verifyGoodScenario() throws Exception {
        service.doJob();
        logbackVerifier.expectMessage(Level.INFO, "it worked");
    }
```

---
class: codeonly
```java
public class LogbackVerifier implements TestRule {

    private Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    private Appender<ILoggingEvent> appender = ... // your Appender impl.

    @Override
    public Statement apply(final Statement base, Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                before();
                try {
                    base.evaluate();
                    verify();
                } finally {
                    after();
                }
            }
        };
    }

    private void before() {
        rootLogger.addAppender(appender);
    }

    private void after() {
        rootLogger.detachAppender(appender);
    }

    private void verify() { ... }

    public void expectMessage(Level level, String message) { ... }

}
```

---
class: center, middle
# You made it! Now books...

---
background-image:url(goodreads.png)
background-size: 100%

---
background-image:url(twitter.png)
background-size: 100%

---
background-image:url(books1.png)
background-size: 100%

---
background-image:url(books2.png)
background-size: 100%

---
background-image:url(wtw.png)
background-size: 100%


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        slideNumberFormat: function (current, total) { return "" }
      });
    </script>

  </body>
</html>
