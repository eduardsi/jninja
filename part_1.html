<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="ocean.css" />
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .large code { font-size: 1.5em }
      .large .hljs-comment { color: white !important}
      .squeez h3 { margin: 0.5em }
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }
      /* new */
      .example { background-color: #007ebc}
      .example h2 { color: #00394f; font-weight: bold; line-height: 0;}
      .example h1 { color: #fff; font-weight: bold; background-color: #00394f; padding: 10px }

      .codeonly h1, .codeonly h2, .codeonly h3 { color: white }
      .codeonly { padding: 1em; background-color: #2b303b }
      .codeonly pre { margin: 0 }

      .remark-code-line-highlighted { background-color: #2d9967; color: white}
      .remark-code-line-highlighted * { color: white !important; }

      .remark-slide-scaler { -webkit-box-shadow: 0 !important; box-shadow: none !important; }
      .remark-slide-container {background-color: #2b303b}
      /* new end */
      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
      .img100 img { width: 100%}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle, example
# Effective Java Software Design
## (Java 9 edition)
???
- Introduce myself and let others introduce themselves.
- Setting expectations
- Not Java 8 course

---
class: squeez
# Part I

--

## - java updates (relevant to design) in a few slides

--

## - software design economics

--

## - naming &amp; OO construction

--

## - fighting nulls

--

## - abstraction

--

## - fighting feature bloat

---
# Part II

--

## - application layer

--

## - tx

--

## - validation

--

## - persistence

--

## - fault tolerance

---

# Part III

--

## - Homework

--

## - Homework review

---
class: center, middle
# Part I

---
class: center, middle, example
# Java updates relevant to design
## (in a few slides)
---
###**java.time** (Clock, Instant, LocalDate, TemporalAdjuster)
???
No Joda anymore.
--

###**streams** (collections, arrays, chars, files etc.)

--

###**lambdas**

--

###**@FunctionalInterface** (Function, Predicate, Consumer, Supplier)

--

###**method references** (Class::new, instance::method)

--

###**default methods**

--

###**modularity**

--

###**java.lang.reflect.Parameter** (--parameters compiler argument)

---
class: codeonly
.nice[
```java
@RestController
class RegistrationEndpoint {
  @PostMapping
  void post(@RequestParam String username) { ... }
}
```
]

--

.nice[
```java
class MethodArgumentNames {

  void print() {
      Method[] methods = RegistrationEndpoint.class.getDeclaredMethods();
      Arrays
          .stream(methods)
          .flatMap(method -> stream(method.getParameters()))
          .map(Parameter::getName)
          .forEach(System.out::println); // arg0 or username
  }  
}
```
]

--

### Any design smells?

---
class: codeonly
### Don't mix arrows and method references within a Monad
.nice[
```java
class MethodArgumentNames {

  void print() {
    Method[] methods = RegistrationEndpoint.class.getDeclaredMethods();
    Arrays
        .stream(methods)
*       .flatMap(this::parameters)
        .map(Parameter::getName)
        .forEach(System.out::println);
  }

  private Stream<Parameter> parameters(Method method) {
     return Arrays.stream(method.getParameters());
  }  
}

```
]

---
class: codeonly
### +1 requirement: fail fast if parameter names are not accessible

--

.nice[
```java
class MethodArgumentNames {

  void print() {
    Method[] methods = RegistrationEndpoint.class.getDeclaredMethods();
    Arrays
        .stream(methods)
        .flatMap(this::parameters)
*       .map(this::name)
        .forEach(System.out::println);
  }

  private String name(Parameter parameter) {
      boolean parameterHasAName = parameter.isNamePresent();
      checkArgument(parameterHasAName,
        "Parameter %s does not have a name. Please compile with --parameter flag", parameter);
      return parameter.getName();
  }
}
```
]

--

### Can we do any better?

---
class: codeonly

### Move code to the place it belongs to

--

.nice[
```java
class MethodArgumentNames {

  void print() {
    Method[] methods = RegistrationEndpoint.class.getDeclaredMethods();
    Arrays
        .stream(methods)
        .flatMap(this::parameters)
*       .map(ParameterName::new)
        .forEach(System.out::println);
  }

  private class ParameterName {
      ParameterName(Parameter parameter) {
          boolean parameterHasAName = parameter.isNamePresent();
          checkArgument(parameterHasAName,
              "Parameter %s does not have a name. Please compile with --parameter flag", parameter);
          this.textualName = parameter.getName();
      }
      @Override
      public String toString() {
          return this.textualName;
      }
  }
}
```
]

---
class: codeonly
### **implicit conversion**

```java
class BitcoinExchange {
    BitcoinExchange(BitcoinExchange.Rate rate) {
        this.rate = rate;
    }
    void sell(Bitcoin btc) { ... rate.decimal() ... }
    void buy(Bitcoin btc) { ... rate.decimal() ... }

    @FunctionalInterface
    interface Rate {
        BigDecimal decimal();
    }
}
```

--
```java
class Coinbase {
    public BigDecimal exchangeRate() {
        return remoteApi.fetchExchangeRate();
    }
}
```

--

```java
Coinbase coinbase = new Coinbase();
```
--

```java
*BitcoinExchange exchange = new BitcoinExchange(coinbase::exchangeRate);
```

### no need to implement BitcoinExchange.Rate interface 

---

class: center, middle, codeonly
# Take-away: stick to Interface Segregation Principle. 
### @FunctionalInterface is your best friend

---
class: codeonly
```java
@FunctionalInterface
interface FileFactory {
    File newFile(String name);
}
```

--

```java
class Framework {
    Framework(FileFactory fileFactory) { ... }
}
```

--

.crap[
```java
@BeforeJava(8)
class SimpleFileFactory implements FileFactory {
    @Override
    public File newFile(String name) {
        return new File(name);
    }
}

Framework framework = new Framework(new SimpleFileFactory());
```
]

--

.crap[
```java
Framework framework = new Framework(name -> new File(name));
```
]

--

.nice[
```java
Framework framework = new Framework(File::new);
```
]
???
conclusion: factories can be partially eliminated.

---
class: codeonly
### **checked exception in lambdas**
.crap[
```java
    int from = 8000;
    int to = 9000;
    IntStream
              .rangeClosed(from, to)
              .mapToObj(Port::new)
              .filter(p -> {
                  try {
                      return p.free();
                  } catch (IOException e) {
                      throw new RuntimeException(e);
                  }
              })
              .findFirst();
```
]

--

class: codeonly

### noexception.machinezoo.com

.nice[
```java
    IntStream
            .rangeClosed(from, to)
            .mapToObj(Port::new)
            .filter(Exceptions.sneak().predicate(Port::free))
            .findFirst();
```
]

---
class: codeonly

.crap[
```java
    Master master = new Master();
    Slave slave = new Slave();

    Connection connection;
    try {
        connection = master.connection();
    } catch (RuntimeException e) {
        log.warning(e);
        connection = slave.connection();
    }
```
]

--

.nice[
```java
    Connection connection = Exceptions
      .log()
      .get(master::connection)
      .orElseGet(slave::connection);
```
]

---
class: center, middle, example
# The economics of software design 101
???
Before HOW -> WHY

---
class: center, middle
# There is a strong correlation between quality of the codebase and developer productivity or **throughput**.
## (c) me
???
- The higher is quality, the higher is productivity. And vice versa.
- Everyone agrees?!
- Productivity - TIME we spend per CHANGE.

---
class: middle
# <span class="ktx" expr="Throughput = \dfrac{RTF}{TIME}"></span>
#### *RTF - Released Tested Features (c) [The Economics of Software Design](https://www.youtube.com/watch?v=7HecgbghFTk), J.B. Rainsberger *
???

---
class: center, middle
# Higher throughput = lower **cost per change**.
#### <span class="ktx" expr="cost\,per\,change = time\,spent\,on\,change\,\times salary"></span>

---
class: center, middle
# Why do these guys move so slow?!
???
Low throughput

---
class: center, middle
# Why are these guys so expensive?!
???
High CPC (low throghput; too low for given salary!!!)


---
class: center, middle
# By writing clean code, you enable **stable throughput / responsiveness over time**.
### (the time that is usually longer than your employment)
???
- The goal of design is to be able to ship as fast as we can now not only in the next 3 months, but in years etc.
- Unfortunately, we do not usually know see long-term consequences of our work, but we should.
- For example, my best friend is now maintaining a software that I wrote 6 years ago :-)


---
name: throughput
<div id="throughput" style="width: 100%; height: 100%;"></div>
???
- team is slow and becomes a bottleneck to make world a better place :-) New teams, rewrites etc.
- a nice thing about sustainable pace that I can estimate.
- Do you know the rule that makes throughput gradually grow? BS rule. That's how we escale from SHIT.
- Can someone explain why throughput drops that fast?

---
#  Reinforcing loops:

--

### low throughput -> pressure -> more corners cut -> lower throghput

--
### low throughput -> unmet deadlines -> more people to work on features -> lower throughput (Brook's Law)

--

### low quality tolerated -> lower quality (Broken window theory)

--

### Graham's Law
???
- BWT - if there is mess, or rush, you don't be the first to make a mess.
- Graham's law - Shitty component remain a part of the system over time precisely because it's hard to take out. Conversely, a component that is easy to replace is one that we may replace.

---
class: center, middle
# Technical debt


---
class: center, middle
##  Technical debt is a metaphor to express cumulative **future** consequences of corners being cut.
---
name: debt
<div id="debt" style="width: 100%; height: 100%;"></div>
???
- TD - cumulative future consequences of corners being cut.
- In this example, we pay TD in terms of throughput.
- TD is about future. And we want future US to thank us in future.

---
class: center, middle
# ?
???
- raise your hand who thinks technical debt is a bad thing?
- who thinks it's a good thing?
- is taking a loan a bad thing?
- is taking and loan and not returning it back for a long time - a bad thing?

---
class: center, middle
# Technical debt is a **tool** for gaining a **short-term** gain. **Needs to be carefully managed**.
???
- Spike and Throwaway! (Dan North). E.g. TDDing at this level is kinda waste.
- Meeting deadline (critical problem, black swan events -> unexpected prospect)

---
class: conversation
### **Manager**: When will the new permission be done?

--

### **Dev**: Mmmm, I hope tomorrow, in the end of the day.

--

### **Manager**: We need it today. Can’t you find a “creative” way to do it?

--

### **Dev**: Let me think…

--

### **Manager**: We have 5 clients that really need this today. Else they will probably not sign the contract.

--

### **Dev**: But the…

--

### **Manager**: Look, it’s important that you understand the business value of it. Isn’t it just a new condition in the code? Just put it there, and we’ll “fix it” later.

--

### **Dev**: Ok.

--

### **Manager**: So we’ll be able to deploy today?

--

### **Dev**: Aham.

#### *— [Technical Debt 101](https://medium.com/@joaomilho/festina-lente-e29070811b84#.7d8asvofr)*

---
class: bottom, right
background-image:url(techDebtQuadrant.png)
#### *Technical debt quadrant: http://martinfowler.com/bliki/TechnicalDebtQuadrant.html*
???
- reckless - we focus on completing tasks fast instead of building HQ system. Boil like frogs.
- It's often the case that it can take a year of programming on a project before you understand what the best design approach should have be.

---
class: center, middle, bad
# The only way to go fast is to go well.
### (c) Uncle Bob
???
really?

---
class: center, middle, oki
# The only way to go fast [in a long run] is to go well.
### (c) Uncle Bob (edited)

---
class: center, middle
# Does writing clean code take more time than writing crap?
???
- SOMETIMES writing takes longer. But it makes READING easier.

---
class: center, middle
# Reading vs. writing ratio is 10:1.
???
we want reading to be easy if it makes writing harder. Making code easy to read, makes it easier to write.

---
class: center, middle
# There are people who write clean code blazingly fast.
???
I saw master at work. You can be that master. Skill acquisition graph (performance over time)

---
class: center, middle
# If something is not worth our time, consider not doing it.
![](stepsofmastery.png)
???
- Avoiding it - nice! less INHERENT COMPLEXITY. less code to maintain.
- Agile Manifesto principle. Simplicity — the art of maximizing the amount of work not done.
- First law of software quality: e = mc^2 ; errors = (more code)^2

---
class: center, middle
# Consider your reputation.
???


---
background-image:url(SonarQube-02.png)
background-size: 100%
???
- not used
- running on every push
- before every push (https://hub.docker.com/_/sonarqube)
- running on every code change

---
class: lint
background-image:url(sonarlint.png)
background-size: 100%

---
class: center, middle, example
# Naming

---
class: codeonly
.crap[
```java
@AstonishingTwilioApi
class Example {

  public static final String ACCOUNT_SID = "{{ account_sid }}";
  public static final String AUTH_TOKEN = "{{ auth_token }}";

  public static void main(String[] args) throws TwilioRestException {
    TwilioRestClient client = new TwilioRestClient(ACCOUNT_SID, AUTH_TOKEN);

    List<NameValuePair> params = new ArrayList<NameValuePair>();
    params.add(new BasicNameValuePair("Body", "Hello from Java"));
    params.add(new BasicNameValuePair("To", "+12345678901"));
    params.add(new BasicNameValuePair("From", "+12345678901"));

    MessageFactory messageFactory = client.getAccount().getMessageFactory();
    Message message = messageFactory.create(params);
  }
}
```
]
???
- Stroup effect
- Naming issues has cumulative effect
- The code is not HONEST.

---
class: codeonly
```java
@WhatDoYouExpectToHappen
void code() {
  Entity entity ...
  dao.update(entity);
}
```

--

.crap[
```java
void update(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
}
```
]

--

.nice[
```java
void update(Entity entity) {
  checkArgument(entity.isIdAssigned(), "Cannot update entity. Id is missing");
  ...
}
```
]

--

```java
void updateIfIdAssigned(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
  ...
}
```

---
class: codeonly
.crap[
```java
interface Employee {
  String employeeAddress();
}
```
]

--

.nice[
```java
interface Employee {
  String address();
}
```
]

--

.crap[
```java
class Transaction {
  enum TransactionScope { }
}
```
]

--

.nice[
```java
class Transaction {
  enum Scope { }
}
```
]

--

.crap[
```java
@PackagesAreExceptionToTheRule
package org.framework.batch
interface Reader { }
interface Operation { }
```
]

--

.nice[
```java
interface BatchReader { }
interface BatchOperation { }
```
]

--

.nice[
```java
interface Batch {
  interface Reader { }
  interface Operation { }
}
```
]

---
class: codeonly
.crap[
```java
// incBy – preposition, not a noun
interface Counter {
  void increment(long incBy) { this.current += incBy }
}
```
]
???
by – PREPOSITION (followd by NOUN) in English.

--

.crap[
```java
interface Counter {
  // do we increment counter or ask counter to increment the value?
  void increment(long value) { this.current += value } 
}
```
]

--

.crap[
```java
interface Counter {
  // too generic, if working with a code when the method's signature is not visible
  void incrementBy(long value) { this.current += value } 
}
```
]

--

.nice[
```java
interface Counter {
  // finally!
  void incrementBy(long adjunct) { this.current += adjunct }
}
```
]

--

.crap[
```java
class Widget {
    private long length;
```
]

--

.crap[
```java
class Widget {
    private long lengthInPixels;
```
]

--

.nice[
```java
class Widget {
    private Pixels length;
```
]

--

.crap[
```java
interface Movie {
    void stream(Channel channel);
```
]

--

.crap[
```java
interface Movie {
    void streamInto(Channel channel);
```
]

---
class: codeonly

# Code must speak the domain language

.crap[
```java
  class BillingAgreement {
      private LocalDate startingDate;
```
]

--

.nice[
```java
  class BillingAgreement {
      private LocalDate asOfDate;
```
]

--

.crap[
```java
  class Payment {
      private LocalDate maxPaymentDate;
```
]

--

.nice[
```java
  class Payment {
      private LocalDate dueDate;
```
]

--

.crap[
```java
  class Loan {
      private Customer customer;
```
]

--

.nice[
```java
  class Loan {
      private Borrower borrower;
```
]

---
class: center, middle
## Compound names usually indicate a missing root object

---
class: codeonly
```java
class AwsS3Bucket {

  private final String awsPassword;
  private final String awsLogin;
  private final String bucketName;

  public AwsS3Bucket(String awsLogin, String awsPassword, String bucketName) {
    this.awsLogin = awsLogin;
    this.awsPassword = awsPassword;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

--

```java
class AwsCredentials {

  public final String login;
  public final String password;

  public AwsCredentials(String login, String password) {
    this.login = login;
    this.password = password;
  }
}
```

---
class: codeonly
```java
class AwsS3Bucket {

  private final AWSCredentials awsCredentials;
  private final String bucketName;

  public AwsS3Bucket(AwsCredentials awsCredentials, String bucketName) {
    this.awsCredentials = awsCredentials;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

--

```java
class AwsAccount {

  private final AwsCredentials credentials;

  public AwsAccount(AwsCredentials credentials) {
    this.credentials = credentials;
  }

}
```

---
class: codeonly
```java
class AwsS3Bucket {

  private final AwsAccount account;
  private final String name;

  public AwsS3Bucket(AwsAccount account, String name) {
    this.account = account;
    this.name = name;
  }

  void create() {
    ...
  }

}
```

---
class: codeonly
.crap[
```java
interface SpotifyApp {
    void playMusic();
    void stopMusic();
}
```
]

--

.nice[
```java
interface Music {
    void stop();
    void play();
}
```
]

--

.nice[
```java
interface SpotifyApp {
    Music music();
}
```
]

--

class: codeonly
.crap[
```java
interface HipChat {
    void sendMessage(String channel, String mesage);
}
```
]

--

class: codeonly
.nice[
```java
interface Channel {
    void send(String message);
}
```
]

--

.nice[
```java
interface HipChat {
    Channel channel(String name);
}
```
]

---
class: center, middle
## Avoid dumb suffixes when possible
### (but always stay consistent)



---
class: codeonly
.crap[
```java
class CancelTransactionAction { }
class ApplyForLoanAction { }
class AskQuestionAction { }
class ReportSpammerAction { }
```
]

--

.crap[
```java
class CancelTransactionCommand { }
class ApplyForLoanCommand { }
class AskQuestionCommand { }
class ReportSpammerCommand { }
```
]

--

### **Verb** – a word used to describe an action, state, or occurrence.
### **Verbs are actions by default**

--

.nice[
```java
class CancelTransaction { }
class ApplyForLoan { }
class AskQuestion { }
class ReportSpammer { }
```
]

---
class: codeonly

### exceptions are events. "what has happened?" in past tense

--

```java
class RuleException { }                                          // what is that?
```

--

.crap[
```java
class RuleExceptionException { }                                 // oh shit
```
]

--

.nice[
```java
class RuleExceptionIncorrectlyApplied { }                        // great
```
]

--

.crap[
```java
class ExecutionTimeoutException extends ... { }                  // dumb suffix
```
]

--

.crap[
```java
class ExecutionTimeout extends ... { }                           // confusing noun
```
]

--

.nice[
```java
class ExecutionTimedOut extends ... { }                          // great
```
]


.nice[
```java
class ExecutionTookTooLong extends ... { }                       // great
```
]

--

.crap[
```java
class OverlappingFileLockException extends ... { }               // dumb suffix
```
]

--

.nice[
```java
class FileLockAcquisitionFailed extends ... { }                  // great
```
]

--

.crap[
```java
class WebDriverException extends ... { }                         
```
]

--

.nice[
```java
class WebDriverCrashed extends ... { }                         
```
]

--

.crap[
```java
class BrowserNotSupportedException extends ... { }                         
```
]

--

.nice[
```java
class UnsupportedBrowserProvided extends ... { }                         
```
]

--

.crap[
```java
class InvisibleButtonException extends ... { }                         
```
]

--

.nice[
```java
class InvisibleButtonClicked extends ... { }                         
```
]

---
class: center, middle
# Move from **f(o)** to **o.f()**
### (encapsulate state)

---
class: codeonly

```java
class File { }
```

--

.crap[
```java
class FileReader {
   String read(File file) { ... }
}
```
]

--

.crap[
```java
class FileReader {
   String read(File file) { ... }
   String read(Path path) { ... }   
}
```
]

--

.nice[
```java
class TextFile {
   TextFile(Path) { ... }
   TextFile(File) { ... }
   String text();
}
```
]

--

.crap[
```java
class FileReader {
   ...  
   boolean hasText(File file) { ... }
   boolean hasText(Path file) { ... }
}
```
]

--

.nice[
```java
class TextFile {
   ...
   boolean isEmpty();
}
```
]

---
class: codeonly

.nice[
```java
class TextFile {
   TextFile(Path) { ... }
   TextFile(File) { ... }
   String text();
}
```
]

--

.crap[
```java
class TextFile {
   TextFile(Path) { ... }
   TextFile(File) { ... }
   String text();
   byte[] binary();
}
```
]

--

.nice[
```java
class TextFile {
   TextFile(Path) { ... }
   TextFile(File) { ... }
   Content content();
}
```
]

.nice[
```java
class Content {
   String textual() { ... };
   byte[] binary() { ... };
}
```
]

---
class: codeonly
.crap[
```java
interface EmailSender {
  void send(Email email);
}
```
]

--

.nice[
```java
interface Email {
  void deliver();
}
```]

--

.crap[
```java
interface ConditionChecker {
  boolean checkCondition(Condition condition)
}
```
]

--

.nice[```java
interface Condition {
  boolean isFulfilled();
}
```
]

--

.crap[
```java
interface CredentialValidator {
  boolean validated(String username, String password);
}
```
]

--

.nice[```java
interface Credentials {
  boolean areValid();
}
```
]

---
class: codeonly

.crap[
```java
class BankAccount {
  private Collection<Transactions> transactions;
  void exportTransactions(Period period, Media media) {}
}
```
]

### For some reason, we want to move transaction exporting to a separate class...

--

.crap[
```java
class TransactionExporter {
  void export(BankAccount account, Period period, Media media) { ... }
}
```
]

--

.nice[
```java
class BankAccount {
  private Collection<Transactions> transactions;
  TransactionsForExport transactions(Period period) {}
}

class TransactionsForExport {
  private Period period;
  void export(Media media);
}
```
]

--

.nice[
```java
class BankAccount {
  private Collection<Transactions> transactions;
  BankStatement statement(Period period) {}
}

class BankStatement {
  private Period period;
  void export(Media media);
}
```
]

---
class: codeonly
.crap[
```java
interface MoneyFormatter {
  String format(Money money);
}
```
]

--

.nice[
```java
String ? = money.format(FormatSpecification specification)
```
]

--

.nice[
```java
interface PrettyMoney {

  String asText();
```
]

--

.nice[
```java
  class Humane implements PrettyMoney {
    @Override
    public String asText() { ... }
  }
```
]
--

.nice[
```java
  class ISO_1234 implements PrettyMoney {
    @Override
    public String asText() { ... }
  }

}
```
]

--

```java
public static void main(String[] args) {
    Money money = new Money(99.00);
    PrettyMoney prettyMoney = new PrettyMoney.Humane(money);
    println(prettyMoney.asText());
}
```
???
- makes our software more OO, composable from classes, not methods
- why not MoneyFormat?
- why not toString()

---
class: codeonly
.crap[
```java
class FuckupProbabilityCalculator {
    BigDecimal calculate() { ... }
}
```]

--

![](fuckupdecimal.png)

---
class: codeonly

.nice[
```java
interface DecimalNumber {

    BigDecimal decimal();
```
]

--

.nice[
```java
    default DecimalNumber dividedBy(DecimalNumber divisor) {
        BigDecimal roundedDivision = decimal().divide(
            divisor.decimal(), RoundingMode.ROUND_UNNECESSARY);
        return new Const(roundedDivision);
    }

    ...

}```
]

--

.nice[
```java
class Const implements DecimalNumber {

    private final BigDecimal origin;
```
]

--

.nice[
```java
    public Const(int origin) {
      this(new BigDecimal(origin));
    }
```
]

--

.nice[
```java
    public Const(BigDecimal origin) {
      this.origin = origin.setScale(2, BigDecimal.ROUND_UNNECESSARY);
    }
```
]

--

.nice[
```java
    @Override
    public BigDecimal decimal() {
      return origin;
    }
}
```
]

---
class: codeonly

.nice[
```java
class FuckupProbability implements DecimalNumber {

    private final SecureRandom random = new SecureRandom();

    @Override
    public BigDecimal decimal() {
      return new BigDecimal(random.nextInt());
    }
}
```]

--

.nice[
```java
void wunderDemo() {
    DecimalNumber one = new FuckupProbability();
    DecimalNumber another = new FuckupProbability();
```
]

--

.nice[
```java
    DecimalNumber average = one.plus(another).dividedBy(new Const(2));
```
]

--

.nice[
```java
    DecimalNumber average = new Average(one, another);
}
```
]

--

.nice[
```java
class Average implements DecimalNumber {

    private final DecimalNumber[] numbers;

    public Average(DecimalNumber... numbers) {
        this.numbers = numbers;
    }

    @Override
    public BigDecimal decimal() {
        DecimalNumber total = new Const(numbers.length);
        DecimalNumber sum = new Sum(numbers);
        DecimalNumber average = sum.dividedBy(total);
        return average.decimal();
    }

}
```
]

---
class: codeonly
.crap[
```java
@Goodbye
public final class BigDecimalUtils {

    public static final int AMOUNT_SCALE = 2;

    private BigDecimalUtils() {
    }

    public static BigDecimal amount(int value) {
      return amount(new BigDecimal(value));
    }

    public static BigDecimal amount(BigDecimal amount) {
      return amount.setScale(AMOUNT_SCALE, BigDecimal.ROUND_HALF_UP);
    }

    public static boolean isEqual(BigDecimal value1, BigDecimal value2) {
      boolean isEqual = value1.compareTo(value2) == 0;
      return isEqual;
    }

    public static boolean isInRange(BigDecimal amount, BigDecimal amountFrom, BigDecimal amountTo) {
      return isGe(amount, amountFrom) && isLe(amount, amountTo);
    }

    public static boolean isZero(BigDecimal value) {
      return isEqual(BigDecimal.ZERO, value);
    }

  ...

}
```
]
---
class: center, middle
# Methods are either **commands** or **queries**.
### Use commands (verbs) to tell an object what to do.
### With queries (nouns) you ask object to give something.
— *[Command/Query Separation](http://martinfowler.com/bliki/CommandQuerySeparation.html)*

---
class: codeonly
.crap[
```java
interface Iterator<T> {

  @NounWithASideAffect
  @ViolatesCqs
  T next();
}
```
]

--

.nice[
```java
interface Iterator<T> {

  @VerbThatReturnsNothing
  void advance();

  @NounThatReturnsStuff
  T current();
}
```
]

--

.crap[
```java
@VerbThatReturnsStuff
InputStream load(URL url);
```
]

--

.nice[
```java
@NounThatReturnsStuff
InputStream stream(URL url);
```
]

--

.crap[
```java
@VerbThatReturnsStuff
String read(File file);
```
]

--

.nice[
```java
@NounThatReturnsStuff
String content(File file);
```
]

---
class: codeonly

.crap[
```java
interface Document {

  BytesWritten writeInto(OutputStream output);
}
```
]

--

.nice[
```java
interface Document {

   OutputPipe output();
}
```
]

--

```java
interface OutputPipe {}

     void write();

     BytesWritten bytesWritten();

     Duration timeTaken();
}
```

---
class: center, middle
# Never use getters in your OO code.

---

## Getters are verbs

--

## Get **may** have a side effect

--

### - get married

--

### - get money from the ATM

--

### - get from A to B...

---
class: codeonly
```java
class Client {
  String fullName();
  String personalId();
}
```
???
consider readability if (client.fullName()) vs. if (client.getFullName())

--

```java
interface Iterator<T> {
  T current();
}
```

---
class: center, middle
## Blindly removing get\* prefix will remove noise, but won't make your code more object-oriented.
### **Tell, don't ask** as much as you can.


---
class: center, middle
# Never use setters in your OO code.

---
class: codeonly
.crap[
```java
Borrower borrower = new Borrower();
borrower.setFirstName(firstName);
borrower.setLastName(lastName);
```
]

--

.nice[
```java
borrower.giveName(String firstName, String lastName);
```
]
???
grant permissions vs. set permissions

--

.crap[
```java
borrower.setAcceptedAgreementType(AgreementType acceptedAgreementType);
```
]

--

.nice[
```java
borrower.accept(Agreement agreement);
```
]

--

.crap[
```java
agreement.setSigned(boolean agreementSigned);
```
]

--

.nice[
```java
agreement.sign();
```
]

--

.nice[
```java
agreement.callOff();
```
]

--

.crap[
```java
user.setTwitter(Twitter twitter);
```
]

--

.nice[
```java
user.establish(TwitterPresence twitterPresence);
```
]

--

.crap[
```java
blog.setTags(Tag... tags);
```
]

--

.nice[
```java
blog.tag(Tag... tag);
```
]

--

.nice[
```java
conference.addSpeaker(Speaker speaker);
```
]

--

.crap[
```java
conference.accept(Speaker speaker);
```
]


---
class: codeonly

.crap[
```java
Bank bank = new Bank();
bank.setCode(...);
bank.setName(...);
bank.setBic(...);
```
]

--

.nice[
```java
@OnlyNameChangeIsAllowedAndIdentityStaysImmutable
Bank bank = new Bank(code, name, bic);
bank.rename(...);
```
]

--

### what if need to change bank identity due to acquisition by another bank?

--

.nice[
```java
Bank bank = ...
Bank anotherBank = new Bank(code, name, bic);
bank.become(anotherBank);
```
]

---
# Data structures

--

## - DTOs, Java beans...

--

## - do not have behaviour

--

## - **can** have getters and setters (but should they?)

--

## - **must not** be confused with DDD value objects
???
- immutable
- can have some behaviour

---
class: codeonly
```java
@QuiteALotOfNoise
class User {

    private String firstName;
    private String lastName;
    private Optional<String> middleName = Optional.empty();

    public User(String firstName, String lastName) {
        ...
    }

    public User withMiddleName(String middleName) {
        this.middleName = Optional.of(middleName);
        return this;
    }

    ... getters go here ...

    @Override
    public int hashCode() {
        return HashCodeBuilder.reflectionHashCode(this);
    }

    @Override
    public boolean equals(Object that) {
        return EqualsBuilder.reflectionEquals(this, that);
    }
}
```

---
class: codeonly
```java
@Immutable
interface User {

  String firstName();
  String lastName();
  Optional<String> middleName();
  Collection<String> nicknames;

}
```

--

```java
User uncleBob = UmmutableUser
                  .builder()
                  .firstName("Robert")
                  .lastName("Martin")
                  .addNickname("Uncle Bob")
                  .build();
```

--

```java
User anotherUncleBob = UmmutableUser
                        .copyOf(uncleBob)
                        .withFirstName("R.");
```

---
background-image:url(immutables.png)
background-size: 100%

---
class: center, middle
## Booleans are not nouns!

---
class: codeonly
.crap[
```java
class Customer {
  @Confusing
  boolean satisfiedBy(Specification);
}
```
]

--

.nice[
```java
class Customer {
  @MuchBetter
  boolean isSatisfiedBy(Specification);
}
```
]

--

.crap[
```java
enum Severity {
  boolean major();
}
```
]

--

.nice[
```java
enum Severity {
  boolean isMajor();
}
```
]

--

.nice[
```java
class ProductCatalog {
  boolean contains(Product);
}
```
]

--

.crap[
```java
interface Input {

  @Bullshitake
  boolean validate();
}
```
]


--

.crap[
```java
interface Input {

  @MuchBetter
  boolean isValid();
}
```
]

---
class: center, middle
# Package naming

---

class: codeonly

### name of the company has nothing to do with code

.crap[
```java
package org.apache.spark;
```
]

--

.nice[
```java
package spark;
```
]


--

### plural or singular?


```java
package tomtom.navigation;
package tomtom.navigation.maps;
```

```java
package tomtom.navigation;
package tomtom.navigation.map;
```

--

### Use the plural for packages with homogeneous contents.
### Use the singular for packages with heterogeneous contents.

---
class: center, middle, example
# Tony Hoare's billion dollar mistake

---
class: center, middle
## In computing, a null pointer has a value reserved for indicating that the pointer does not refer to a valid object. **Never pass null**. **Never return null**.

---
class: codeonly
```groovy
compile group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
```

--

```java
@IsNotInheritedBySubpackages
@ParametersAreNonnullByDefault
package root;
```

--

```java
@ParametersAreNonnullByDefault
package root.subpackage;
```

--

class: img100
![](nevernull.png)


--

```java
@Override
public boolean equals(@Nullable Object obj) { ... }
```
???
- otherwise I will have to null-check all arguments, to be defensive.

---
class: img100, codeonly
![](brokennullity.png)

--

```java
@Nonnull
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface NullsForbidden {
}
```

--

```java
@NullsForbidden
package wombat;
```

---
class: img100, codeonly
![](nullsworkagain.png)

---
class: codeonly
.crap[
```java
@ReturnsNullIfNumberIsNotFound
interface PhoneBook {
  PhoneNumber phoneNumber(String regex);
}
```
]

--

.nice[
```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(String regex);
}
```
]

--

```java
void ifPresent() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(...);
  phoneNumber.ifPresent(paymentReminder::send);
}
```

--

```java
void orElse() {
  PhoneNumber phoneNumber = phoneBook.phoneNumber(...)
      .orElse(PhoneNumber.USA_PRESIDENT);
}
```

--

```java
void orElseThrow() {
  PhoneNumber phoneNumber = phoneBook.phoneNumber(...)
      .orElseThrow(() -> new PhoneNumberLookupFailed(regex)
}
```

---

class: codeonly
.crap[
```java
void lifeWithoutOptionals() {
  PhoneNumber phoneNumber = phoneBook.phoneNumber(...);
  if (phoneNumber != null) {
    FacebookProfile facebookProfile = facebook.profile(phoneNumber);
    if (facebookProfile != null) {
      Picture picture = facebookProfile.picture();
      if (picture != null) {
        picture.download();
      }
    }
  }
}
```
]

--

.nice[
```java
void optionalIsAMonad() {
  phoneBook.phoneNumber(...)
      .flatMap(this::facebookProfile)
      .flatMap(FacebookProfile::picture)
      .ifPresent(ProfilePicture::download);
}

private FacebookProfile facebookProfile(PhoneNumber) {
  ...  
}

```
]

---
class: codeonly
```java
@RegexIsOptional
interface PhoneBook {
  Collection<PhoneNumber> phoneNumbers(String regex);
}
```

--

```java
interface Mask {

  Mask ANY = phoneNumber -> true;

  boolean matches(PhoneNumber phoneNumber);
}
```

--

```java
class Regex implements Mask {

  private final Pattern regex;

  @Override
  public boolean matches(PhoneNumber phoneNumber) {
    return regex.asPredicate().test(phoneNumber.toString());
  }
}
```

--

```java
interface PhoneBook {
  Collection<PhoneNumber> phoneNumbers(Mask mask);
}```

--

```java
phoneBook.phoneNumbers(Mask.ANY);

phoneBook.phoneNumbers(new Regex(...));

```

---
class: codeonly

.crap[
```java
class Entrepreneur {
  private String fullName;
  private Optional<Money> money;

  Entrepreneur(String fullName, Optional<Money> money) {
      this.fullName = fullName;
      this.money = money;
  }
}
```
]

--

.nice[
```java
class Entrepreneur {
  private String fullName;
  private Optional<Money> money = Optional.empty();

  Entrepreneur(String fullName) {
      this.fullName = fullName;
  }

  void earn(Money money)
    this.money = Optional.of(money);
  }
}
```
]

---
class: center, middle
# Code must be kept at the same level of abstraction (**SLAP**)
### (abstraction - trimming info on a subject to the absolute context relevant minimum)

---
class: codeonly

.crap[
```java
if (productsOwnedByPo.get(po.id()).containsKey(product.id())) {
  ...
}
```
]

--

.nice[
```java
if (productOwner.owns(product)) {
  ...
}
```
]

--

.crap[
```java



Collection<Boolean> checkboxes = new ArrayList<>();
```
]

--

.nice[
```java
Collection<Checkbox> checkboxes = ...
```
]

--

.crap[
```java



interface EShop {
    Map<String, String> resolveAffiliates(EShopSession session);
}
```
]

--

.crap[
```java
interface EShop {
    Affiliates affiliates(EShopSession session);
}
```
]

--

.crap[
```java
@TryToRemoveIntermediaries
interface EShopSession {
    Affiliates affiliates();
}
```
]

---
class: codeonly
.crap[
```java
MultivaluedMap<String, String> formParams = new Form();
for (String key : params.keySet()) {
    formParams.add(key, params.get(key));
}
```
]

--

.crap[
```java
Form form = new Form();
for (String key : params.keySet()) {
    form.add(key, params.get(key));
}
```
]

--

.nice[
```java
Form form = new Form(new Parameters(params));
```
]

--

.nice[
```java
Form form = new Form();
form.parameterize(new Parameters(params));
```
]

--

.nice[
```java
Form form = new Form();
form.parameterize(Parameters.from(httpRequest));
```
]

---
class: codeonly
.crap[
```java
class ValidationFacade {
    public boolean validateAnswers(Map<String, String> questionToAnswerMap) {
      // we always get 4 answers
      return MapUtils.isNotEmpty(questionToAnswerMap) && questionToAnswerMap.size() == 4;
    }
}
```
]

--

.nice[
```java
class Answer {
    String questionId;
    String answerId;
}
```
]

--

.crap[
```java
class ValidationFacade {
    public boolean validateAnswers(Collection<Answer> answers) {
      // we always get 4 answers
      return answers.size() == 4;
    }
}
```
]

--

.crap[
```java
class ValidationFacade {
    private static final int MANDATORY_NUMBER_OF_ANSWERS = 4;

    public boolean validate(Collection<Answer> answers) {
      return answers.size() == MANDATORY_NUMBER_OF_ANSWERS;
    }
}
```
]

---
class: codeonly
.nice[
```java
class UnvalidatedAnswers {

    private static final int MANDATORY_NUMBER_OF_ANSWERS = 4;
    private final Collection<Answer> answers;

    boolean areValid() {
        return answers.size() == MANDATORY_NUMBER_OF_ANSWERS;
    }
}
```
]

--

.crap[
```java
class ValidationFacade {
    public boolean validate(UnvalidatedAnswers answers) {
      return answers.areValid();
    }
}
```
]

--

.nice[
```java
@FacadeBecameObsolete
UnvalidatedAnswers answers = new UnvalidatedAnswers(...);
if (answers.areValid()) {
    ....
}
```
]

---
class: center, middle
# Reification - a process of making something concrete (implicit -> explicit).
???
- with lambdas, you can write short expressions easily. Often, you must reify them.


---
class: center, middle
# Let's come back to keeping code at the same level of abstraction...

---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = this.applicationCheckFactory.make(when, application, this.countryCode);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
  return checkResult;
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
* def check = makeCheck(application, when);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
  return checkResult;
}
```

---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
  return checkResult;
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
* log(check); // logIfNeeded if conditional needs to be communicated
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```
---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persistResults(checkResult);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persist(checkResult);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* if (shouldRunScorecard(application)) {
    runScorecard(application);
  }
}
```

---
class: codeonly
.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return runScorecard && LoanAgreementType.MAIN.equals(application.agreementType());
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && LoanAgreementType.MAIN.equals(application.agreementType());
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && application.agreementType().equals(MAIN);
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && application.isAgreementOfTypeMain()); // WTF is Type?
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && application.isAgreementOfType(MAIN)); // WTF is Type?
}
```
]

--

.nice[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
   return scoringEnabled && agreement.isMain();
}
```
]

--

.nice[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
   boolean agreementIsApplicableForScoring = agreement.isMain();
   return scoringEnabled && agreementIsApplicableForScoring;
}
```
]

---
class: codeonly
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
  if (shouldRunScorecard(application)) {
      runScorecard(application);
  }
}
```

--

```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
}
```

--

```groovy
public def scoreApplicationIfNecessary(LoanApplication application) {
  if (shouldRunScorecard(application)) {
      runScorecard(application);
  }
}
```


---
class: center, middle
## The code should read like a top-down narrative. Start with high-level, abstract paragraphs. Then dive into details.
### — The Stepdown Rule


---
class: center, middle
# Is Guava still a thing?

---
class: codeonly
```java
Range.closed(1, 3).contains(2);

Range.lessThan(5).contains(5);
```

--

```java
Multimap<String, String> gadgets = HashMutimap.create();

gadgets.put("iPhone", "5S");
gadgets.put("iPhone", "6S");
gadgets.put("LG", "Nexus");
```

--

```java
List<Iphone> iphones() {
  return ImmutableList.copyOf(iphones);
}
```

--

```java
Ordering<Money> ordering = Ordering
  .natural()
  .nullsFirst()
  .onResultOf(Money::amount);

Collection<Money> lotsOfMoney = ...

ordering.isOrdered(lotsOfMoney)

Money million = new Money(1000000);
List<Money> leastOfAMillion = ordering.leastOf(lotsOfMoney, million);

ordering.reverse();
```

---
class: codeonly
```java
public int compareTo(Foo that) {
  return ComparisonChain.start()
    .compare(this.a, that.a)
    .compare(this.b, that.b)
    .compare(this.c, that.c, Ordering.natural())
    .result();
```


--

```java
CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, "CONSTANT_NAME"));
```

--

```java
new EqualsTester()
    .addEqualityGroup("hello", "h" + "ello")
    .addEqualityGroup("world", "wor" + "ld")
    .addEqualityGroup(2, 1 + 1)
    .testEquals();
```

--

```java
int maxNumberOfInsertions = 10000;
int falsePositiveProbability = 3;

BloomFilter<String> ipAddresses = BloomFilter.create(stringFunnel(Charsets.UTF_8),
                                                     maxNumberOfInsertions,
                                                     falsePositiveProbability);

boolean mightContain = ipAddresses.mightContain("121.21.13.111");
boolean neverContain = !mightContain;
```
???
Briefly, Bloom filters are a probabilistic DS, definitely NOT containing, but if yes - MAYBE


---
class: middle, center, example
# Fighting feature bloat
### ... because we want to keep object's behaviour next to the state

---
class: middle, center
# Single Responsibility Principle
### doesn't help much

---
# How small the class should be?
???

--


### Comprehensible or **mind-sized** — *me*

--

### Small enough to lower **coupling** — *Marco Ceconni*
???
Marco Cecconi - Dev at StackOverflow

--

### Large enough to maximize **cohesion** — *Marco Ceconni*

--

### Small enough to be easy to **test**  — *me*


---
class: codeonly

```java
@GenericNamingLeadsToObesity
@HardToArgueThatTradeIsDoingMoreThanOneThing
class Trade {
  void process() {
    // 1000 LOC
  }
}
```

--

```java
class *Helper
```

--

```java
class *Utils
```

--

```java
class *Manager
```

--

```java
class *Service
```

--

```java
class *Controller
```


---
class: codeonly
.crap[
```java
@TwoInterwovenConceptsAreHidingInside
@FileSuffixAndDirIndicateMissingObject
class FtpUtils {

  void transferFile(File file, File newLocation)

  boolean fileExists(String filename);

  void makeDir(String parentDir, String dir);

  boolean folderExists(String folder);

}
```
]

--

class: codeonly
.crap[
```java
@StilProcedural
class FtpClient {

  void transferFile(File file, File newLocation)

  boolean fileExists(String filename);

  void makeDir(String parentDir, String dir);

  boolean folderExists(String folder);

}
```
]

---
class: codeonly

.nice[
```java
class FtpFolder {

  void createIn(FtpFolder parent);

  boolean exists();

}
```
]

--

.nice[
```java
class FtpFile {

  void transferTo(FtpFolder destination)

  boolean exists();

}
```
]

---
class: codeonly
```java
public class Tweet {

    private LocalDateTime time = LocalDateTime.now();

    private Collection<Like> likes = new LinkedList<>();

    public LocalDateTime time() {
        return time;
    }

*   public Collection<Like> likes() {
*       return ImmutableList.copyOf(likes);
*   }
*
*   public void like(Like like) {
*     likes.add(like);
*   }
*
*   public long totalLikes() {
*     return likes.size();
*   }
*
*   public long totalLikesBy(LikerId likerId) {
*     return likes.stream().filter(like -> like.isBy(likerId)).count();
*   }
```

---
class: codeonly
```java
public class Tweet {

    private LocalDateTime time = LocalDateTime.now();

    private Collection<Like> likes = new LinkedList<>();

    public LocalDateTime time() {
        return time;
    }

    public Likes likes() {
        return new Likes();
    }

    class Likes {

        public void put(Like like) {
            likes.add(like);
        }

        public long total() {
            return likes.size();
        }

        public long totalBy(LikerId likerId) {
            return likes.stream().filter(like -> like.isBy(likerId)).count();
        }

        public Collection<Like> all() {
            return ImmutableList.copyOf(likes);
        }
    }
}
```

---
class: codeonly
```java
public class Tweet {

    private LocalDateTime time = LocalDateTime.now();

    private Collection<Like> likes = new LinkedList<>();

    public LocalDateTime time() {
        return time;
    }

    public Likes likes() {
        return new Likes();
    }

    class Likes extends ForwardingList<Like> {

        public long totalBy(LikerId likerId) {
            return likes.stream().filter(like -> like.isBy(likerId)).count();
        }

        @Override
        protected List<Like> delegate() {
            return likes;
        }
    }
}
```

---
class: center, middle
## Total likes during Black Friday?

---
class: codeonly
```java
class BlackFriday {
```

--

```java
    public boolean fallsOn(LocalDate date) {
        return blackFriday().isEqual(date);
    }
```

--

```java
    private LocalDate blackFriday() {
        return thanksGivingDay().plusDays(1);
    }
```

--

```java
    private LocalDate thanksGivingDay() {
        return Year.now()
                .atMonth(Month.NOVEMBER)
                .with(TemporalAdjusters.lastInMonth(DayOfWeek.THURSDAY));
    }
}
```

--

.crap[
```java
class Likes {
    ...
    public long totalDuring(BlackFriday blackFriday) {
        return likes
            .stream()
            .filter(like -> blackFriday.fallsOn(like.time().toLocalDate()))
            .count();
    }
    ...
}
```
]

---
class: codeonly
```java
class BlackFriday implements SpecialDay {
```

```java
    public boolean fallsOn(LocalDate date) {
        return blackFriday().isEqual(date);
    }
```

```java
    private LocalDate blackFriday() {
        return thanksGivingDay().plusDays(1);
    }
```

```java
    private LocalDate thanksGivingDay() {
        return Year.now()
                .atMonth(Month.NOVEMBER)
                .with(TemporalAdjusters.lastInMonth(DayOfWeek.THURSDAY));
    }
}
```

.crap[
```java
class Likes {
    ...
    public long totalDuring(SpecialDay specialDay) {
        return likes
            .stream()
            .filter(like -> specialDay.fallsOn(like.time().toLocalDate()))
            .count();
    }
    ...
}
```
]

---
class: center, middle
## But different clients has different query requirements for Likes...

---
class: codeonly
```java
public interface Entity<T> {
    default <R> R projection(Function<T, R> fn) {
        return fn.apply((T) this);
    }
}
```

--

```java
class Likes implements Entity<Likes> {
  ...
}
```

--

```java
class TotalDuringBlackFriday implements Function<Tweet.Likes, Long> {

    private final BlackFriday blackFriday = new BlackFriday();

    @Override
    public Long apply(Tweet.Likes likes) {
        return
          likes
            .stream()
            .filter(like -> blackFriday.fallsOn(like.time().toLocalDate()))
            .count();
    }
}
```

--

```java
Tweet tweet = ...
Tweet.Likes likes = tweet.likes();
long total = likes.projection(new TotalDuringBlackFriday());
```
???
- must side effect free!
- btw, can be written inline, as lambdas


---
class: codeonly
```java
public interface Entity<T> {
    default <R> R projection(Function<T, R> fn) {
        return fn.apply((T) this);
    }
    default boolean satisfies(Predicate<T> predicate) {
        return predicate.test((T) this);
    }
}
```

--

```java
class GotMillionLikesOnAPostingDay implements Predicate<Tweet> {

        @Override
        public boolean test(Tweet tweet) {
            long likesOnAPostingDay = tweet
                    .likes()
                    .stream()
                    .filter(like -> like.madeOn(tweet.time().toLocalDate())))
                    .count();
            return likesOnAPostingDay >= 1000000;
        }
    }
```

--
```java
Tweet tweet = ...
boolean milionLikesInADay = tweet.satisfies(new GotMillionLikesOnAPostingDay());
```

---
class: center, middle
# In order to improve searchability, consider creating custom @FunctionalInterfaces – Projection and Specification.



    </textarea>
    <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        slideNumberFormat: function (current, total) { return "" }
      });
      slideshow.on('afterShowSlide', function (slide) {

        var axs =  {
                  title: 'thoughput / responsiveness over time.',
                  xaxis: {
                    title: 'time (months)'
                  },
                  yaxis: {
                    title: 'throughput / responsiveness (RTF / sprint)'
                  }
                }

        var thr = [
                {
                  x: [2, 10, 14, 24, 40],
                  y: [30, 29, 28, 23, 10],
                  name: 'continuous degradation',
                  mode: 'lines',
                  line: {
                      color: 'rgb(219, 64, 82)',
                      width: 3
                    }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30, 30, 30, 30],
                  name: 'sustainable pace',
                  mode: 'lines',
                  line: {
                      color: 'rgb(169, 169, 169)'
                  }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30.5, 31, 31.5, 32],
                  name: 'continuous improvement',
                  mode: 'lines'
                },
          ];

          var dbt = thr.concat({
                  x: [28, 28],
                  y: [30, 20],
                  name: 'technical debt',
                  mode: 'lines',
                  line: {
                    dash: 'dot'
                  }
                } );

        if (slide.properties.name == "throughput") {
          Plotly.newPlot('throughput', thr, axs);
        }
        if (slide.properties.name == "debt") {
          Plotly.newPlot('debt', dbt, axs);
        }
      });

    var ktx = document.getElementsByClassName("ktx");
    for(var i = 0; i < ktx.length; i++) {
       katex.render(ktx.item(i).getAttribute('expr'), ktx.item(i));
      }
    </script>

  </body>
</html>
