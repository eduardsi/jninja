<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="ocean.css" />
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .large code { font-size: 1.5em }
      .large .hljs-comment { color: white !important}
      .squeez h3 { margin: 0.5em }
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }
      /* new */
      .example { background-color: #007ebc}
      .example h2 { color: #00394f; font-weight: bold; line-height: 0;}
      .example h1 { color: #fff; font-weight: bold; background-color: #00394f; padding: 10px }

      .codeonly { padding: 1em; background-color: #2b303b }
      .codeonly pre { margin: 0 }

      .remark-code-line-highlighted { background-color: #2d9967; color: white}
      .remark-code-line-highlighted * { color: white !important; }

      .remark-slide-scaler { -webkit-box-shadow: 0 !important; box-shadow: none !important; }
      .remark-slide-container {background-color: #2b303b}
      /* new end */
      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
      .img100 img { width: 100%}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle, example
# Effective Coding Principles and Patterns in Java 8
???
- Introduce myself and let others introduce themselves.
- Setting expectations
- Not Java 8 course

---
class: squeez
# Part I

--

## - java 8 in 4 slides

--

## - software design economics

--

## - naming

--

## - solid

--

## - modularity

---
# Part II

--

## - application layer

--

## - tx

--

## - validation

--

## - peristence

--

## ...

---
# Part III

--

## - Lean Coffee

--

## - more Lean Coffee

---

# Part IV

--

## - Homework

--

## - Homework review

---
class: center, middle
# Part I

---
class: center, middle, example
# Java 8 additions
## (in 4 slides)
---
###**java.time** (Clock, Instant, LocalDate, TemporalAdjuster)
???
No Joda anymore.
--

###**streams** (collections, arrays, chars, files etc.)

--

###**lambdas**

--

###**@FunctionalInterface** (Function, Predicate, Consumer, Supplier)

--

###**method references** (Class::new, instance::method)

--

###**default methods**

--

###**java.lang.reflect.Parameter** (--parameters compiler argument)

--

### **PermGen** replaced with out-of-heap **Metaspace**

---
### **implicit conversion**

--

```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
--
```java
Converter<String, Integer> converter = Integer::valueOf;
```
--
```java
class Person {

    private final String firstName, lastName;

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```
--
```java
interface PersonFactory {
    Person create(String firstName, String lastName);
}
```
--
```java
PersonFactory personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");
```

---
### **checked exception in lambdas**
.crap[
```java
Arrays.stream(dir.listFiles())
        .map(file -> {
            try {
                return file.getCanonicalPath();
            } catch (IOException e) {
                throw new RuntimeException(e);

            }
        })
        .forEach(System.out::println);
```
]
---

.nice[
```java
Arrays.stream(dir.listFiles())
        .map(Unchecked.function(File::getCanonicalPath))
        .forEach(System.out::println);
```
]

--

.nice[
```java
class Unchecked {
  public static <T, R> Function<T, R> function(CheckedFunction<T, R> function) {
    return t -> {
        try {
            return function.apply(t);
        }
        catch (Throwable e) {
          if (e instanceof Error) {
              throw (Error) e;
          }
          if (e instanceof RuntimeException) {
              throw (RuntimeException) e;
          }
          throw new RuntimeException(e);
        }
    };
  }

}
```
]

--

.nice[
```java
@FunctionalInterface
public interface CheckedFunction<T, R> {
    R apply(T t) throws Throwable;
}
```
]

---
class: center, middle, example
# The economics of software design 101
???
Before HOW -> WHY

---
class: center, middle
# There is a strong correlation between quality of the codebase and developer productivity or **throughput**.
## (c) me
???
- The higher is quality, the higher is productivity. And vice versa.
- Everyone agrees?!
- Productivity - TIME we spend per CHANGE.

---
class: middle
# <span class="ktx" expr="Throughput = \dfrac{RTF}{TIME}"></span>
#### *RTF - Released Tested Features (c) [The Economics of Software Design](https://www.youtube.com/watch?v=7HecgbghFTk), J.B. Rainsberger *
???

---
class: center, middle
# Higher throughput = lower **cost per change**.
#### <span class="ktx" expr="cost\,per\,change = time\,spent\,on\,change\,\times salary"></span>

---
class: center, middle
# Why do these guys move so slow?!
???
Low throughput

---
class: center, middle
# Why are these guys so expensive?!
???
High CPC (low throghput; too low for given salary!!!)


---
class: center, middle
# By writing clean code, you enable **stable throughput / responsiveness over time**.
### (the time that is usually longer than your employment)
???
- The goal of design is to be able to ship as fast as we can now not only in the next 3 months, but in years etc.
- Unfortunately, we do not usually know see long-term consequences of our work, but we should.
- For example, my best friend is now maintaining a software that I wrote 6 years ago :-)


---
name: throughput
<div id="throughput" style="width: 100%; height: 100%;"></div>
???
- team is slow and becomes a bottleneck to make world a better place :-) New teams, rewrites etc.
- a nice thing about sustainable pace that I can estimate.
- Do you know the rule that makes throughput gradually grow? BS rule. That's how we escale from SHIT.
- Can someone explain why throughput drops that fast?

---
#  Reinforcing loops:

--

### low throughput -> pressure -> more corners cut -> lower throghput

--
### low throughput -> unmet deadlines -> more people to work on features -> lower throughput (Brook's Law)

--

### low quality tolerated -> lower quality (Broken window theory)

--

### low quality tolerated -> lower quality -> tolerated -> even bigger decline in quality -> ... (Drift to Low Performace)

--

### Graham's Law
???
- BWT - if there is mess, or rush, you don't be the first to make a mess.
- Graham's law - Shitty component remain a part of the system over time precisely because it's hard to take out. Conversely, a component that is easy to replace is one that we may replace.

---
![](donella.png)

---
class: center, middle
# Technical debt


---
class: center, middle
##  Technical debt is a metaphor to express cumulative **future** consequences of corners being cut.
---
name: debt
<div id="debt" style="width: 100%; height: 100%;"></div>
???
- TD - cumulative future consequences of corners being cut.
- In this example, we pay TD in terms of throughput.
- TD is about future. And we want future US to thank us in future.

---
class: center, middle
# ?
???
- raise your hand who thinks technical debt is a bad thing?
- who thinks it's a good thing?
- is taking a loan a bad thing?
- is taking and loan and not returning it back for a long time - a bad thing?

---
class: center, middle
# Technical debt is a **tool** for gaining a **short-term** gain. **Causes addiction** and needs to be **managed**.
???
- Spike and Throwaway! (Dan North). E.g. TDDing at this level is kinda waste.
- Meeting deadline (critical problem, black swan events -> unexpected prospect)

---
class: conversation
### **Manager**: When will the new permission be done?

--

### **Dev**: Mmmm, I hope tomorrow, in the end of the day.

--

### **Manager**: We need it today. Can’t you find a “creative” way to do it?

--

### **Dev**: Let me think…

--

### **Manager**: We have 5 clients that really need this today. Else they will probably not sign the contract.

--

### **Dev**: But the…

--

### **Manager**: Look, it’s important that you understand the business value of it. Isn’t it just a new condition in the code? Just put it there, and we’ll “fix it” later.

--

### **Dev**: Ok.

--

### **Manager**: So we’ll be able to deploy today?

--

### **Dev**: Aham.

#### *— [Technical Debt 101](https://medium.com/@joaomilho/festina-lente-e29070811b84#.7d8asvofr)*

---
class: bottom, right
background-image:url(techDebtQuadrant.png)
#### *Technical debt quadrant: http://martinfowler.com/bliki/TechnicalDebtQuadrant.html*
???
- reckless - we focus on completing tasks fast instead of building HQ system. Boil like frogs.
- It's often the case that it can take a year of programming on a project before you understand what the best design approach should have be.

---
class: center, middle, bad
# The only way to go fast is to go well.
### (c) Uncle Bob
???
really?

---
class: center, middle, oki
# The only way to go fast [in a long run] is to go well.
### (c) Uncle Bob (edited)

---
class: center, middle
# Does writing clean code take more time than writing crap?
???
- takes time -> lower throghput -> higher cost per change. -> quality is expensive

---
class: center, middle
# Reading vs. writing ratio is 10:1.
???
we want reading to be easy if it makes writing harder. Making code easy to read, makes it easier to write.

---
class: center, middle
# There are people who write clean code blazingly fast.
???
I saw master at work. You can be that master. Skill acquisition graph (performance over time)

---
class: center, middle
# If something is not worth our time, consider not doing it.
![](stepsofmastery.png)
???
- Avoiding it - nice! less INHERENT COMPLEXITY. less code to maintain.
- Agile Manifesto principle. Simplicity — the art of maximizing the amount of work not done.
- First law of software quality: e = mc^2 ; errors = (more code)^2

---
class: center, middle
# Consider your reputation.
???


---
class: center, middle
## If you think someone is an asshole, most people who are silently observing the situation think so, too.
#### *— Guy’s Theory of Perfect Knowledge of Assholes*

---
background-image:url(SonarQube-02.png)
background-size: 100%
???
- not used
- running on every push
- before every push (https://hub.docker.com/_/sonarqube)
- running on every code change

---
class: lint
background-image:url(sonarlint.png)
background-size: 100%

---
class: center, middle, example
# Naming

---
class: codeonly
.crap[
```java
@AstonishingTwilioApi
class Example {

  public static final String ACCOUNT_SID = "{{ account_sid }}";
  public static final String AUTH_TOKEN = "{{ auth_token }}";

  public static void main(String[] args) throws TwilioRestException {
    TwilioRestClient client = new TwilioRestClient(ACCOUNT_SID, AUTH_TOKEN);

    List<NameValuePair> params = new ArrayList<NameValuePair>();
    params.add(new BasicNameValuePair("Body", "Hello from Java"));
    params.add(new BasicNameValuePair("To", "+12345678901"));
    params.add(new BasicNameValuePair("From", "+12345678901"));

    MessageFactory messageFactory = client.getAccount().getMessageFactory();
    Message message = messageFactory.create(params);
  }
}
```
]
???
- Stroup effect
- Naming issues has cumulative effect
- The code is not HONEST.

---
class: codeonly
```java
@WhatDoYouExpectToHappen
void code() {
  Entity entity ...
  dao.update(entity);
}
```

--

.crap[
```java
void update(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
}
```
]

--

.nice[
```java
void update(Entity entity) {
  checkArgument(entity.isIdAssigned(), "Cannot update entity. Id is missing");
  ...
}
```
]

--

```java
void updateIfIdAssigned(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
  ...
}
```

---
class: codeonly
.crap[
```java
interface Employee {
  String employeeAddress();
}
```
]

--

.nice[
```java
interface Employee {
  String address();
}
```
]

--

.crap[
```java
class Transaction {
  enum TransactionScope { }
}
```
]

--

.nice[
```java
class Transaction {
  enum Scope { }
}
```
]

--

.crap[
```java
@PackagesAreExceptionToTheRule
package org.framework.batch
interface Reader { }
interface Operation { }
```
]

--

.nice[
```java
interface BatchReader { }
interface BatchOperation { }
```
]

--

.nice[
```java
interface Batch {
  interface Reader { }
  interface Operation { }
}
```
]

--

.crap[
```java
void increment(long incBy) {}
```
]

--

.nice[
```java
void increment(long by) {}
```
]

--

.nice[
```java
void increment(long diff) {}
```
]

---
class: codeonly
.crap[
```java
  class Ticket {
      private LocalDate refundedDate;
      private LocalDate refundedUntilDate;
```
]

--

.nice[
```java
  class Ticket {
      private LocalDate refundedOn;
      private LocalDate refundableTill;
```
]

--

.crap[
```java
  class Ticket {
      private LocalTime bookingTime;
```
]

--

.nice[
```java
  class Ticket {
      private LocalTime bookedAt;
```
]

--

.crap[
```java
  class BorrowedAndroidDevice {
      private LocalDate promisedBackDate;
```
]

--

.nice[
```java
  class BorrowedAndroidDevice {
      private LocalDate promisedBackBy;
```
]

--

.nice[
```java
  class BorrowedAndroidDevice {
      private LocalDate returnBy;
```
]

--

.crap[
```java
  class Widget {
      private long lengthInPixels;
```
]

--

.nice[
```java
  class Widget {
      private Pixels length;
```
]

--

.crap[
```java
  interface Movie {
      void stream(OutputStream outputStream);
```
]

--

.nice[
```java
  interface Movie {
      void stream(OutputStream into);
```
]

---
class: center, middle
## Composite names usually indicate a missing root object

---
class: codeonly
```java
class AwsS3Bucket {

  private final String awsPassword;
  private final String awsLogin;
  private final String bucketName;

  public AwsS3Bucket(String awsLogin, String awsPassword, String bucketName) {
    this.awsLogin = awsLogin;
    this.awsPassword = awsPassword;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

--

```java
class AwsCredentials {

  public final String login;
  public final String password;

  public AwsCredentials(String login, String password) {
    this.login = login;
    this.password = password;
  }
}
```

---
class: codeonly
```java
class AwsS3Bucket {

  private final AWSCredentials awsCredentials;
  private final String bucketName;

  public AwsS3Bucket(AwsCredentials awsCredentials, String bucketName) {
    this.awsCredentials = awsCredentials;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

--

```java
class AwsAccount {

  private final AwsCredentials credentials;

  public AwsAccount(AwsCredentials credentials) {
    this.credentials = credentials;
  }

}
```

---
class: codeonly
```java
class AwsS3Bucket {

  private final AwsAccount account;
  private final String bucketName;

  public AwsS3Bucket(AwsAccount account, String bucketName) {
    this.account = account;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

---
class: codeonly
.crap[
```java
interface SpotifyApp  {
    void playMusic();
    void stopMusic();
}
```
]

--

.nice[
```java
interface Music  {
    void stop();
    void play();
}
```
]

--

.nice[
```java
interface SpotifyApp  {
    Music music();
}
```
]

--

class: codeonly
.crap[
```java
interface HipChat  {
    void sendMessage(String channel, String mesage);
}
```
]

--

class: codeonly
.nice[
```java
interface Channel  {
    void send(String message);
}
```
]

--

.nice[
```java
interface HipChat  {
    Channel channel(String name);
}
```
]

---
class: center, middle
## Avoid dumb suffixes when possible
### (but always stay consistent)

---
class: codeonly
.crap[
```java
class CancelTransactionCommand { }
class ApplyForLoanCommand { }
class AskQuestionCommand { }
class ReportSpammerCommand { }
```
]

--

.nice[
```java
class CancelTransaction { }
class ApplyForLoan { }
class AskQuestion { }
class ReportSpammer { }
```
]

--

.crap[
```java
class RegistrationFailureException extends BusinessException { }
```
]

--

.nice[
```java
class RegistrationFailure extends BusinessException { }
```
]

--

.crap[
```java
class ExecutionTimeoutException extends IllegalStateException { }
```
]

--

.nice[
```java
class ExecutionTimeout extends IllegalStateException { }
```
]

--

.nice[
```java
class ExecutionTookTooLong extends IllegalStateException { }
```
]

--

.crap[
```java
class OverlappingFileLockException extends IllegalStateException { }
```
]

--

.nice[
```java
class FileLockAlreadyTaken extends IllegalStateException { }
```
]

--

.crap[
```java
class IsNewCustomerSpecification implements Specification { }
```
]

--

.nice[
```java
class IsNewCustomer implements Specification { }
```
]

---
class: codeonly
.crap[
```java
//
// A BeanFactoryPostProcessor used to register and inject
// @MockBeans with the ApplicationContext...
// ...
// @author Phillip Webb
// @since 1.4.0
//
public class MockitoPostProcessor extends ... implements ..., BeanFactoryPostProcessor {}
```
]

--

.nice[
```java
public class MockBeanInjector extends ... implements ..., BeanFactoryPostProcessor {}
```
]

--

```java



interface PaymentExporter {
	void export(Output into);
}
```

--

.crap[
```java
@NotThatEasy
class Swedbank implements PaymentExporter {
	public void export(Output into) {}
}
```
]

--

.nice[
```java
interface PaymentsForExport {
	void export(Output into);
}
```
]

--

.nice[
```java
class SwedbankPayments implements PaymentsForExport {
	public void export(Output into) {}
}
```
]

---
class: center, middle
# Prefer creating objects that represent **what they are**, rather than what they do

---
class: codeonly
.crap[
```java
class File { }

interface FileReader {
   Data read(File file) { }
}
```
]

--

.nice[
```java
interface DataFile {
   Data data();
}
```
]

--

.crap[
```java
interface EmailSender {
  void send(Email email);
}
```
]

--

.nice[
```java
interface EmailProvider {
  void send(Email email);
}
```]

--

.crap[
```java
interface ConditionChecker {
  boolean checkCondition()
}
```
]

--

.nice[```java
interface Condition {
  boolean isTrue();
}
```
]

--

.crap[
```java
interface PaymentExporter {
    void export(Output into);
}
```
]

--

.crap[
```java
interface PaymentsForExport {
    void export(Output into);
}
```
]


---
class: codeonly
.crap[
```java
interface MoneyFormatter {
  String format(Money money);
}
```]

--

.nice[
```java
interface PrettyMoney {

  String asText();
```
]

--

.nice[
```java
  class Humane implements PrettyMoney {
    @Override
    public String asText() { ... }
  }
```
]
--

.nice[
```java
  class ISO_1234 implements PrettyMoney {
    @Override
    public String asText() { ... }
  }

}
```
]

--

```java
public static void main(String[] args) {
    Money money = new Money(99.00);
    PrettyMoney prettyMoney = new PrettyMoney.Humane(money);
    println(prettyMoney.asText());
}
```
???
- makes our software more OO, composable from classes, not methods
- why not MoneyFormat?
- why not toString()

---
class: codeonly
.crap[
```java
class FuckupProbabilityCalculator {
    BigDecimal calculate() { ... }
}
```]

--

![](fuckupdecimal.png)

---
class: codeonly

.nice[
```java
interface DecimalNumber {

    BigDecimal decimal();
```
]

--

.nice[
```java
    default DecimalNumber dividedBy(DecimalNumber divisor) {
        BigDecimal roundedDivision = decimal().divide(
            divisor.decimal(), RoundingMode.ROUND_UNNECESSARY);
        return new Const(roundedDivision);
    }

    ...

}```
]

--

.nice[
```java
class Const implements DecimalNumber {

    private final BigDecimal origin;
```
]

--

.nice[
```java
    public Const(int origin) {
      this(new BigDecimal(origin));
    }
```
]

--

.nice[
```java
    public Const(BigDecimal origin) {
      this.origin = origin.setScale(2, BigDecimal.ROUND_UNNECESSARY);
    }
```
]

--

.nice[
```java
    @Override
    public BigDecimal decimal() {
      return origin;
    }
}
```
]

---
class: codeonly

.nice[
```java
class FuckupProbability implements DecimalNumber {

    private final SecureRandom random = new SecureRandom();

    @Override
    public BigDecimal decimal() {
      return new Const(random.nextInt());
    }
}
```]

--

.nice[
```java
void wunderDemo() {
    DecimalNumber one = new FuckupProbability();
    DecimalNumber another = new FuckupProbability();
```
]

--

.nice[
```java
    DecimalNumber average = one.plus(another).dividedBy(new Const(2));
```
]

--

.nice[
```java
    DecimalNumber average = new Average(one, another);
}
```
]

--

.nice[
```java
class Average implements DecimalNumber {

    private final DecimalNumber[] numbers;

    public Average(DecimalNumber... numbers) {
        this.numbers = numbers;
    }

    @Override
    public BigDecimal decimal() {
        DecimalNumber total = new Const(numbers.length);
        DecimalNumber sum = new Sum(numbers);
        DecimalNumber average = sum.dividedBy(total);
        return average.decimal();
    }

}
```
]

---
class: codeonly
.crap[
```java
@Goodbye
public final class BigDecimalUtils {

    public static final int AMOUNT_SCALE = 2;

    private BigDecimalUtils() {
    }

    public static BigDecimal amount(int value) {
      return amount(new BigDecimal(value));
    }

    public static BigDecimal amount(BigDecimal amount) {
      return amount.setScale(AMOUNT_SCALE, BigDecimal.ROUND_HALF_UP);
    }

    public static boolean isEqual(BigDecimal value1, BigDecimal value2) {
      boolean isEqual = value1.compareTo(value2) == 0;
      return isEqual;
    }

    public static boolean isInRange(BigDecimal amount, BigDecimal amountFrom, BigDecimal amountTo) {
      return isGe(amount, amountFrom) && isLe(amount, amountTo);
    }

    public static boolean isZero(BigDecimal value) {
      return isEqual(BigDecimal.ZERO, value);
    }

  ...

}
```
]
---
class: center, middle
# Methods are either **commands** or **queries**.
### Use commands (verbs) to tell an object what to do.
### With queries (nouns) you ask object to give something.
— *[Command/Query Separation](http://martinfowler.com/bliki/CommandQuerySeparation.html)*

---
class: codeonly
.crap[
```java
interface Iterator<T> {

  @NounWithASideAffect
  @ViolatesCqs
  T next();
}
```
]

--

.nice[
```java
interface Iterator<T> {

  @VerbThatReturnsNothing
  void advance();

  @NounThatReturnsStuff
  T current();
}
```
]

--

.crap[
```java
@VerbThatReturnsStuff
InputStream load(URL url);
```
]

--

.nice[
```java
@NounThatReturnsStuff
InputStream stream(URL url);
```
]

--

.crap[
```java
@VerbThatReturnsStuff
String read(File file);
```
]

--

.nice[
```java
@NounThatReturnsStuff
String content(File file);
```
]

---
class: codeonly

.crap[
```java
interface Document {

  BytesWritten write(InputStream to);
}
```
]

--

.nice[
```java
interface Document {

   OutputPipe output();
}
```
]

--

```java
interface OutputPipe {}

     void write(InputStream to);

     BytesWritten written();

     Duration timeTaken();
}
```

---
class: center, middle
# Never use getters in your OO code.

---

## Getters are verbs

--

## Get **may** have a side effect

--

### - get married

--

### - get money from the ATM

--

### - get from A to B...

---
class: codeonly
```java
class Client {
  String fullName();
  String personalId();
}
```

--

```java
interface Iterator<T> {
  T current();
}
```

---
class: center, middle
## Blindly removing get\* prefix will remove noise, but won't make your code more object-oriented.
### **Tell, don't ask** as much as you can.


---
class: center, middle
# Never use setters in your OO code.

---
class: codeonly
.crap[
```java
Borrower borrower = new Borrower();
borrower.setFirstName(firstName);
borrower.setLastName(lastName);
```
]

--

.nice[
```java
borrower.giveName(String firstName, String lastName);
```
]
???
grant permissions vs. set permissions

--

.crap[
```java
borrower.setAcceptedAgreementType(AgreementType acceptedAgreementType);
```
]

--

.nice[
```java
borrower.accept(Agreement agreement);
```
]

--

.crap[
```java
agreement.setSigned(boolean agreementSigned);
```
]

--

.nice[
```java
agreement.sign();
```
]

--

.nice[
```java
agreement.unsign();
```
]

--

.crap[
```java
Bank bank = new Bank();
bank.setCode(...);
bank.setName(...);
bank.setBic(...);
```
]

--

.nice[
```java
@NewBankMustBeCreatedIfEitherCodeOrBicChanges
Bank bank = new Bank(code, name, bic);
bank.rename(...);
```
]

--

.nice[
```java
@IfYouReallyNeedToChangeBankIdentity
Bank bank = ...
Bank anotherBank = new Bank(code, name, bic);
bank.become(anotherBank);
```
]

---
# Data structures

--

## - DTOs, Java beans...

--

## - do not have behaviour

--

## - **can** have getters and setters (but should they?)

--

## - **must not** be confused with DDD value objects
???
- immutable
- can have some behaviour

---
class: codeonly
```java
@QuiteALotOfNoise
class UserRepresentation {

    private String firstName;
    private String lastName;
    private Optional<String> middleName = Optional.empty();

    public UserRepresentation(String firstName, String lastName) {
        ...
    }

    public UserRepresentation withMiddleName(String middleName) {
        this.middleName = Optional.of(middleName);
        return this;
    }

    ... getters go here ...

    @Override
    public int hashCode() {
        return HashCodeBuilder.reflectionHashCode(this);
    }

    @Override
    public boolean equals(Object that) {
        return EqualsBuilder.reflectionEquals(this, that);
    }
}
```

---
class: codeonly
```java
@Immutable
interface UserRepresentation {

  String firstName();
  String lastName();
  Optional<String> middleName();
  Collection<String> nicknames;

}
```

--

```java
UserRepresentation carlosNorris = ImmutableUserRepresentation
                                    .builder()
                                    .firstName("Carlos")
                                    .lastName("Norris")
                                    .addNickname("Chuck")
                                    .build();
}
```

--

```java
UserRepresentation rayNorris = ImmutableUserRepresentation
                                  .copyOf(chuck)
                                  .withFirstName("Ray");
}
```

---
background-image:url(immutables.png)
background-size: 100%

---
class: center, middle
## Be careful with booleans
### (boolean are not nouns)

---
class: codeonly
.crap[
```java
class Customer {
  @Confusing
  boolean satisfiedBy(Specification);
}
```
]

--

.nice[
```java
class Customer {
  @MuchBetter
  boolean isSatisfiedBy(Specification);
}
```
]

--

.crap[
```java
enum Severity {
  boolean major();
}
```
]

--

.nice[
```java
enum Severity {
  boolean isMajor();
}
```
]

--

.nice[
```java
class ProductCatalog {
  boolean contains(Product);
}
```
]

--

.crap[
```java
interface Input {

  @Bullshitake
  boolean validate();
}
```
]


--

.crap[
```java
interface Input {

  @MuchBetter
  boolean isValid();
}
```
]

---
class: center, middle
# Package naming

---
class: codeonly
.crap[
```java
@NameOfTheCompanyHasNothingToDoWithCode
package org.apache.spark;
```
]

--

.nice[
```java
package spark;
```
]

--

```java
@Plural
package tomtom.maps;

@Singular
package tomtom.map;
```

--

```java
package tomtom.navigation;
package tomtom.navigation.maps;
```

---
class: center, middle, example
# Tony Hoare's billion dollar mistake

---
class: center, middle
## In computing, a null pointer has a value reserved for indicating that the pointer does not refer to a valid object. **Never pass null**. **Never return null**.

---
class: codeonly
```groovy
compile group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
```

--

```java
@IsNotInheritedBySubpackages
@ParametersAreNonnullByDefault
package root;
```

--

```java
@ParametersAreNonnullByDefault
package root.subpackage;
```

--

class: img100
![](nevernull.png)


--

```java
@Override
public boolean equals(@Nullable Object obj) { ... }
```
???
- otherwise I will have to null-check all arguments, to be defensive.

---
class: img100, codeonly
![](brokennullity.png)

--

```java
@Nonnull
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface NullsForbidden {
}
```

--

```java
@NullsForbidden
package wombat;
```

---
class: img100, codeonly
![](nullsworkagain.png)

---
class: codeonly
.crap[
```java
@ReturnsNullIfNumberIsNotFound
interface PhoneBook {
  PhoneNumber phoneNumber(String regex);
}
```
]

--

.nice[
```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(String regex);
}
```
]

--

```java
void ifPresent() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(...);
  phoneNumber.ifPresent(paymentReminder::send);
}
```

--

```java
void orElse() {
  PhoneNumber phoneNumber = phoneBook.phoneNumber(...)
      .orElse(PhoneNumber.USA_PRESIDENT);
}
```

--

```java
void orElseThrow() {
  PhoneNumber phoneNumber = phoneBook.phoneNumber(...)
      .orElseThrow(() -> new NoPhoneNumberFound(regex)
}
```

--

```java
void optionalIsAMonad() {
  phoneBook.phoneNumber(...)
      .flatMap(no -> facebookProfile.byPhoneNumber(no))
      .flatMap(FacebookProfile::picture)
      .ifPresent(ProfilePicture::download);
}
```

---
class: codeonly
.crap[
```java
@RegexIsOptional
interface PhoneBook {
  Collection<PhoneNumber> phoneNumbers(String regex);
}
```
]

--

```java
interface Mask {

  Mask ANY = phoneNumber -> true;

  boolean matches(PhoneNumber phoneNumber);
}
```

--

```java
class Regex implements Mask {

  private final Pattern regex;

  @Override
  public boolean matches(PhoneNumber phoneNumber) {
    return phoneNumber.matches(regex);
  }
}
```

--

```java
class PhoneNumber {
    boolean matches() {
        return regex.asPredicate().test(text());
    }
}
```

--

```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(Mask mask);
}```

---
class: codeonly

.crap[
```java
class Entrepreneur {
  private String fullName;
  private Optional<Money> money;

  Entrepreneur(String fullName, Optional<Money> money) {
      this.fullName = fullName;
      this.money = money;
  }
}
```
]

--

.nice[
```java
class Entrepreneur {
  private String fullName;
  private Optional<Money> money = Optional.empty();

  Entrepreneur(String fullName) {
      this.fullName = fullName;
  }

  void earn(Money money)
    this.money = Optional.of(money);
  }
}
```
]

---
class: center, middle, example
# General design principles

---
class: center, middle
# Maximizing reuse complicates use.
#### *— Kirk Knoernschild, [Java Application Architecture](https://www.amazon.com/Java-Application-Architecture-Modularity-Patterns/dp/0321247132)*
???
- Use/Reuse paradox: what is easy to use is often hard to reuse
- The ability to compose systems from reusable elements complicates the system.

---
class: center, middle
# Flexibility breeds complexity.
#### *— Kirk Knoernschild, [Java Application Architecture](https://www.amazon.com/Java-Application-Architecture-Modularity-Patterns/dp/0321247132)*
???
- implementation side of things

---
class: center, middle
# Fight temptation to write re-usable and flexible code upfront. Start with specific and direct code, and let reuse / flexibility points emerge from usage scenarios.
???
- Lean #4 principle (decide as late a possible - knowledge/time plot).
- YAGNIy (XP principle) [yet joke]
- KISS (keep it simple and straightforward)

---
class: center, middle
## It is a capital mistake to theorize before one has data. Insensibly one begins to twist facts to suit theories, instead of theories to suit facts.
— *Sherlock Holmes*

---
class: center, middle
# **Emergent design** depends on code that is **easy to change**.

---
class: center, middle
# Reuse increase coupling.
???
DRY has a side-effect.

---
class: center, middle
# Code must be kept at the same level of abstraction (**SLAP**)
### (abstraction - trimming info on a subject to the absolute context relevant minimum)

---
class: codeonly

.crap[
```java
if (productsOwnedByPo.get(po.id()).containsKey(product.id())) {
  ...
}
```
]

--

.nice[
```java
if (productOwner.owns(product)) {
  ...
}
```
]

--

.crap[
```java



Collection<Boolean> checkboxes = new ArrayList<>();
```
]

--

.nice[
```java
Collection<Checkbox> checkboxes = ...
```
]

--

.crap[
```java



interface EShop {
    Map<String, String> resolveAffiliates(EShopSession session);
}
```
]

--

.crap[
```java
interface EShop {
    Affiliates affiliates(EShopSession session);
}
```
]

--

.crap[
```java
@AimForThis
interface EShopSession {
    Affiliates affiliates();
}
```
]

---
class: codeonly
.crap[
```java
MultivaluedMap<String, String> formParams = new Form();
for (String key : params.keySet()) {
    formParams.add(key, params.get(key));
}
```
]

--

.crap[
```java
Form form = new Form();
for (String key : params.keySet()) {
    form.add(key, params.get(key));
}
```
]

--

.nice[
```java
Form form = new Form(new Parameters(params));
```
]

--

.nice[
```java
Form form = new Form();
form.parameterize(new Parameters(params));
```
]

--

.nice[
```java
Form form = new Form();
form.parameterize(Parameters.from(httpRequest));
```
]

---
class: codeonly
.crap[
```java
class EquifaxFacade {
    public boolean validateAnswers(Map<String, String> questionToAnswerMap) {
      // we always get 4 questions from Equifax
      return MapUtils.isNotEmpty(questionToAnswerMap) && questionToAnswerMap.size() == 4;
    }
}
```
]

--

.nice[
```java
class Answer {
    String questionId;
    String answerId;
}
```
]

--

.crap[
```java
class EquifaxFacade {
    public boolean validateAnswers(Collection<Answer> answers) {
      // we always get 4 questions from Equifax
      return answers.size() == 4;
    }
}
```
]

--

.crap[
```java
class EquifaxFacade {
    private static final int MANDATORY_NUMBER_OF_ANSWERS = 4;

    public boolean validate(Collection<Answer> answers) {
      return answers.size() == MANDATORY_NUMBER_OF_ANSWERS;
    }
}
```
]

---
class: codeonly
.nice[
```java
class UnvalidatedAnswers {

    private static final int MANDATORY_NUMBER_OF_ANSWERS = 4;
    private final Collection<Answer> answers;

    boolean areValid() {
        return answers.size() == MANDATORY_NUMBER_OF_ANSWERS;
    }
}
```
]

--

.crap[
```java
class EquifaxFacade {
    public boolean validate(UnvalidatedAnswers answers) {
      return answers.areValid();
    }
}
```
]

--

.nice[
```java
@FacadeBecameObsolete
UnvalidatedAnswers answers = new UnvalidatedAnswers(...);
if (answers.areValid()) {
    ....
}
```
]

---
class: center, middle
# Reification - a process of making something concrete (implicit -> explicit).
???
- with lambdas, you can write short expressions easily. Often, you must reify them.


---
class: center, middle
# Let's come back to keeping code at the same level of abstraction...

---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = this.applicationCheckFactory.make(when, application, this.countryCode);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
  return checkResult;
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
* def check = makeCheck(application, when);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
  return checkResult;
}
```

---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
  return checkResult;
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
* log(check); // logIfNeeded if conditional needs to be communicated
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```
---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persistResults(checkResult);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persist(checkResult);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

---
class: codeonly
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
  if (this.runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* if (shouldRunScorecard(application)) {
    runScorecard(application);
  }
}
```

---
class: codeonly
.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return runScorecard && LoanAgreementType.MAIN.equals(application.agreementType());
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && LoanAgreementType.MAIN.equals(application.agreementType());
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && application.agreementType().equals(MAIN);
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && application.isAgreementOfTypeMain()); // WTF is Type?
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
  return scoringEnabled && application.isAgreementOfType(MAIN)); // WTF is Type?
}
```
]

--

.nice[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
   return scoringEnabled && agreement.isMain();
}
```
]

--

.nice[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
   boolean agreementIsApplicableForScoring = agreement.isMain();
   return scoringEnabled && agreementIsApplicableForScoring;
}
```
]

---
class: codeonly
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
  if (shouldRunScorecard(application)) {
      runScorecard(application);
  }
}
```

--

```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
}
```

--

```groovy
@MuchBetterButScoringDomainIsStillMissing
public def scoreApplicationIfNecessary(LoanApplication application) {
  if (shouldRunScorecard(application)) {
      runScorecard(application);
  }
}
```

--

```groovy
@AimForThisButTryToAvoidConditional
public def scoreApplicationIfNecessary(LoanApplication application) {
  Scoring scoring = new Scoring(application);
  if (scoring.isNecessary()) {
      Scorecard scorecard = scoring.scorecard();
      scorecard.run();
  }
}
```

---
class: center, middle
## The code should read like a top-down narrative. Start with high-level, abstract paragraphs. Then dive into details.
### — The Stepdown Rule


---
class: center, middle, example
# Comments

---
class: center, middle
# What I like of comments is deleting them
— *Someone*


---
class: center, middle
# Commenting code is like explaining a bad joke.
— *Someone*
???
code is like a joke.
refactor your joke.

---
class: center, middle
# A common fallacy is to assume authors of incomprehensible code will somehow be able to express themselves lucidly and clearly in comments
— *Kevlin Henney*

---
class: center, middle
background-image:url(cat.jpg)
background-size: 100%

---
class: codeonly
.crap[
```java
YAMLFactory factory = new YAMLFactory();
JsonParser parser = factory.createJsonParser(yamlString); // don't be fooled by method name...
```
]

--

.nice[
```java
YAMLFactory yaml = new YAMLFactory();
Parser parser = yaml.parser(yamlString);
```
]

--

.crap[
```java
@RequestMapping(method = { RequestMethod.GET, RequestMethod.POST })
String login() {
  // RequestMethod.POST protects from 405 "Method not supported" for clients
  // logging in before JS is loaded
  visitor.login();
  return "redirect:/profile";
}
```
]

--

.crap[
```java
@RequestMapping(method = { RequestMethod.GET, RequestMethod.POST })
String login() {
  visitor.login();
  return "redirect:/profile";
}
```
]

--

```java
class LoginEndpointSpec extends Specification {

    @SeeTrello("https://trello.com/b/0V4Fn8Gm/login-problem-ie7")
    def "supports login via http post"() {
        ...
    }

    def "supports login via http get"() {
      ...
    }
}
```

---

class: codeonly
```java
void teenagerParty() {
```

--

```java
  // inviting friends
  .. code
  .. code
  .. code
```

--

```java
  // finding a friend over 18
  .. code
  .. code
```

--

```java
  // buying booz
  .. code
  .. code
}
```

--

```java
  // buying parents a ticket to cinema
  .. code
  .. code
  .. code
```

--

```java
  // having a party
  .. code
  .. code
```

--

```java
  // suffering from hangover
  .. code
  .. code
  .. code
}
```
???
a pattern of long methods

---
class: codeonly
.nice[
```java
void teenagerParty() {
  inviteFriends();
  findAdultFriend();
  buyALotOfBuzz();
  buyParentsATicketToCinema();
  enjoyTheParty();
  sufferFromHangover();
}
```
]
???
the problem with large methods is that they lead to code duplication. No reuse :-)

--

class: codeonly
.crap[
```java
class Noop implements ModelAndViewDelegate {
    @Override
    public void delegate(ModelAndView model) {
         // do nothing
    }
}
```
]

--

class: codeonly
.crap[
```java
/**
 *  @author Tom Miller
 */
class ItsACollectiveCodeOwnershipDude {
}
```
]

---
class: codeonly
.crap[
```java
class Jetty {
    /**
     * Port on which jetty would run. Defaults to 8082;
     */
    public void setPort(int port) {

    }
}
```
]

--

.nice[
```java
class Jetty {

    private final int DEFAULT_PORT = 8082;
```
]

--

.nice[
```java
    public void run(int port) {
```
]

--

.nice[
```java
    public void run() {
      run(DEFAULT_PORT);
    }
```
]

--

.nice[
```java
    public int port() {
      return port;
    }
}
```
]

---
class: codeonly
.nice[
```java
interface Port {

  Port DEFAULT = () -> 8082;

  int number();
}
```
]

--

.nice[
```java
class Jetty {

  public void run(Port port) { ... }

  public Port port() {
    return port;
  }
}
```
]

--

.nice[
```java
class WebApplication {
  void start() {
      Jetty jetty = new Jetty();
      jetty.run(Port.DEFAULT);
  }
}
```
]



---
class: codeonly
.crap[
```java
@Transactional
public Client getClient() {
  Client client = repository.getRequired(Client.class, clientId);
  // lazy init
  client.getEntityUuid();
  return client;
}
```
]

--

```java
@Transactional
<T> T clientProjection(Function<Client, T> fn) {
  Client client = repository.getRequired(Client.class, clientId);
  return fn.apply(client);
}
```

--

```java
class Screenshot {
  void take() {
    // Base64 encoding is required by SauceLabs
    String base64Screenshot = webDriver.getScreenshotAs(OutputType.BASE64);
  }
}
```

--

```java
class Screenshot {
  private static final OutputType SAUCE_ENCODING = OutputType.BASE64;

  void take() {
    String screenshot = webDriver.getScreenshotAs(SAUCE_ENCODING);
  }
}
```

---
class: codeonly
.crap[
```java
// "--web-security=false"     -> allows cross-origin XHR
// "--ssl-protocols=any"      -> enable support for all SSL protocol versions
// "--ignore-ssl-errors=true" -> ignores SSL errors
String[] args = new String[] {
    "--web-security=false",
    "--ssl-protocol=any",
    "--ignore-ssl-errors=true" });

DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(PHANTOMJS_CLI_ARGS, args);
WebDriver driver = new PhantomJSDriver(capabilities);
```
]

--

.nice[
```java
String allowCrossOriginXhr = "--web-security=false";
String supportAllSslProtocolVersions = "--ssl-protocols=any";
String ignoreSslErrors = "--ignore-ssl-errors=true";

String[] args = new String[] {
    allowCrossOriginXhr,
    supportAllSslProtocolVersions,
    ignoreSslErrors
);

DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(PHANTOMJS_CLI_ARGS, args);
WebDriver driver = new PhantomJSDriver(capabilities);
```
]

---
class: codeonly
```java
class PhantomJSCapabilities {

    private final Collection<String> args = new HashSet<>();
```

--

```java
    public PhantomJSCapabilities allowCrossOriginXhr() {
      args.add("--web-security=false");
      return this;
    }
```

--

```java
    public PhantomJSCapabilities supportAllSslProtocolVersions() {
      args.add("--ssl-protocol=any");
      return this;
    }
```

--

```java
    public PhantomJSCapabilities ignoreSslErrors() {
      args.add("--ignore-ssl-errors=true");
      return this;
    }
```

--

```java
    public DesiredCapabilities desired() {
      DesiredCapabilities capabilities = new DesiredCapabilities();
      capabilities.setCapability(PHANTOMJS_CLI_ARGS, args.toArray(String[]::new));
      return capabilities;
    }
}
```

--

```java
WebDriver driver = new PhantomJSDriver(
  new PhantomJSCapabilities()
    .allowCrossOriginXhr()
    .supportAllSslProtocolVersions()
    .ignoreSslErrors()
    .desired());
```

---
class: codeonly
```java
@WhenAuthorCannotExpressHimselfInComments
@ThisIsCrappyCode(level = 10)
private void processMsgImages(File parentDir, EmailMessage emailMessage) {
* // find all img tag src's
  String body = emailMessage.getBody();
  Pattern p = Pattern.compile("<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>");
  Matcher m = p.matcher(body);
  List<String> imageSrcList = new ArrayList<String>();
  if (m.find()) {
    String src = m.group(1);
    imageSrcList.add(src);
  }

  for (String imgSrc : imageSrcList) {
		File imgFile = new File(parentDir, imgSrc);
		if (imgFile.exists()) {
			addEmbeddedField(emailMessage, imgFile);
			emailMessage.setBody(emailMessage.getBody().replace(imgSrc, "cid:" + imgFile.getName()));
		}
	}
}
```

--

```java
private void processMsgImages(File parentDir, EmailMessage emailMessage) {
* List<String> imageLinks = collectImageLinks(emailMessage);

  for (String imgSrc : imageSrcList) {
  File imgFile = new File(parentDir, imgSrc);
  if (imgFile.exists()) {
    addEmbeddedField(emailMessage, imgFile);
    emailMessage.setBody(emailMessage.getBody().replace(imgSrc, "cid:" + imgFile.getName()));
  }
  }
}
```

---
class: codeonly, large
```java
//
// Dear maintainer:
//
// Once you are done trying to 'optimize' this routine,
// and have realized what a terrible mistake that was,
// please increment the following counter as a warning
// to the next guy:
//
// total_hours_wasted_here = 16
//
```


---
### - Express intent with code (meta-annotation is code)

--

### - No FIXMEs

--

### - No TODOs

--

### - No commented out code

--

### - JavaDocs are made for public APIs. Internally, show usage with tests

---
class: codeonly
```java
@Nonnegative
```
--
```java
@OverridingMethodsMustInvokeSuper
```
--
```java
@WillClose
```
--
```java
@WillNotClose
```
--
```java
@GuardedBy
```
--
```java
@ThreadSafe
```
--
```java
@NotThreadSafe
```
--
```java
@Immutable
```

--
```java
@VisibleForTesting
```
--
```java
@Beta
```
--
```java
@Seconds
```
--
```java
@VisibleForHibernate
```
--
```java
@LegacyApproach("http://our.wiki/best-practices#34")
```
--
```java
@Spike("http://trello.com/b/0V4Fn8Gm/integration-poc")
```

---
class: center, middle
# Is Guava still a thing?

---
class: codeonly
```java
Range.closed(1, 3).contains(2);

Range.lessThan(5).contains(5);
```

--

```java
Multimap<String, String> gadgets = HashMutimap.create();

gadgets.put("iPhone", "5S");
gadgets.put("iPhone", "6S");
gadgets.put("LG", "Nexus");
```

--

```java
List<Iphone> iphones() {
  return ImmutableList.copyOf(iphones);
}
```

--

```java
Ordering<Money> ordering = Ordering
  .natural()
  .nullsFirst()
  .onResultOf(Money::amount);

Collection<Money> lotsOfMoney = ...

ordering.isOrdered(lotsOfMoney)

ordering.leastOf(lotsOfMoney, new Money(10.00));

ordering.reverse();
```

---
class: codeonly
```java
public int compareTo(Foo that) {
  return ComparisonChain.start()
    .compare(this.a, that.a)
    .compare(this.b, that.b)
    .compare(this.c, that.c, Ordering.natural())
    .result();
```


--

```java
CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, "CONSTANT_NAME"));
```

--

```java
new EqualsTester()
    .addEqualityGroup("hello", "h" + "ello")
    .addEqualityGroup("world", "wor" + "ld")
    .addEqualityGroup(2, 1 + 1)
    .testEquals();
```

--

```java
int maxNumberOfInsertions = 10000;
int falsePositiveProbability = 3;

BloomFilter<String> ipAddresses = BloomFilter.create(stringFunnel(Charsets.UTF_8),
                                                     maxNumberOfInsertions,
                                                     falsePositiveProbability);

boolean mightContain = ipAddresses.mightContain("121.21.13.111");
boolean neverContain = !mightContain;
```
???
Briefly, Bloom filters are a probabilistic DS, definitely NOT containing, but if yes - MAYBE


---
class: middle, center, example
# SOLID

---
class: middle, center
# Single Responsibility Principle
---
# How small the class should be?
???

--


### Mind-sized — *me*

--

### Small enough to lower coupling — *Marco Ceconni*
???
Marco Cecconi - Dev at StackOverflow

--

### Large enough to maximize cohesion — *Marco Ceconni*

--

### Small enough to be easy to understand, rewrite or replace  — *me*

--

### Small enough to be easy to test  — *me*

--

### Inside every large program, there is a small program trying to get out — *Tony Hoare*
???
TH - Quicksort

---
class: codeonly
```java
@TwoInterwoveConceptsAreHidingInside
class FtpClient {

  void transferFile(String filename, InputStream input)

  boolean fileExists(String filename);

  void makeDir(String parentDir, String dir);

  boolean folderExists(String folder);

}
```

--

```java
@GenericNamingLeadsToObesity
@HardToArgueThatTradeIsDoingMoreThanOneThing
class Trade {
  void process() {
    // 1000 LOC
  }
}
```

--

```java
class *Helper
```

--

```java
class *Utils
```

--

```java
class *Manager
```

--

```java
class *Service
```

--

```java
class *Controller
```

---
class: center, middle
## Fighting feature bloat

---
class: codeonly
```java
public class Tweet {

    private LocalDate postedAt = LocalDate.now();

    private Collection<Like> likes = new LinkedList<>();

    public LocalDate postedAt() {
        return postedAt;
    }

*   public Collection<Like> likes() {
*       return ImmutableList.copyOf(likes);
*   }
*
*   public void like(Like like) {
*     likes.add(like);
*   }
*
*   public long totalLikes() {
*     return likes.size();
*   }
*
*   public long totalLikesBy(LikerId likerId) {
*     return likes.stream().filter(like -> like.isPutBy(likerId)).count();
*   }
```

---
class: codeonly
```java
public class Tweet {

    private LocalDate postedAt = LocalDate.now();

    private Collection<Like> likes = new LinkedList<>();

    public LocalDate postedAt() {
        return postedAt;
    }

    public Likes likes() {
        return new Likes();
    }

    class Likes {

        public void put(Like like) {
            likes.add(like);
        }

        public long total() {
            return likes.size();
        }

        public long totalBy(LikerId likerId) {
            return likes.stream().filter(like -> like.isPutBy(likerId)).count();
        }

        public Collection<Like> all() {
            return ImmutableList.copyOf(likes);
        }
    }
}
```

---
class: center, middle
## Total likes during Black Friday?

---
class: codeonly
```java
class BlackFriday {
```

--

```java
    public boolean fallsOn(LocalDate date) {
        return blackFriday().isEqual(date);
    }
```

--

```java
    private LocalDate blackFriday() {
        return thanksGivingDay().plusDays(1);
    }
```

--

```java
    private LocalDate thanksGivingDay() {
        return Year.now()
                .atMonth(Month.NOVEMBER)
                .atDay(1)
                .with(TemporalAdjusters.lastInMonth(DayOfWeek.THURSDAY));
    }
}
```

--

.crap[
```java
class Likes {
    ...
    public long totalDuring(BlackFriday blackFriday) {
        return likes
            .stream()
            .filter(like -> blackFriday.fallsOn(like.when()))
            .count();
    }
    ...
}
```
]

---
class: codeonly
```java
class BlackFriday implements SpecialDay {
```

```java
    public boolean fallsOn(LocalDate date) {
        return blackFriday().isEqual(date);
    }
```

```java
    private LocalDate blackFriday() {
        return thanksGivingDay().plusDays(1);
    }
```

```java
    private LocalDate thanksGivingDay() {
        return Year.now()
                .atMonth(Month.NOVEMBER)
                .atDay(1)
                .with(TemporalAdjusters.lastInMonth(DayOfWeek.THURSDAY));
    }
}
```

.crap[
```java
class Likes {
    ...
    public long totalDuring(SpecialDay specialDay) {
        return likes
            .stream()
            .filter(like -> specialDay.fallsOn(like.when()))
            .count();
    }
    ...
}
```
]

---
class: center, middle
## But different clients has different query requirements...

---
class: codeonly
```java
public interface Entity<T> {
    default <R> R collect(Function<T, R> fn) {
        return fn.apply((T) this);
    }
}
```

--

```java
class Likes implements Entity<Likes> {
  ...
}
```

--

```java
class TotalDuringBlackFriday implements Function<Tweet.Likes, Long> {

    private final BlackFriday blackFriday = new BlackFriday();

    @Override
    public Long apply(Tweet.Likes likes) {
        return
          likes
            .all()
            .stream()
            .filter(like -> blackFriday.fallsOn(like.when()))
            .count();
    }
}
```

--

```java
Tweet tweet = ...
Tweet.Likes likes = tweet.likes();
long total = likes.collect(new TotalDuringBlackFriday());
```
???
- must side effect free!
- btw, can be written inline, as lambdas


---
class: codeonly
```java
public interface Entity<T> {
    default <R> R collect(Function<T, R> fn) {
        return fn.apply((T) this);
    }
    default boolean isSatisfiedBy(Predicate<T> predicate) {
        return predicate.test((T) this);
    }
}
```

--

```java
class GotMillionLikesOnAPostingDay implements Predicate<Tweet> {

        @Override
        public boolean test(Tweet tweet) {
            long likesOnAPostingDay = tweet
                    .likes()
                    .all()
                    .stream()
                    .filter(like -> like.isPutWhen(tweet.posted()))
                    .count();
            return likesOnAPostingDay >= 10000000;
        }
    }
```

--
```java
Tweet tweet = ...
boolean milionLikesInADay = tweet.isSatisfiedBy(new GotMillionLikesOnAPostingDay());
```

---
class: middle, center
# Open-Closed Principle

---
class: codeonly
.crap[
```java
class NotificationService {

  private final SmsNotifer viaSms;

  private final EmailNotifier viaEmail;

  NotificationService(SmsNotifier viaSms, EmailNotifier viaEmail) {
    this.viaSms = viaSms;
    this.viaEmail = emaviaEmailil
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        viaSms.send(notification);
      }
      viaEmail.send(notification);
  }
}

class SmsNotifier {
    void send(Notification notification);
}

class EmailNotifier {
    void send(Notification notification);
}
```
]

---
class: codeonly
```java
class EveryNotificationChannel {

  private final SmsNotificationChannel smsChannel;

  private final EmailNotificationChannel emailChannel;

  public EveryNotificationChannel(SmsNotificationChannel sms, EmailNotificationChannel email) {
    this.smsChannel = sms;
    this.emailChannel = email;
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        smsChannel.send(notification);
      }
      emailChannel.send(notification);
  }
}

class SmsNotificationChannel {
    void send(Notification notification);
}

class EmailNotificationChannel {
    void send(Notification notification);
}
```
???
omni - every from latin.

---
class: codeonly
```java
class EveryNotificationChannel {

  private final SmsNotificationChannel smsChannel;

  private final EmailNotificationChannel emailChannel;

  public EveryNotificationChannel(SmsNotificationChannel sms, EmailNotificationChannel email) {
    this.smsChannel = sms;
    this.emailChannel = email;
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        smsChannel.send(notification);
      }
      emailChannel.send(notification);
  }
}

class SmsNotificationChannel implements NotificationChannel {
    void send(Notification notification);
}

class EmailNotificationChannel implements NotificationChannel {
    void send(Notification notification);
}

interface NotificationChannel {
    void send(Notification notification);
}
```

---
class: codeonly
```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
*     if (notification.isNotTooLongForSms()) {
        smsChannel.send(notification);
      }
      emailChannel.send(notification);
  }
}

interface NotificationChannel {
    void send(Notification notification);
}
```

---
class: codeonly
```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        smsChannel.send(notification);
      }
      emailChannel.send(notification);
  }
}

interface NotificationChannel {
    void send(Notification notification);
    boolean accepts(Notification notification);
}
```

--
```java
class EmailNotificationChannel implements NotificationChannel {
    boolean accepts(Notification notification) { return ALWAYS; }
}
```

--
```java
class SmsNotificationChannel implements NotificationChannel {
    boolean accepts(Notification notification) {
        return notification.isSatisifiesBy(new FitsIntoSms());
    }
}
```

--
```java
class FitsIntoSms implements Predicate<Notification> {
    public boolean test(Notification notification) {
      return notification.isNotTooLongForSms();
    }
}
```

---
class: codeonly
```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
      notificationChannels.stream()
        .filter(channel -> channel.accepts(notification))
        .forEach(channel -> channel.send(notification));
  }
}
```

--

```java
class EveryNotificationChannel implements NotificationChannel {
  ...
}
```

---
class: center, middle
# Liskov Substitution Principle
???
indicators - instanceof checks, UnsupportedOperationException, funny restrictions (don't use this class if...)

---
background-image:url(toinstant.png)
background-size: 100%
???
java.sql.Date extends java.util.Date

---
class: codeonly
.crap[
```java
class MapWithMandatoryValues implements Map<String, String> {
    @Override
    String get(Object key) {
        def value = super.get(key)
        if (!value) {
            throw new MissingParameter(key as String)
        }
        value
    }
}
```
]

--

```java
class TradeOrder {
  void cancel() {
    notifyRegulators();
  }
}
```

--
.crap[
```java
class SilentTradeOrder extends Trade {
  @Override
  void notifyRegulators() {
  }
}
```
]

---
class: codeonly
```java
class Amount {
    private final BigDecimal origin;
    public Amount(BigDecimal origin) {
      Preconditions.checkArgument(origin.isPositive(), "Only positive amount is supported");
      this.origin = origin;
    }
}
```

--

```groovy
class AmountSpec extends Specification {
    def "does not support negative numbers"() {
      when:
        new Amount(-1.00)
      then:
         def e = thrown(IllegalArgumentException)
         e.message == "Only positive amount is supported"
    }
}
```

--

.crap[
```java
class Amount {
    BigDecimal origin;
    public Amount(BigDecimal origin) {
      Preconditions.checkArgument(origin.isPositive(), "Only positive amount is supported");
      this.origin = origin;
    }
    Amount() {
    }
}
```
]

--

.crap[
```java
class SignedAmount extends Amount {
    public SignedAmount(BigDecimal origin) {
      super();
      this.origin = origin;
    }
}
```
]


---
### - Subclassing is evil because a subclass that breaks invariants may look completely logical in isolation.

--
### - **Normalized hierarchy** is a hieararchy in which no class has more than one implementation of a method.

--
### - Prefer composition over inheritance and, if not possible, stick to **NF**.
???
- we do inheritance because its easy. We get functinaluty for free.
- but we also committed to make a class substitute.
- IntelliJ - replace inheritance with delegation :-) stop typing.
- if you dont have IDE like this... Find someone who can type very fast.
- violating DRY and OCP now :-) Your choice.
- Worker work() and Manager w/o work example @Delegate

---
class: center, middle
# The Interface Segregation Principle

---
class: center, middle
# Many client specific interfaces are better than one general purpose interface.
### — *Robert Martin, Agile Software Development*

---
# What's wrong with FAT interfaces?

--

### Suffer from low cohesion

--

### Suffer from high afferent/efferent coupling
???
afferent - in
efferent - out

--

### Make implementers suffer from the same deseases

---
class: codeonly
.crap[
```java
package shwitter.config;
interface ProductSettings {
    Attempts maxRegistrationAttempts();
    BonusAmount bonusAmount();
    Income minimalIncome();
    ...
}
```
]

--
.nice[
```java
package shwitter.registration;
interface RegistrationAttempts {
    Attempts max();
}
```
]

--

.nice[
```java
package shwitter.loyalty;
interface BonusAmount extends DecimalNumber {
}
```
]

--

.nice[
```java
package shwitter.lending.rules;
interface IncomeConstraints {
    Income minimal();
}
```
]

--

```java
@ConsiderComplexityOfAnImplementer
```

--

```java
@ConsiderComplexityOfATest
```

--

```java
@ConsiderImpactOfMovingAnInterface
```

---
class: codeonly
```java
interface BacklogItem {
    Complexity complexity();
    void estimate(Duration duration);
}
```

--

.crap[
```java
@MurphysLawHitTheFan
class EstimateForecast {
    private final BacklogItem backlogItem

    Duration duration() {
      Duration duration = forecast(backlogItem.complexity());
*     backlogItem.estimate(duration);
      return duration;
    }
}
```
]

--

```java
interface Complex {
  Complexity complexity();
}
```

--

```java
interface BacklogItem extends Complex {
    void estimate(Duration duration);
}
```

--

```java
class EstimateForecast {
    private final Complex complex;

    Duration duration() {
      Duration duration = forecast(complex.complexity());
*     complex.estimate(duration); // compile error
      return duration;
    }
}
```

---
class: center, middle
# Dependency Inversion Principle

---
class: center, middle
# High-level modules should not depend on low-level modules. Both should depend on abstractions.
### — *Robert Martin, Agile Software Development*
???
the goal is to increase reuse of a high-level modules.

---
class: codeonly

```java
*package app.invoicing;
```

--

```java
class Invoice {
    InputStream input();
}
```

```java

*package infra.pdf;
```

--
```java
interface Canvas {
    OutputStream output();
}
```

--
```java
class ITextDocument {

    private final Invoice invoice;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(invoice.input(), canvas.output());
    }
}
```

---
class: codeonly
```java
*package app.invoicing;
```


```java
class Invoice {
    InputStream input();
}
```

```java
@NotReusableBecauseItDependsOnInvoicing
@CannotBeExtractedInASeparateModule
*package infra.pdf;
```

```java
interface Canvas {
    OutputStream output();
}
```

```java
class ITextDocument {

    private final Invoice invoice;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(invoice.input(), canvas.output());
    }
}
```

---
class: codeonly
```java
*package app.invoicing;

class Invoice implements PdfSource {
    InputStream input();
}

interface PdfSource {
    InputStream input();
}
```

--

```java
@DecouplingByAbstraction
@StillCannotBeExtractedInASeparateModule
*package infra.pdf;

class ITextDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.input(), canvas.output());
    }
}
```

---
class: codeonly
```java
*package app.invoicing;

class Invoice implements PdfSource {
    InputStream input();
}
```


```java
@DependencyInverted
@CanBeExtractedInASeparateModule
@UsageDirectionIsOpposedToDependencyDirection
*package infra.pdf;

class ITextDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.input(), canvas.output());
    }
}

interface PdfSource {
    InputStream input();
}
```

---
class: codeonly
```java
*package app.invoicing;

@RestController
class InvoiceEndpoint {

  private final Invoices invoices;

  @GetMapping(value = "/invoices/{id}", produces = "application/pdf")
  void download(String id, HttpServletResponse response) {
    Invoice invoice = invoices.by(id);
```

--

```java
    ITextDocument document = new ITextDocument(invoice);
```

--

```java
    Canvas canvas = new HttpOutCanvas(response);
```

--

```java
    document.render(canvas);
  }
}
```

---
class: center, middle
## Now let's make invoicing domain independent of iText and let plug any PDF rendering mechanism...

---
class: codeonly

```java
*package infra.pdf.api;

interface Canvas {
  OutputStream output();
}

interface PdfSource {
    InputStream input();
}
```

--

```java
interface PdfDocument {
  interface Factory {
    PdfDocument create(PdfSource source);
  }

  void render(Canvas canvas);
}
```

--

```java
*package infra.pdf.impl.itext;

class ITextDocument implements PdfDocument {
    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = ...
    }
}
```
--

```java
@Singleton
class ITextDocumentFactory implements PdfDocument.Factory {

    public PdfDocument create(PdfSource source) {
        return new ITextDocument(source);
    }
}
```

---
class: codeonly
```java
*package infra.pdf.impl.pdfbox;

class BoxPdfDocument implements PdfDocument {
    private final PdfSource source;

    public void render(Canvas canvas) {
        PDFBox box = ...
    }
}
```

--

```java
@Singleton
class BoxPdfDocumentFactory implements PdfDocument.Factory {
    ....
}
```

--

class: codeonly
```java
*package app.invoicing;

@RestController
class InvoiceEndpoint {

  private final Invoices invoices;

  private final PdfDocument.Factory pdfDocumentFactory;

  @GetMapping(value = "/invoices/{id}", produces = "application/pdf")
  void download(String id, HttpServletResponse response) {
    Invoice invoice = invoices.by(id);
```

--

```java
    PdfDocument document = pdfDocumentFactory.create(invoice);
```

--

```java
    Canvas canvas = new HttpOutCanvas(response);
```

--

```java
    document.render(canvas);
  }
}

---
### Consider **weight**
```java
package infra.pdf.impl.itext;
*@javax.inject.Singleton // javax.inject:javax.inject
class ITextPdfDocumentFactory implements PdfDocumentFactory {
    ...
}
```

### vs.

```java
package infra.pdf.impl.itext;
*@org.springframework.stereotype.Component // org.springframework:spring-context
class ITextPdfDocumentFactory implements PdfDocumentFactory {
    ...
}
```

---
class: center, middle
## A bit more modularty...

---
class: center, middle
## Consider **weight**

---

### - **@javax.inject.Singleton** vs. **@org.springframework...Component**

--

### - **@javax.inject.Inject** vs. **@org.springframework...Autowired**

--

### - library that depends on **slf4j-api** vs. **Logback**

--

### - library that depends on **Guava** vs. just **JDK 8**

--

### - library that depends on **Scala** vs. just **JDK 8**

--

### - transitive dependencies also add to weight
---
background-image:url(repackage.png)
background-size: 100%

---
class: center, middle
## Consider **granularity**

---
class: codeonly
```groovy
configurations {
    compile.exclude module: "spring-boot-starter-tomcat"
}

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web:1.4.0.RELEASE")
    compile("org.springframework.boot:spring-boot-starter-jetty:1.4.0.RELEASE")
    // ...
}
```
???
but in general, Spring Boot is very fine grained.

---
class:libs
background-image:url(jetty.png)
background-size: 100%

---
background-image:url(aws.png)
background-size: 100%

---
# More on modularity
![](kirk.jpg)

---
class: center, middle
## Logical design requires the same amount of attention as the physical one.

---
class: nopadding
background-image:url(hibernate.png)
background-size: 100%
### .spanny[Hibernate Core v4.3.8.Final]
???
ok, you have nice physical modularity, but what about logical design?

---
class: nopadding
background-image:url(jdk7.png)
background-size: 100%
### .spanny[JDK v1.7.0_51]

---
class: nopadding
background-image:url(findbugs10.png)
background-size: 100%
### .spanny[Findbugs V1.0 - A great start]

---
class: nopadding
background-image:url(findbugs11.png)
background-size: 100%
### .spanny[Findbugs V1.1 – Imperfection creeps in]

---
class: nopadding
background-image:url(findbugs12.png)
background-size: 100%
### .spanny[Findbugs V1.2 – Imperfection takes hold]

---
class: nopadding
background-image:url(findbugs13.png)
background-size: 100%
### .spanny[Findbugs V1.3 – Chaos begins]

---
class: nopadding
background-image:url(findbugs14.png)
background-size: 100%
### .spanny[Findbugs V1.4 – Explosion]

---
class: nopadding
background-image:url(spring.png)
background-size: 100%
### .spanny[Spring v4.1.6]


---
class: right, middle
## **A JDK code base is deeply interconnected** at both the API and the implementation levels, having been built over many years primarily in the style of a monolithic software system. .fade[We’ve spent considerable effort eliminating or at least simplifying as many API and implementation dependences as possible, so that both the Platform and its implementations can be presented as a coherent set of interdependent modules, but some particularly thorny cases remain.]
### — *Mark Reinholds, Chief Architect of the Java Platform*


---
class: center, middle
## From assessing hundreds of software systems on three continents I know that about 90% of software systems are suffering from severe architectural erosion, i.e. there is not a lot of the original architectural structure left in them, and **coupling and dependencies are totally out of control**.
### — *Alexander von Zitzewitz*

---
# Hints
### Manage dependencies (Stan4j, Structure 101, VeriPacks)

--

### Avoid circular dependencies (merging, DI, demotion, escalation)
???
- you have seen escalation with a Black Friday

--

### Prefer smaller packages over large ones

--

### Provide slim interface and hide implementation details
???
@Component package-private.

--

### Group tightly-coupled classes together (Common Closure Principle)

--

### Reify! (e.g. String traderId vs TraderId traderId)


--

### [Architecting well-structured Java applications](https://www.youtube.com/watch?v=99VFdX1WS7o) — *Eduards Sizovs*

---
class: center, middle
## VeriPacks demo


    </textarea>
    <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        slideNumberFormat: function (current, total) { return "" }
      });
      slideshow.on('afterShowSlide', function (slide) {

        var axs =  {
                  title: 'thoughput / responsiveness over time.',
                  xaxis: {
                    title: 'time (months)'
                  },
                  yaxis: {
                    title: 'throughput / responsiveness (RTF / sprint)'
                  }
                }

        var thr = [
                {
                  x: [2, 10, 14, 24, 40],
                  y: [30, 29, 28, 23, 10],
                  name: 'continuous degradation',
                  mode: 'lines',
                  line: {
                      color: 'rgb(219, 64, 82)',
                      width: 3
                    }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30, 30, 30, 30],
                  name: 'sustainable pace',
                  mode: 'lines',
                  line: {
                      color: 'rgb(169, 169, 169)'
                  }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30.5, 31, 31.5, 32],
                  name: 'continuous improvement',
                  mode: 'lines'
                },
          ];

          var dbt = thr.concat({
                  x: [28, 28],
                  y: [30, 20],
                  name: 'technical debt',
                  mode: 'lines',
                  line: {
                    dash: 'dot'
                  }
                } );

        if (slide.properties.name == "throughput") {
          Plotly.newPlot('throughput', thr, axs);
        }
        if (slide.properties.name == "debt") {
          Plotly.newPlot('debt', dbt, axs);
        }
      });

    var ktx = document.getElementsByClassName("ktx");
    for(var i = 0; i < ktx.length; i++) {
       katex.render(ktx.item(i).getAttribute('expr'), ktx.item(i));
      }
    </script>

  </body>
</html>
