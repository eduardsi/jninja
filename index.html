<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }

      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Effective Coding Principles and Patterns in Java 8

---
class: center, middle
# Welcome.
???
Introduce myself and let others introduce themselves.
Setting expectations:
- Not Java 8 course.
- Learn principles, practices and patterns for writing readable, maintainable and effective code - CLEAN CODE. In modern Java.
- My goal is to make you feel that he rules will tell you to do things that are really weird or NOT to do something that you did. Be open minded.



---
# Agenda
- Day I: General Software Design
- Day II:
- Homework (with group code review).

---
class: center, middle, invert
# Java 8 additions in 4 slides
---
###**java.time** (Clock, Instant, LocalDate, TemporalAdjuster)
???
No Joda anymore.
--

###**streams** (collections, arrays, chars, files etc.)

--

###**lambdas**

--

###**@FunctionalInterface** (Function, Predicate, Consumer, Supplier)

--

###**method references** (Class::new, instance::method)

--

###**default methods**

--

###**java.lang.reflect.Parameter** (--parameters compiler argument)

--

### **PermGen** replaced with out-of-heap **Metaspace**

---
### **implicit conversion**

--

```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
--
```java
Converter<String, Integer> converter = Integer::valueOf;
```
--
```java
class Person {

    private final String firstName, lastName;

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```
--
```java
interface PersonFactory {
    Person create(String firstName, String lastName);
}
```
--
```java
PersonFactory personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");
```

---
### **checked exception in lambdas**
.crap[
```java
Arrays.stream(dir.listFiles())
        .map(file -> {
            try {
                return file.getCanonicalPath();
            } catch (IOException e) {
                throw new RuntimeException(e);

            }
        })
        .forEach(System.out::println);
```
]
---

.nice[
```java
Arrays.stream(dir.listFiles())
        .map(Unchecked.function(File::getCanonicalPath))
        .forEach(System.out::println);
```
]

--

.nice[
```java
class Unchecked {
  public static <T, R> Function<T, R> function(CheckedFunction<T, R> function) {
    return t -> {
        try {
            return function.apply(t);
        }
        catch (Throwable e) {
          if (e instanceof Error) {
              throw (Error) e;
          }
          if (e instanceof RuntimeException) {
              throw (RuntimeException) e;
          }
          throw new RuntimeException(e);
        }
    };
  }

}
```
]

--

.nice[
```java
@FunctionalInterface
public interface CheckedFunction<T, R> {
    R apply(T t) throws Throwable;
}
```
]

---
class: center, middle, invert
# The economics of software design 101
???
Before HOW -> WHY

---
class: center, middle
# There is a strong correlation between quality of the codebase and developer productivity or **throughput**.
## (c) me
???
- The higher is quality, the higher is productivity. And vice versa.
- Everyone agrees?!
- Productivity - TIME we spend per CHANGE.

---
class: middle
# <span class="ktx" expr="Throughput = \dfrac{RTF}{TIME}"></span>
#### *RTF - Released Tested Features (c) [The Economics of Software Design](https://www.youtube.com/watch?v=7HecgbghFTk), J.B. Rainsberger *
???

---
class: center, middle
# Higher throughput = lower **cost per change**.
#### <span class="ktx" expr="cost\,per\,change = time\,spent\,on\,change\,\times salary"></span>

---
class: center, middle
# Why do these guys move so slow?!
???
Low throughput

---
class: center, middle
# Why are these guys so expensive?!
???
High CPC (low throghput; too low for given salary!!!)


---
class: center, middle
# By writing clean code, you enable **stable throughput / responsiveness over time**.
### (the time that is usually longer than your employment)
???
- The goal of design is to be able to ship as fast as we can now not only in the next 3 months, but in years etc.
- Unfortunately, we do not usually know see long-term consequences of our work, but we should.
- For example, my best friend is now maintaining a software that I wrote 6 years ago :-)


---
name: throughput
<div id="throughput" style="width: 100%; height: 100%;"></div>
???
- team is slow and becomes a bottleneck to make world a better place :-) New teams, rewrites etc.
- a nice thing about sustainable pace that I can estimate.
- Do you know the rule that makes throughput gradually grow? BS rule. That's how we escale from SHIT.
- Can someone explain why throughput drops that fast?

---
#  Reinforcing loops:
### low throughput -> pressure -> more corners cut -> lower throghput
### low throughput -> unmet deadlines -> more people to work on features -> lower throughput (Brook's Law)
### low quality tolerated -> lower quality (Broken window theory)
### low quality tolerated -> lower quality -> tolerated -> even bigger decline in quality -> ... (Drift to Low Performace)
### Graham's Law
???
- BWT - if there is mess, or rush, you don't be the first to make a mess.
- Graham's law - Shitty component remain a part of the system over time precisely because it's hard to take out. Conversely, a component that is easy to replace is one that we may replace.

---
![](donella.png)

---
name: debt
<div id="debt" style="width: 100%; height: 100%;"></div>
???
- TD - cumulative consequences of corners being cut.
- In this example, we pay TD in terms of throughput.

---
class: center, middle
# ?
???
- raise your hand who thinks technical debt is a bad thing?
- who thinks it's a good thing?
- is taking a loan a bad thing?
- is taking and loan and not returning it back for a long time - a bad thing?

---
class: center, middle
# Technical debt is a **tool** for gaining a **short-term** gain. **Causes addiction** and needs to be **managed**.
???
- Spike and Throwaway! (Dan North). E.g. TDDing at this level is kinda waste.
- Meeting deadline (critical problem, black swan events -> unexpected prospect)

---
class: conversation
### **Manager**: When will the new permission be done?
### **Dev**: Mmmm, I hope tomorrow, in the end of the day.
### **Manager**: We need it today. Can’t you find a “creative” way to do it?
### **Dev**: Let me think…
### **Manager**: We have 5 clients that really need this today. Else they will probably not sign the contract.
### **Dev**: But the…
### **Manager**: Look, it’s important that you understand the business value of it. Isn’t it just a new condition in the code? Just put it there, and we’ll “fix it” later.
### **Dev**: Ok.
### **Manager**: So we’ll be able to deploy today?
### **Dev**: Aham.
#### *— [Technical Debt 101](https://medium.com/@joaomilho/festina-lente-e29070811b84#.7d8asvofr)*

---
class: bottom, right
background-image:url(techDebtQuadrant.png)
#### *Technical debt quadrant: http://martinfowler.com/bliki/TechnicalDebtQuadrant.html*
???
- reckless - we focus on completing tasks fast instead of building HQ system. Boil like frogs.
- It's often the case that it can take a year of programming on a project before you understand what the best design approach should have be.

---
class: center, middle, bad
# The only way to go fast is to go well.
### (c) Uncle Bob
???
really?

---
class: center, middle, oki
# The only way to go fast [in a long run] is to go well.
### (c) Uncle Bob (edited)

---
class: center, middle
# Does writing clean code take more time than writing crap?
???
- takes time -> lower throghput -> higher cost per change. -> quality is expensive

---
class: center, middle
# Reading vs. writing ratio is 10:1.
???
we want reading to be easy if it makes writing harder. Making code easy to read, makes it easier to write.

---
class: center, middle
# There are people who write clean code blazingly fast.
???
I saw master at work. You can be that master. Skill acquisition graph (performance over time)

---
class: center, middle
# If something is not worth our time, consider not doing it.
![](stepsofmastery.png)
???
- Avoiding it - nice! less INHERENT COMPLEXITY. less code to maintain.
- Agile Manifesto principle. Simplicity — the art of maximizing the amount of work not done.
- First law of software quality: e = mc^2 ; errors = (more code)^2

---
class: center, middle
# It only takes one crappy class to harm your reputation.
???


---
class: center, middle
## If you think someone is an asshole, most people who are silently observing the situation think so, too.
#### *— Guy’s Theory of Perfect Knowledge of Assholes*

---
background-image:url(SonarQube-02.png)
???
- not used
- running on every push
- before every push (https://hub.docker.com/_/sonarqube)
- running on every code change

---
class: lint
background-image:url(sonarlint.png)

---
class: center, middle, invert
# Naming

---
### Astonishing / non-intention revealing Twilio API
```java
import com.twilio.sdk.TwilioRestClient;
import com.twilio.sdk.TwilioRestException;
import com.twilio.sdk.resource.factory.MessageFactory;
import com.twilio.sdk.resource.instance.Message;
import org.apache.http.NameValuePair;
import org.apache.http.message.BasicNameValuePair;

public class Example {

  // Find your Account Sid and Token at twilio.com/console
  public static final String ACCOUNT_SID = "{{ account_sid }}";
  public static final String AUTH_TOKEN = "{{ auth_token }}";

  public static void main(String[] args) throws TwilioRestException {
    TwilioRestClient client = new TwilioRestClient(ACCOUNT_SID, AUTH_TOKEN);

    // Build a filter for the MessageList
    List<NameValuePair> params = new ArrayList<NameValuePair>();
    params.add(new BasicNameValuePair("Body", "Hello from Java"));
    params.add(new BasicNameValuePair("To", "+12345678901"));
    params.add(new BasicNameValuePair("From", "+12345678901"));

    MessageFactory messageFactory = client.getAccount().getMessageFactory();
*   // this guy actually sends a message. Violates Least Astonishment Principle
*   Message message = messageFactory.create(params);
  }
}
```
???
The code is not HONEST.

---
```java
// quite a big surprise for a client
void update(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
}
```

```java
// if you can't do something - fail
// force client to check the conditional
void update(Entity entity) {
  checkArgument(entity.isIdAssigned(), "Cannot update entity. Id is missing");
  ...
}
```

```java
// if you really need to communicate conditional execution
void updateIfIdAssigned(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
}
```
---
### Take scope into account
```java
interface Employee {
  String employeeAddress();
}

interface Employee {
  String address();
}
```
```java
class Transaction {
  enum TransactionScope { }
}

class Transaction {
  enum Scope { }
}
```

```java
// Packages are usually exception to the rule
package org.framework.batch

interface Reader { }         // :(
interface Operation { }      // :(

interface BatchReader { }    // :)
interface BatchOperation { } // :)
```

---
### Composite names usually indicate lack of a root object
```java
class AwsS3Bucket {

  private final String awsPassword;
  private final String awsLogin;
  private final String bucketName;

  public AwsS3Bucket(String awsLogin, String awsPassword, String bucketName) {
    this.awsLogin = awsLogin;
    this.awsPassword = awsPassword;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```
```java
class AwsCredentials {

  public final String login;
  public final String password;

  public AwsCredentials(String login, String password) {
    this.login = login;
    this.password = password;
  }
}
```

---
```java
class AwsS3Bucket {

  private final AWSCredentials awsCredentials;
  private final String bucketName;

  public AwsS3Bucket(AwsCredentials awsCredentials, String bucketName) {
    this.awsCredentials = awsCredentials;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

```java
class AwsAccount {

  private final AwsCredentials credentials;

  public AwsAccount(AwsCredentials credentials) {
    this.credentials = credentials;
  }

}
```

---
```java
class AwsS3Bucket {

  private final AwsAccount account;
  private final String bucketName;

  public AwsS3Bucket(AwsAccount account, String bucketName) {
    this.account = account;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

---
### Consider searchability
```java
class CancelTransaction { }

// vs.

class CancelTransactionCommand { }
```

```java
class NotifyOnApplicationCanceled
  implements DomainEventHandler<LoanApplicationCanceled> {
}

// vs.

class NotifyOnLoanApplicationCanceled
  implements DomainEventHandler<LoanApplicationCanceled> {
}
```

### Stay consistent
```java
class RegistrationFailure extends BusinessException { }

// vs.

class RegistrationException extends BusinessException { }
```

---
class: center, middle
# Prefer creating objects that represent **what they are**, rather than what they do

---
```java
class File { }

interface FileReader {
   Data read(File file) { }
}
```
```java
interface DataFile {
   Data data();
}
```
```java
interface EmailSender {
  void send(Email email);
}
```

```java
interface EmailProvider {
  void send(Email email);
}
```

```java
interface ConditionChecker {
  boolean checkCondition()
}
```

```java
interface Condition {
  boolean isTrue();
}
```

---
```java
interface MoneyFormatter {
  String format(Money money);
}
```
```java
interface PrettyMoney {

  String asText();

  class Humane implements PrettyMoney {
    @Override
    public String asText() { ... }
  }

  class ISO_1234 implements PrettyMoney {
    @Override
    public String asText() { ... }
  }

}
```

```java
public static void main(String[] args) {
    Money money = new Money(99.00);
    PrettyMoney prettyMoney = new PrettyMoney.Humane(money);
    println(prettyMoney.asText());
}
```
???
- makes our software more OO, composable from classes, not methods
- why not MoneyFormat?
- why not toString()

---
```java
class FuckupProbabilityCalculator {
    BigDecimal calculate() { ... }
}
```
```java
class FuckupProbability implements DecimalNumber {
    BigDecimal decimal();
}
```
```java
interface DecimalNumber {

    BigDecimal decimal();

    default DecimalNumber dividedBy(DecimalNumber divisor) {
        BigDecimal roundedDivision = decimal().divide(divisor.decimal(), RoundingMode.HALF_DOWN);
        return new Const(roundedDivision);
    }

}```
```java
class Const implements DecimalNumber {

    private final BigDecimal origin;

    public Const(int origin) { this(BigDecimal.valueOf(origin, 2)); }

    public Const(BigDecimal origin) { this.origin = origin; }

    @Override
    public BigDecimal decimal() { return origin; }
}
```
---
```java
public static void main(String[] args) {
    DecimalNumber minimal = new FuckupProbability(...);
    DecimalNumber maximal = new FuckupProbability(...);
    DecimalNumber average = minimal.plus(maximal).dividedBy(new Const(2));
}
```

```java
public static void main(String[] args) {
    DecimalNumber minimal = new FuckupProbability(...);
    DecimalNumber maximal = new FuckupProbability(...);
    DecimalNumber average = new Average(minimal, maximal)
}
```
```java
class Average implements DecimalNumber {

    private final DecimalNumber[] numbers;

    public Average(DecimalNumber... numbers) {
        this.numbers = numbers;
    }

    @Override
    public BigDecimal decimal() {
        DecimalNumber total = new Const(numbers.length);
        DecimalNumber sum = new Sum(numbers);
        DecimalNumber average = sum.dividedBy(total);
        return average.decimal();
    }

}
```
---
class: bad
```java
public final class BigDecimalUtils {

	public static final int AMOUNT_SCALE = 2;

	private BigDecimalUtils() {
	}

	public static BigDecimal amount(int value) {
		return amount(new BigDecimal(value));
	}

  public static BigDecimal amount(BigDecimal amount) {
		return amount.setScale(AMOUNT_SCALE, BigDecimal.ROUND_HALF_UP);
	}

  public static boolean isEqual(BigDecimal value1, BigDecimal value2) {
		boolean isEqual = value1.compareTo(value2) == 0;
		return isEqual;
	}

  public static boolean isInRange(BigDecimal amount, BigDecimal amountFrom, BigDecimal amountTo) {
    return isGe(amount, amountFrom) && isLe(amount, amountTo);
  }

  public static boolean isZero(BigDecimal value) {
    return isEqual(BigDecimal.ZERO, value);
  }

  ...

}
```
---
class: center, middle
# Methods are either **commands** or **queries**.
### Use commands (verbs) to tell an object what to do.
### With queries (nouns) you ask object a question.
— *[Command/Query Separation](http://martinfowler.com/bliki/CommandQuerySeparation.html)*
---

```java
interface Iterator<T> {
  T next(); // give next or return next? both! :-)
}
```

```java
interface Iterator<T> {
  void advance();
  T current();
}
```

```java
InputStream load(URL url);
```

```java
InputStream stream(URL url);
```

```java
String read(File file);
```

```java
String content(File file);
```

---
```java
class Document {
  int write(InputStream stream); // returns number of bytes written :(
}
```
```java
class Document {
   OutputPipe output();
}

class OutputPipe {

     void write(InputStream stream);

     int bytes();

     long time();
}
```

---
# Avoid getters
## Getters are verbs
## Get **may** have a side effect
### - get married
### - get money from the ATM
### - get from A to B...

---
```java
class Client {
  String fullName();
  String personalId();
}
```

```java
interface Iterator<T> {
  T current();
}
```
### Sometimes booleans are not nouns, but are NEVER verbs
```java
class Customer {
  boolean isSatisfiedBy(Specification); // satisfiedBy -> confusing
}
```
```java
enum Severity {
  boolean isMajor(); // major() -> confusing
}
```
```java
class ProductCatalog {
  boolean contains(Product);
}
```
```java
interface Input {
  boolean validate(); // verb! :(((
}
```

---
# Avoid setters
## ...and don't treat your objects as **data structures**
???
- Pure OO design require encapsulation. Frameworks as for data. Conflict.

```java
Client.setFirstName(firstName);
Client.setLastName(lastName);
```

```java
Client.giveName(String firstName, String lastName);
```
???
grant permissions vs. set permissions

```java
void setPreferredAgreementType(AgreementType preferredAgreementType) { }
```

```java
void preferAgreement(AgreementType preferredAgreementType) { }
```

```java
void setAgreementSigned(boolean agreementSigned) {}
```

```java
void signAgreement() {} // agreement().sign() would be way better
```
```java
void unsignAgreement() {}
```


---
# Data structures
## Do not have behaviour
## **Can** have getters and setters (if needed)
```java
class UserRepresentation {

  public final String firstName;
  public final String lastName;
  public Optional<String> middleName = Optional.empty();

  UserRepresentation(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
}
```
```java
UserRepresentation userRepresentation = new UserRepresentation("Jackie", "Chan");
println userReprensetation.firstName;
println userReprensetation.lastName;
```

---
# Package naming
## Name of the company has nothing to do with code
```java
package org.apache.spark;
```

```java
package spark;
```

## Plural or singular?
```java
package shipyard.maps; // contains different maps and nothing else
```
```java
package shipyard.map; // everything related to maps
```
```java
package shipyard.navigation;      // everything related to navigation
package shipyard.navigation.maps;
```

---
class: center, middle, invert
# Tony Hoare's billion dollar mistake

---
# In computing, a null pointer has a value reserved for indicating that the pointer does not refer to a valid object.
## - Do not pass nulls
## - Do not return nulls
---
```groovy
compile group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
```

### package-info.java
```java
@ParametersAreNonnullByDefault
package wombatizer;
```

```java
@Override
public boolean equals(@Nullable Object obj) { ... }
```
???
- otherwise I will have to null-check all arguments, to be defensive.

---
### may not contain a phone number that matches a given regex
```java
interface PhoneBook {
  PhoneNumber phoneNumber(String regex);
}
```
--
```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(String regex);
}
```
---
### regex is optional
```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(String regex);
}
```
--
```java
interface Mask {

  Mask ANY = phoneNumber -> true;

  boolean matches(PhoneNumber phoneNumber);
}
```
--
```java
class Regex implements Mask {

  private final Pattern regex;

  @Override
  public boolean matches(PhoneNumber phoneNumber) {
    return phoneNumber.matches(regex);
  }
}
```
--

```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(Mask mask);
}```

--
.corner[
```java
class PhoneNumber {
    boolean matches() {
        return regex.asPredicate().test(text());
    }
}
```
]

--
.corner[
```java
Pattern.compile(":")
  .splitAsStream("foobar:foo:bar")
  .filter(s -> s.contains("bar"))
  .sorted()
  .collect(Collectors.joining(":"));
```
]


---
```java
void ifPresent() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(new Regex(...));
  phoneNumber.ifPresent(paymentReminder::send);
}
```
--
```java
void orElse() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(new Regex(...))
      .orElse(PhoneNumber.USA_PRESIDENT);
}
```
--
```java
void orElseThrow() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(new Regex(...))
      .orElseThrow(() -> new MissingPhoneNumberException()
}
```
--
```java
void optionalIsAMonad() {
  phoneBook.phoneNumber(new Regex(...))
      .flatMap(no -> facebookProfile.byPhoneNumber(no))
      .flatMap(FacebookProfile::beloved)
      .ifPresent(Beloved::hijack);
}
```
???
You can build pipes w/o worrying about null checks.

---
```java
Outer outer = new Outer();
if (outer != null && outer.nested != null && outer.nested.inner != null) {
    System.out.println(outer.nested.inner.foo);
}
```
--
```java
Optional.of(new Outer())
    .flatMap(o -> Optional.ofNullable(o.nested))
    .flatMap(n -> Optional.ofNullable(n.inner))
    .flatMap(i -> Optional.ofNullable(i.foo))
    .ifPresent(System.out::println);
```

---
class: center, middle, invert
# General design principles

---
class: center, middle
# Maximizing reuse complicates use.
#### *— Kirk Knoernschild, [Java Application Architecture](https://www.amazon.com/Java-Application-Architecture-Modularity-Patterns/dp/0321247132)*
???
- Use/Reuse paradox: what is easy to use is often hard to reuse
- The ability to compose systems from reusable elements complicates the system.

---
class: center, middle
# Flexibility breeds complexity.
#### *— Kirk Knoernschild, [Java Application Architecture](https://www.amazon.com/Java-Application-Architecture-Modularity-Patterns/dp/0321247132)*
???
- implementation side of things

---
class: center, middle
# Fight temptation to write re-usable and flexible code upfront. Start with specific and direct code, and let reuse / flexibility points emerge from usage scenarios.
???
- Lean #4 principle (decide as late a possible - knowledge/time plot).
- YAGNI (XP principle)
- KISS (keep it simple and straightforward)

---
class: center, middle
# **Emergent design** depends on code that is **easy to change**.

---
class: center, middle
# Reuse increase coupling.
???
DRY has a side-effect.

---
class: center, middle
# Code must be kept at the same level of abstraction.
### (abstraction - trimming info on a subject to the absolute context relevant minimum)

---
```java
Map<int, Map<int, int>> portfoliosByTraderId;
if (portfolioIdsByTraderId.get(trader.getId())
 .containsKey(portfolio.getId())) {...}
```

--

```java
if (trader.canView(portfolio)) {...}
```

---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = applicationCheckFactory.make(when, application, countryCode);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```

---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
* def check = applicationCheckFactory.make(when, application, countryCode);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
* def check = makeCheck(application, when);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```
---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
* if (log.isDebugEnabled()) {
*   log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
* }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
* log(check); // logIfNeeded if conditional needs to be communicated
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```
---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persist(checkResult);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```

---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* if (shouldRunScorecard(application)) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```
---
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
*  return runScorecard && LoanAgreementType.MAIN.equals(application.agreementType());
}
```
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
*  return scoringEnabled && application.agreementType().equals(MAIN);
}
```
```groovy
private boolean shouldRunScorecard(LoanApplication application) { // inflexble
*  return scoringEnabled && application.isAgreementOfTypeMain()); // WTF is Type?
}
```
```groovy
private boolean shouldRunScorecard(LoanApplication application) { // flexible
*  return scoringEnabled && application.isAgreementOfType(MAIN)); // WTF anyway?
}
```
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
*  return scoringEnabled && agreement.isMain();
}
```
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
   boolean agreementIsApplicableForScoring =
        agreement.satisfies(new IsApplicableForScoring());
*  return scoringEnabled && agreementIsApplicableForScoring;
}
```

---
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* // smells like a missing application scoring concept
* if (shouldRunScorecard(application)) {
*    runScorecard(application, checkResult);
* }
  return checkResult;
}
```
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* def scoring = scoring(application);
* if (scoring.isNecessary()) { // NullObject can remove if, but should we?
*    scoring.score();
* }
  return checkResult;
}
```
---
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
  def scoring = scoring(application);
  if (scoring.isNecessary()) {
    scoring.score();
  }
  return checkResult;
}
```
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
}

public def scoreApplicationIfNecessary(LoanApplication application) {
  def scoring = scoring(application);
  if (scoring.isNecessary()) {
    scoring.score();
  }
}
```
```groovy
// making things more explicit...
// don't even consider extending LoanApplication
class ScorableLoanApplication {
    void score();
}
```

---
```java
public interface EShopService {
    Map<String, String> prepareNotificationParams(EShopSession session);
}
```
```java
public interface EShopNotificationParams {
    NotifationParams prepare(EShopSession session);
}
```
---
```java
public interface EShopService {
    Map<String, String> prepareNotificationParams(EShopSession session);
}
```
```java
public interface EShopNotificationParams {
    NotifationParams prepare(EShopSession session);
}
```
#### ----
```java
MultivaluedMap<String, String> formParams = new Form();
for (String key : params.keySet()) {
    formParams.add(key, params.get(key));
}
```
```java
Form form = new Form(new Params(params));
```

---
```java
public interface EShopService {
    Map<String, String> prepareNotificationParams(EShopSession session);
}
```
```java
public interface EShopNotificationParams {
    NotifationParams prepare(EShopSession session);
}
```
#### ----
```java
MultivaluedMap<String, String> formParams = new Form();
for (String key : params.keySet()) {
    formParams.add(key, params.get(key));
}
```
```java
Form form = new Form(new Params(params));
```
#### ----
```java
Map<String, Boolean> checkboxes = new HashMap<>();
```
```java
Collection<Checkbox> checkboxes = ...
```

---
```java
interface EquifaxFacade {
    public boolean validateAnswers(Map<String, String> questionToAnswerMap) {
      // we always get 4 questions from Equifax
      return MapUtils.isNotEmpty(questionToAnswerMap)
        && questionToAnswerMap.size() == 4;
    }
}
```
```java
class Answer {
    String questionId;
    String answerId;
}
```
```java
class UnvalidatedAnswers {

    private static final int ALWAYS_FIXED_NUMBER_OF_QUESTIONS = 4;
    private final Collection<Answer> answers;

    boolean areValid() {
        return answers.size() == ALWAYS_FIXED_NUMBER_OF_QUESTIONS;
    }
}
```
```java
  UnvalidatedAnswers unvalidatedAnswers = new UnvalidatedAnswers(answers);
  if (!unvalidatedAnswers.areValid()) {
    ....
  }
```
---
class: center, middle
# Reification - a process of making something concrete (implicit -> explicit).
???
- with lambdas, you can write short expressions easily. Often, you must reify them.

---
class: center, middle
# The Stepdown Rule
#### **The code should read like a top-down narrative. Start with high-level, abstract paragraphs. Then dive into details. — Clean Code**


---
class: center, middle
# Commenting code is like explaining a bad joke.

---
class: center, middle
# A common fallacy is to assume authors of incomprehensible code will somehow be able to express themselves lucidly and clearly in comments
— *Kevlin Henney*

---
class: center, middle
# What I like of comments is deleting them

---
class: center, middle
![](cat.jpg)

---
background-image:url(yaml.png)

---
```java
@Component
class NoOpAuthenticationHandler implements AuthenticationHandler {

	@Override
	public void delegate(ModelAndView model) {
*		// do nothing
	}

}
```

```java
@RequestMapping(value = "", method = { RequestMethod.GET, RequestMethod.POST })
public String index() {
* // RequestMethod.POST protects from 405 "Method not supported" for clients
* // logging in before JS is loaded
  return loginService.isLoggedIn() ? "redirect:/profile" : "index";
}
```
![](butwhy.png)

---
```java
@Transactional
public Client getClient() {
  Client client = repository.getRequired(Client.class, clientId);
* // lazy init
  client.getEntityUuid();
  return client;
}
```

```java
@Transactional
public <T> T applyToClient(Function<Client, T> fn) {
  Client client = repository.getRequired(Client.class, clientId);
  return client.apply(fn);
}
```

```java
void take() {
* // Base64 encoding is required by SauceLabs
  String base64Screenshot = webDriver.getScreenshotAs(OutputType.BASE64);
}
```

```java
private static final OutputType SAUCELABS_ENCODING = OutputType.BASE64;

void take() {
  String screenshot = webDriver.getScreenshotAs(SAUCELABS_ENCODING);
}
```

---
```java
// Disable "web-security", enable all possible "ssl-protocols" and
// "ignore-ssl-errors" for PhantomJSDriver
capabilities.setCapability(PhantomJSDriverService.PHANTOMJS_CLI_ARGS,
  new String[] {
    "--web-security=false",
    "--ssl-protocol=any",
    "--ignore-ssl-errors=true" });
```
--
```java
String disableWebSecurity = "--web-security=false";
String enableAllSslProtocols = "--ssl-protocol=any";
String ignoreSslErrors = "--ignore-ssl-errors";

String args = new String[] { disableWebSecurity, enableAllSslProtocols, ignoreSslErrors };
capabilities.setCapability(PHANTOMJS_CLI_ARGS, args);
```

---
```java
private void processMsgImages(File parentDir, EmailMessage emailMessage) {
* // find all img tag src's
  String body = emailMessage.getBody();
  Pattern p = Pattern.compile("<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>");
  Matcher m = p.matcher(body);
  List<String> imageSrcList = new ArrayList<String>();
  if (m.find()) {
    String src = m.group(1);
    imageSrcList.add(src);
  }

  for (String imgSrc : imageSrcList) {
		File imgFile = new File(parentDir, imgSrc);
		if (imgFile.exists()) {
			addEmbeddedField(emailMessage, imgFile);
			emailMessage.setBody(emailMessage.getBody().replace(imgSrc, "cid:" + imgFile.getName()));
		}
	}
}
```

```java
private void processMsgImages(File parentDir, EmailMessage emailMessage) {
* List<String> imageLinks = collectImageLinks(emailMessage);

  for (String imgSrc : imageSrcList) {
  File imgFile = new File(parentDir, imgSrc);
  if (imgFile.exists()) {
    addEmbeddedField(emailMessage, imgFile);
    emailMessage.setBody(emailMessage.getBody().replace(imgSrc, "cid:" + imgFile.getName()));
  }
  }
}
```

---
```java
*// function to configure for send to debts
*// possible to use overDueDays and paymentAmount
void sendToDebts() {
  if (overDueDays >= 4 && overDueDays <= 6) {
    doLoanSendToDebts()
  }

* // safeguard
  if (overDueDays >= 10 && overDueDays <= 13) {
    doLoanSendToDebts()
  }
}
```
![](butwhy.png)

---
```java
//
// Dear maintainer:
//
// Once you are done trying to 'optimize' this routine,
// and have realized what a terrible mistake that was,
// please increment the following counter as a warning
// to the next guy:
//
// total_hours_wasted_here = 16
//
```


---
### Express intent with code (meta-annotations are also code)
### No FIXMEs
### No TODOs
### No commented out code
### JavaDocs are made for public APIs. Within a team, express use-cases with tests.

---
### JSR-305
```java
@Nonnegative
```
--
```java
@OverridingMethodsMustInvokeSuper
```
--
```java
@WillClose
```
--
```java
@WillNotClose
```
--
```java
@GuardedBy
```
--
```java
@ThreadSafe
```
--
```java
@NotThreadSafe
```
--
```java
@Immutable
```

---
### Guava
```java
@VisibleForTesting
```
--
```java
@Beta
```
--
### Custom
```java
@Seconds
```
--
```java
@VisibleForHibernate
```
--
```java
@LegacyApproach("http://our.wiki/best-practices#34")
```
--
```java
@Spike("http://trello.com/b/0V4Fn8Gm/integration-poc")
```
---
# Is Guava still a thing?

--

### Ranges
.corner.long[
```java
Range.closed(1, 3).contains(2);

Range.lessThan(5).contains(5);
```
]

--

### Multimaps
.corner.long[
```java
Multimap<String, String> gadgets = ...

gadgets.put("iPhone", "5S");
gadgets.put("iPhone", "6S");
gadgets.put("LG", "Nexus");
```
]

--

### Immutable Collections
.corner.long[
```java
Collection<User> users() {
  return ImmutableList.copyOf(users);
}
```
]

--

### Ordering
.corner.long[
```java
Ordering<Person> ordering = Ordering
  .natural()
  .nullsFirst()
  .onResultOf(Person::middleName);
```
]

--

### ComparisonChain
.corner.long[
```java
public int compareTo(Foo that) {
  return ComparisonChain.start()
    .compare(this.a, that.a)
    .compare(this.b, that.b)
    .compare(this.c, that.c, Ordering.natural())
    .result();
```
]

--

### CaseFormat
.corner.long[
```java
CaseFormat.UPPER_UNDERSCORE
  .to(CaseFormat.LOWER_CAMEL, "CONSTANT_NAME"));
```
]
--

### Hashing - BloomFilter - EventBus - EqualsTester
???
Briefly, Bloom filters are a probabilistic DS, definitely NOT containing, but if yes - MAYBE


---
class: middle, center, invert
# SOLID
#### [SOLID principles](https://vimeo.com/60193259) — *Eduards Sizovs*

---
class: middle, center
# Singe Responsibility Principle
---
# How small the class should be?
### Size is just an indicator of bloaded responsibilities — *me*

--

### Mind-sized — *me*

--

### Small enough to lower coupling — *Marco Ceconni*
???
Marco Cecconi - Dev at StackOverflow

--

### Large enough to maximize cohesion — *Marco Ceconni*

--

### Small enough to be easy to understand, rewrite or replace  — *me*

--

### Inside every large program, there is a small program trying to get out — *Tony Hoare*
???
TH - Quicksort

---
### Can who spot 2 interwoven concepts?
```java
class FtpClient {

  void transferFile(String filename, InputStream input)

  boolean fileExists(String filename);

  void makeDir(String parentDir, String dir);

  boolean folderExists(String folder);

}
```

--
### Does 1 thing well - processing

```java
class Trade {
  void process() {
    // 1000 LOC
  }
}
```

--
### Generic naming leads to obesity - Helpers, Utils, Managers, Services...

---
class: middle, center
# Open-Closed Principle

---
```java
class NotificationService {

  private final SmsNotifer viaSms;

  private final EmailNotifier viaEmail;

  @Autowired
  public NotificationService(SmsNotifier viaSms, EmailNotifier viaEmail) {
    this.viaSms = viaSms;
    this.viaEmail = emaviaEmailil
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        viaSms.send(notification);
      }

      viaEmail.send(notification);
  }
}

class SmsNotifier {
    void send(Notification notification);
}

class EmailNotifier {
    void send(Notification notification);
}
```

---
```java
class EveryNotificationChannel {

  private final SmsNotificationChannel viaSms;

  private final EmailNotificationChannel viaEmail;

  @Autowired
  public EveryNotificationChannel(SmsNotificationChannel viaSms, EmailNotificationChannel viaEmail) {
    this.viaSms = viaSms;
    this.viaEmail = emaviaEmailil
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        viaSms.send(notification);
      }

      viaEmail.send(notification);
  }
}

class SmsNotificationChannel {
    void send(Notification notification);
}

class EmailNotificationChannel {
    void send(Notification notification);
}
```
???
omni - every from latin.

---
```java
class EveryNotificationChannel {

  private final SmsNotificationChannel viaSms;

  private final EmailNotificationChannel viaEmail;

  @Autowired
  public EveryNotificationChannel(SmsNotificationChannel viaSms, EmailNotificationChannel viaEmail) {
    this.viaSms = viaSms;
    this.viaEmail = emaviaEmailil
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        viaSms.send(notification);
      }

      viaEmail.send(notification);
  }
}

class SmsNotificationChannel implements NotificationChannel {
    void send(Notification notification);
}

class EmailNotificationChannel implements NotificationChannel {
    void send(Notification notification);
}

interface NotificationChannel {
    void send(Notification notification);
}
```

---

```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  @Autowired
  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
     if (notification.isNotTooLongForSms()) {
       viaSms.send(notification);
     }

      viaEmail.send(notification);
  }
}

interface NotificationChannel {
    void send(Notification notification);
}
```

---

```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  @Autowired
  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
     if (notification.isNotTooLongForSms()) {
       viaSms.send(notification);
     }

      viaEmail.send(notification);
  }
}

interface NotificationChannel {
    void send(Notification notification);
    boolean accepts(Notification notification);
}
```

--
```java
class SmsNotificationChannel implements NotificationChannel {
    boolean accepts(Notification notification) {
        return notification.isSatisifiesBy(new FitsIntoSms());
    }
}

class EmailNotificationChannel implements NotificationChannel {
    boolean accepts(Notification notification) { return ALWAYS; }
}
```

---
```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  @Autowired
  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
      notificationChannels.stream()
        .filter(channel -> channel.accepts(notification))
        .forEach(channel -> channel.send(notification));
  }
}
```

--

```java
class EveryNotificationChannel implements NotificationChannel {
  ...
}
```

---
class: center, middle
# Liskov Substitution Principle
???
indicators - instanceof checks, UnsupportedOperationException, funny restrictions (don't use this class if...)

---
background-image:url(toinstant.png)
???
java.sql.Date extends java.util.Date

---
.crap[
```java
class MapWithMandatoryValues implements Map<String, String> {
    @Override
    String get(Object key) {
        def value = map.get(key)
        if (!value) {
            throw new MissingParameter(key as String)
        }
        value
    }
}
```
]

--

```java
class TradeOrder {
  void cancel() {
    notifyRegulators();
  }
}
```

--
.crap[
```java
class SilentTradeOrder extends Trade {
  @Override
  void notifyRegulators() {
  }
}
```
]

---

```java
class Amount {
    private final BigDecimal origin;
    public Amount(BigDecimal origin) {
      Preconditions.checkArgument(origin.isPositive(), "Only positive amount is supported");
      this.origin = origin;
    }
}
```

--

```groovy
class AmountSpec extends Specification {
    def "does not support negative numbers"() {
      when:
        new Amount(-1.00)
      then:
         def e = thrown(IllegalArgumentException)
         e.message == "Only positive amount is supported"
    }
}
```

---

.crap[
```java
class Amount {
    BigDecimal origin;
    public Amount(BigDecimal origin) {
      Preconditions.checkArgument(origin.isPositive(), "Only positive amount is supported");
      this.origin = origin;
    }
    Amount() {

    }

}
```
]

--
.crap[
```java
class SignedAmount extends Amount {

    public SignedAmount(BigDecimal origin) {
      super();
      this.origin = origin;
    }
}
```
]


---
### Subclassing is evil because a subclass that breaks invariants may look completely logical in isolation.

--
### **Normalized hierarchy** is a hieararchy in which no class has more than one implementation of a method.

--
### Prefer composition over inheritance and, if not possible, stick to **NF**.
???
never reuse behaviour via inheritance.

---
class: center, middle
# The Interface Segregation Principle

---
class: center, middle
# Many client specific interfaces are better than one general purpose interface.
### — *Robert Martin, Agile Software Development*

---
# What's wrong with FAT interfaces?

--

### Suffer from low cohesion

--

### Suffer from high afferent/efferent coupling
???
afferent - in
efferent - out

--

### Make subclasses suffer from the same deseases

---
.crap[
```java
package shwitter.config;
interface ProductSettings {
    Attempts maxRegistrationAttempts();
    BonusAmount bonusAmount();
    Income minimalIncome();
    ...
}
```
]

--
.nice[
```java
package shwitter.registration;
interface RegistrationAttempts {
    Attempts max();
}
```
]

--

.nice[
```java
package shwitter.loyalty;
interface BonusAmount extends DecimalNumber {
}
```
]

--

.nice[
```java
package shwitter.lending.rules;
interface IncomeConstraints {
    Income minimal();
}
```
]

--

### Consider complexity of an implementor / test?
???
test double, decorator

--

### Impact of moving an interface?

---
```java
interface BacklogItem {
    Complexity complexity();
    void estimate(Duration duration);
}
```

--

### Murphy's Law hits the fan

--

.crap[
```java
class Forecast {
    private final BacklogItem backlogItem
    Duration duration() {
      Duration duration = forecast(backlogItem.complexity());
*     backlogItem.estimate(duration);
      return duration;
    }
}
```
]

--

```java
interface Forecastable {
  Complexity complexity();
}
```

--

```java
interface BacklogItem extends Forecastable {
    void estimate(Duration duration);
}
```

---
```java
interface BacklogItem {
    Complexity complexity();
    void estimate(Duration duration);
}
```

### Murphy's Law hits the fan

.nice[
```java
class Forecast {
    private final Forecastable forecastable;
    Duration duration() {
      Duration duration = forecast(forecastable.complexity());
*     backlogItem.estimate(duration); // compile error
      return duration;
    }
}
```
]

```java
interface Forecastable {
  Complexity complexity();
}
```

```java
interface BacklogItem extends Forecastable {
    void estimate(Duration duration);
}
```

---
class: center, middle
# Dependency Inversion Principle

---
class: center, middle
# High-level modules should not depend on low-level modules. Both should depend on abstractions.
### — *Robert Martin, Agile Software Development*
???
the goal is to increase reuse of a high-level modules.

---
```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

class ITextPdfDocument {

    private final Invoice invoice;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(invoice.stream(), canvas.stream());
    }
}
```

```java
package app.invoicing;

class Invoice {
    InputStream stream();
}
```


--
### **[infra.pdf]** is not reusable, because it depends on **[app.invoicing]**.

---
```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

class ITextPdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.stream(), canvas.stream());
    }
}
```

.l50[
```java
package app.invoicing;

class Invoice implements PdfSource {
    InputStream stream();
}
```
]
.r50[
```java
package app.invoicing;

interface PdfSource {
    InputStream stream();
}
```
]

### **[infra.pdf]** is still not reusable, but coupling decreased.

---
```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

class ITextPdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.stream(), canvas.stream());
    }
}
```

.l50[
```java
package app.invoicing;

class Invoice implements PdfSource {
    InputStream stream();
}
```
]
.r50[
```java
package infra.pdf;

interface PdfSource {
    InputStream stream();
}
```
]

### **[infra.pdf]** is now reusable, because of inverted dependency.

### Usage direction can be opposite to dependency direction.

---
### How to let **[app.invoicing]** plug any PDF implementation?

```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

interface PdfSource {
    InputStream stream();
}

class ITextPdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.stream(), canvas.stream());
    }
}
```

```java
package app.invoicing;

class Invoice implements PdfSource {
    InputStream stream();
}
```

---
### How to let **[app.invoicing]** plug any PDF implementation?

```java
package infra.pdf.api;

interface Canvas {
  OutputStream stream();
}

interface PdfSource {
    InputStream stream();
}

interface PdfDocument {
  void render(Canvas canvas);
}
```

```java
package infra.pdf.impl.itext;

class ITextPdfDocument implements PdfDocument {
    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = ...
    }
}
```

```java
package infra.pdf.impl.pdfbox;

class BoxPdfDocument implements PdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        PDFBox box = ...
    }
}
```

---
### But **[app.invoicing]** is instatiating concrete PdfDocument instance...
.crap[
```java
package app.invoicing;

@RestController
class InvoiceEndpoint {

  @GetMapping("/invoices/latest")
  void download(HttpServletResponse response) {
    Invoice invoice = invoices.latest();
*   PdfDocument document = new ITextPdfDocument(invoice); // or BoxPdfDocument
    Canvas canvas = new HttpOutCanvas(response);
    document.render(canvas);
  }
}
```
]

--

```java
package infra.pdf.api;

interface PdfDocumentFactory  {
    PdfDocument create(PdfSource source);
}
```

--

```java
package infra.pdf.impl.itext;

@Singleton
class ITextPdfDocumentFactory implements PdfDocumentFactory {

    public PdfDocument create(PdfSource source) {
        return new ITextPdfDocument(source);
    }
}
```

---
### Voila!
.nice[
```java
package app.invoicing;

@RestController
class InvoiceEndpoint {

  private final PdfDocumentFactory pdfDocumentFactory;

  @Autowired
  InvoiceEndpoint(PdfDocumentFactory pdfDocumentFactory) {
    this.pdfDocumentFactory = pdfDocumentFactory;
  }


  @GetMapping("/invoices/latest")
  void download(HttpServletResponse response) {
    Invoice invoice = invoices.latest();
*   PdfDocument document = pdfDocumentFactory.document(invoice);

    Canvas canvas = new HttpOutCanvas(response);
    document.render(canvas);
  }
}
```
]

---
### Consider **weight**
```java
package infra.pdf.impl.itext;
*@javax.inject.Singleton // javax.inject:javax.inject
class ITextPdfDocumentFactory implements PdfDocumentFactory {
    ...
}
```

### vs.

```java
package infra.pdf.impl.itext;
*@org.springframework.stereotype.Component // org.springframework:spring-context
class ITextPdfDocumentFactory implements PdfDocumentFactory {
    ...
}
```

---
background-image:url(repackage.png)

---
### Consider **granularity**
```groovy
configurations {
    compile.exclude module: "spring-boot-starter-tomcat"
}

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web:1.4.0.RELEASE")
    compile("org.springframework.boot:spring-boot-starter-jetty:1.4.0.RELEASE")
    // ...
}
```
???
but in general, Spring Boot is very fine grained.

---
class:libs
background-image:url(jetty.png)

---
background-image:url(aws.png)

---
# More on modularity
![](kirk.jpg)


---
class: nopadding
background-image:url(hibernate.png)
### .spanny[Hibernate Core v4.3.8.Final]
???
ok, you have nice physical modularity, but what about logical design?

---
class: nopadding
background-image:url(jdk7.png)
### .spanny[JDK v1.7.0_51]

---
class: nopadding
background-image:url(findbugs10.png)
### .spanny[Findbugs V1.0 - A great start]

---
class: nopadding
background-image:url(findbugs11.png)
### .spanny[Findbugs V1.1 – Imperfection creeps in]

---
class: nopadding
background-image:url(findbugs12.png)
### .spanny[Findbugs V1.2 – Imperfection takes hold]

---
class: nopadding
background-image:url(findbugs13.png)
### .spanny[Findbugs V1.3 – Chaos begins]

---
class: nopadding
background-image:url(findbugs14.png)
### .spanny[Findbugs V1.4 – Explosion]

---
class: nopadding
background-image:url(spring.png)
### .spanny[Spring v4.1.6]


---
class: right, middle
## **A JDK code base is deeply interconnected** at both the API and the implementation levels, having been built over many years primarily in the style of a monolithic software system. .fade[We’ve spent considerable effort eliminating or at least simplifying as many API and implementation dependences as possible, so that both the Platform and its implementations can be presented as a coherent set of interdependent modules, but some particularly thorny cases remain.]
### — *Mark Reinholds, Chief Architect of the Java Platform*


---
class: center, middle
## From assessing hundreds of software systems on three continents I know that about 90% of software systems are suffering from severe architectural erosion, i.e. there is not a lot of the original architectural structure left in them, and **coupling and dependencies are totally out of control**.
### — *Alexander von Zitzewitz*

---
# Hints
### Manage dependencies (Stan4j, Structure 101, VeriPacks)

--

### Avoid circular dependencies (merging, DI, demotion, escalation)

--
### Prefer smaller packages over large ones

--

### Provide slim interface and hide implementation details
???
@Component package-private.

--

### Group tightly-coupled classes together (Common Closure Principle)

--

### Reify! (e.g. String traderId vs TraderId traderId)


--

### [Architecting well-structured Java applications](https://www.youtube.com/watch?v=99VFdX1WS7o) — *Eduards Sizovs*

---
class:libs
background-image:url(layering_veripacks.png)

---
# VeriPacks Demo:
### 1.  **[application]** cannot be accessed by **[domain]** and **[infra]**

--

### 2. **[domain]** is accessible only by [**application**], never **[infra]**

--

### 3. **[infra.emailing]** **publishes** EmailProvider and Email interfaces. SmtpEmailProvider is only accessible by subpackages.

--

### 4. **[org.hibernate]** can only be used by **[infra.hibernate]**

---
# Application layer a-ka Service layer

--

### - defines a use case, what the system does

--

### - defines a use case contract (input / output)

--

### - defines transaction boundary

--

### - never ever to be confused with a domain service

---

.crap[
```java
interface MemberPermissionService {
  void grantPermission(String memberId, String permissionId);

  PermissionsDto listPermissions(String memberId);
}

@Transactional
class DefaultMemberPermissionServiceImpl implements MemberPermissionService {
  @Override
  public void grantPermission(String memberId, String permissionId) { ... }

  @Override
  public PermissionsDto listPermissions(String memberId) { ... }
}
```
]

--

### Tend to grow like hell

--

### No single entry point

--

### Always blocking

--

### Hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...

---

.nice[
```java
interface Command<R extends Command.Response> {
    interface Response {
    }
}
```
]

--

.nice[
```java
class Blank implements Command.Response {
}
```
]

--

```java
interface CommandHandler<C extends Command<R>, R extends Command.Response> {
    R handle(C $);
}
```

--

```java
interface Now {
    <C extends Command<R>, R extends Command.Response> R execute(C command);
}
```
???
finds and executes appropriate impl for a command using generics

--

```java
interface Future {
    <C extends Command<R>, R ...> CompletableFuture<R> schedule(C command);
}```

--

```java
interface Rx {
    <C extends Command<R>, R ...> Observable<R> observe(C command);
}
```

--
```java
interface Durable {
    <C extends Command> void enqueue(C command);
}
```

---
.nice[
```java
public class GrantPermissionCommand implements Command<Blank> {

    private final String memberId, permissionId;

    public GrantPermissionCommand(String memberId, String permissionId) { ... }

    public String memberId() {
        return memberId;
    }

    public String permissionId() {
        return permissionId;
    }
}
```
]

--
.nice[
```java
class GrantPermissionCommandHandler implements CommandHandler<GrantPermissionCommand, Blank> {

    private final Members members;
    private final Permissions permissions;

    @Autowired
    public GrantPermissionCommandHandler(Permissions permissions, Members members) { ... }

    @Override
    public Blank handle(GrantPermissionCommand $) {
        MemberId memberId = new MemberId($.memberId());
        Member member = members.byId(memberId);

        PermissionId permissionId = new PermissionId($.permissionId());
        Permission permission = permissions.byId(permissionId);

        member.grantPermission(permission);
        return new Blank();
    }
}
```
]

---
```java
@RestController
class GrantPermissionEndpoint {

    @Autowired
    Now now;

    @Autowired
    Future future;

    @Autowired
    Rx rx;

    @Autowired
    Durable durable;

    @PostMapping("/users/$userId/permissions")
    void accept(
      @PathVariable String userId,
      @RequestBody GrantPermissionCommand grantPermissionCommand) {

        Blank blank = now.execute(grantPermissionCommand);

        future.schedule(grantPermissionCommand)
          .thenAccept(response -> System.out.println("Completed!"));

        rx.observe(grantPermissionCommand)
          .subscribe(blank -> System.out.println("Completed!"));

        durable.enqueue(grantPermissionCommand);
    }

}
```

---
```java
public interface Command<R extends Command.Response> {

    interface Response {
    }

    default R execute(Now now) {
        return now.execute(this);
    }

    default CompletableFuture<R> schedule(Future future) {
        return future.schedule(this);
    }

    default Observable<R> observe(Rx rx) {
        return rx.observe(this);
    }

    default void enqueue(Durable durable) {
        durable.enqueue(this);
    }
}
```

--
```java
void seeTheDifference() {
  GrantPermissionCommand grantPermissionCommand =
      new GrantPermissionCommand("memberId", "permissionId")

  grantPermissionCommand.execute(now);

  grantPermissionCommand.schedule(future)

  ...
}

```

---
```java
class RetryCommand<R extends Command.Response> implements Command<R> {

    private final Command<R> origin;

    private Optional<Duration> timeout = Optional.empty();

    public RetryCommand(Command<R> origin) {
        this.origin = origin;
    }

    public Command<R> origin() {
        return origin;
    }


    public RetryCommand<R> timeoutAfter(Duration duration) {
        this.timeout = Optional.of(duration);
        return this;
    }

    public Optional<Duration> timeout() {
        return timeout;
    }
}
```

---
```java
class RetryCommandHandler<R extends Command.Response> implements CommandHandler<RetryCommand<R>, R> {

    private static final Duration DEFAULT_TIMEOUT = Duration.ofSeconds(30);

    @Override
    public R handle(RetryCommand<R> $) {

        TimeoutRetryPolicy policy = new TimeoutRetryPolicy();

        Duration timeout = $.timeout().orElse(DEFAULT_TIMEOUT);
        policy.setTimeout(timeout.toMillis());

        RetryTemplate template = new RetryTemplate();
        template.setRetryPolicy(policy);

        return template.execute(context -> {
            Command<R> origin = $.origin();
            CommandHandler<Command<R>, R> originHandler = findHandlerFor(origin);
            return originHandler.handle(origin);
        });
    }
}
```

--

```java
GrantPermissionCommand grantPermissionCommand = new GrantPermission...
new RetryCommand<>(grantPermissionCommand)
        .timeoutAfter(Duration.ofSeconds(5))
        .execute(now);
```

---

### .strike[Tend to grow like hell]

--


### .strike[No single entry point]
???
can make all commands transactional

--

### .strike[Always blocking]

--

### .strike[Hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...]

---
can be prototype! and use power of setting state in constructor, avoid threadlocals.
instead of returning a set of validation errors, throw them!
calling commands from commands indicates a problem of reuse and are DANGEROUS. Change in UC1 can break UC2. Let them evolve independently!

---

```java
package infra.authentication;
class Anonym {
  private final Members members;
  Optional<Token> authenticationToken(String username, String password) {
    Optional<Member> member = members.byLoginAndPassword(username, password);
    return member.flatMap(() -> new JwtToken(username));
  }
}
```
--

```java
package app.membership;

class LogInCommandHandler implements CommandHandler<LogInCommand, LogInCommand.R> {
  @Autowired
  private final Anonym anonym;
  public R handle(LogInCommand $) {
    Token authToken = anonym
      .authenticationToken($.username(), $.password())
      .orElseThrow(() -> throw new InvalidCredentialsException($));

    return new R(authToken.text());
  }
}
```

--

```java
package app.membership;
interface Members {
  Member byLoginAndPassword(username, password);
}
```

--

.corner[
  ### - Bidi usage
  ### - Bidi dependency :(
  ### - Let's make Anonym reusable
]

---

```java
package infra.authentication;
class Anonym {
  private final Credentials credentials;
  Optional<Token> authenticationToken(String username, String password) {
    boolean validCredentials = credentials.areValid(username, password);
    return validCredentials ? Optional.of(new JwtToken(username)) : Optional.empty();
  }
}
```

```java
package infra.authentication;
interface Credentials {
  boolean areValid(String username, String password);
}
```

--

```java
package app.membership;
class MemberCredentials implements Credentials {
  private final Members members;
  @Override
  public boolean areValid(String username, String password) {
    members
      .byLoginAndPassword(username, password);
      .isPresent();
  }
}
```

--

.corner[
  ### - Bi-di usage
  ### - Uni-di dependency
  ### - Anonym is reusable now!
]

---
```java
javajitsu.infrastructure.sms
javajitsu.infrastructure.sms.twilio
javajitsu.application.notification
javajitsu.domain.notification
```

---
- We can add behaviour with decorators (open-closed)

---
# Working with legacy code
### Chia Pet Pattern
### Most development is about preserving behaviour
### Refactoring dilemma


---
### Fighting feature ENVY:
entity.apply(fn)
entity.satisfies()

---
- Adjacent parameter of the same type, if practical, if possible, should be avoided. (c) Scott Meyers
- It is possible to call them in the wrong order.
Date, Month, Day, Year. also more readable.

---
Don't be afraid of creating types.
- CustomerName
- FileName

---
Database is a detail. It's one of the way of representing your entity. Fine.

---
Bundle advanced functionality into separate objects. Functionality is hidden unless such objects are requested. (c) Scott Meyers
Instead of given all stuff, you have to ask for them.

---
Intent. Why intent? RestEndPoint.receive(ACOmmand command). If Rest endpoint is just a translation layer, then, if each command is a use case, we can easily express it in terms of BDD. What the system DOES.
commands can be combined. Throttled. Whatever.
Exception handling
Transaciton management.
Single funcking entry point
command is INTENT. Logs :-)
* What the system is (domain) vs. what the system does (use cases). Commands / Domain
Exhanging messages w/o calling each other. EvenBus!

---
“Behaviour-driven development is about
implementing an application by
describing it from the point of view of
its stakeholders” (c) Dan North


---
```
class Person {

    private final Age age;

    private final Sex sex;

    public Person(Age age, Sex sex) {
        this.age = age;
        this.sex = sex;
    }

    public Age age() {
        return age;
    }

    public Sex sex() {
        return sex;
    }
}

class Age {

    private final int age;

    public Age(int age) {
        this.age = age;
    }

    boolean isMajor() {
        return age > 18;
    }

    @Override
    public int compareTo(Age that) {
        // Guava in use!
        return Ints.compare(this.age, that.age);
    }

    @Override
    public int hashCode() {
        return Objects.hash(age);
    }

    @Override
    public boolean equals(@Nullable Object that) {
        if (that == null || getClass() != that.getClass()) {
            return false;
        }
        Age other = (Age) that;
        return Objects.equals(this.age, other.age);
    }
    guava-testlib

}

```
    Challenge: write equality w/o if conditions
    @Override
    public boolean equals(@Nullable Object that) {
        return new Equality<>(Age::age, Age::isMajor).equals(this, that);
    }

```
---
```
new EqualsTester()
    .addEqualityGroup("hello", "h" + "ello")
    .addEqualityGroup("world", "wor" + "ld")
    .addEqualityGroup(2, 1 + 1)
    .testEquals();
```
---

```
class Equality<T> {

    private final Collection<BiFunction<T, T, Boolean>> checks = new LinkedList<>();

    @SafeVarargs
    public Equality(Property<T, ?>... properties) {
        checks.add((me, you) -> you != null);
        checks.add((me, you) -> me.getClass() == you.getClass());
        checks.addAll(Arrays
                .stream(properties)
                .map(property -> (BiFunction<T, T, Boolean>) (T me, T you) -> Objects.equals(property.take(me), property.take(you)))
                .collect(Collectors.toList()));
    }


    boolean equals(Object me, @Nullable Object you) {
        return checks.stream().allMatch(fn -> fn.apply((T) me, (T) you));
    }
}
}
```


enum Sex {
    MALE, FEMALE
}
```
---
```
        Collection<Person> people = new ArrayList<>();
        List<Person> adultMales = people.stream().filter(new AdultMale()).collect(Collectors.toList());
```

---

---
```
interface Entity<T> {

    default boolean is(Predicate<T> predicate) {
        return predicate.test((T) this);
    }

}

class Person implements Entity<Person>
....

Age adultAge = new Age(18);
Person citizen = new Person(adultAge, Sex.MALE);
boolean adultMale = citizen.isSatisfiedBy(new IsAdultMale());
```
???
Entity is an interface! Wohoo!

---
SOLID (open/closed principle)
- Tempting to sublclass. We never subclass (almost.)
- DECORATORS! Hmm, also, with Decorators you can avoid making objects Configurable, A-ka SomeSettings.
The expression problem
The expression problem refers to the desire to implement an existing set of abstract methods for an existing concrete class without having to change the code that defines either. Object-oriented languages allow you to implement an existing abstract method in a concrete class you control (interface inheritance), but if the concrete class is outside your control, the options for making it implement new or existing abstract methods tend to be sparse. Many popular programming languages such as Ruby, Scala, C#, Groovy, and JavaScript provide partial solutions to this problem by allowing you to add methods to an existing concrete object, a feature sometimes known as monkey-patching, or interpose a different object between mismatched types via implicit conversion.


---
Encapsulated properties must not be used to change the behavior of an object.
for example - Password.



---
Rule of demeter / principle of least knowledge / don't talk to strangers / train wrecks

---
Jackson
- Jackson Guava (https://github.com/FasterXML/jackson-datatypes-collections) -> Multimap, Range, HashCode, InternetDomainName, HostAndPort, Optional
- Jackson JDK8 (https://github.com/FasterXML/jackson-datatype-jdk8) -> Optional
- Jackson JSR310 (https://github.com/FasterXML/jackson-datatype-jsr310) -> javax.date
- Jackson Parameter Names module (https://github.com/FasterXML/jackson-module-parameter-names) ->

---
```
class Person {     // mandatory fields     private final String name;     private final String surname;     // optional fields     private String nickname;     // no annotations are required if preconditions are met (details below)     public Person(String name, String surname) {
```

---
Afterburner
```
<dependency>
  <groupId>com.fasterxml.jackson.module</groupId>
  <artifactId>jackson-module-afterburner</artifactId>
  <version>2.7.1</version>
</dependency>
```

```
ObjectMapper mapper = new ObjectMapper()
mapper.registerModule(new AfterburnerModule());
```

---
# Frameworks
- awaitility
- hicariCP -  the fastest connection pool in Java land
- caffeine - the fastes near-cache in Java land. Can be used as Spring Cache in Spring 4.3

---
LoadingCache<String, Book> booksByTitle = Caffeine.newBuilder()
    .maximumSize(10_000)
    .expireAfterAccess(5, TimeUnit.MINUTES)
    .refreshAfterWrite(1, TimeUnit.MINUTES)
    .build(title -> { // Using a jOOQ repository
      return database.selectFrom(BOOK)
          .where(BOOK.TITLE.eq(title))
          .fetchOneInto(Book.class);
    });

// A classic about a prison revolt (TANSTAAFL!)
Book favorite = booksByTitle.get(“The Moon Is a Harsh Mistress”);

// A good way to spend a long, rainy weekend
Map<String, Book> series = booksByTitle.getAll(Arrays.asList(
  “A Game of Thrones”, “A Clash of Kings”, ...));

---
Stability Patterns
- Retries

---
I like comments! What I like of comments is deleting them
- make implicit explicit
- method names instead of comments
- comments explain each code block :( methods!
- exceptions - performance implications, regexes.
- todo: use paper.
- QCs :-) version control is for that.
- kill commented out code. That's what VC is for.
- javadocs

---
Exception handling
throw new Exception("o_O")
Validation may be a differnet kind of exception.

---
background-image:url(prodex.jpg)

---
- JSR validation is not designed for domain validation / business rules. Only input.
- Business stuff depends on INPUT being correct, not NULLS etc. So it comes first.
- Input validation is (normally) connected to a FIELD. Business - not composition of stuff.

---
class: center, middle, invert
# Logging

---
# Slf4j please.
### - Bridges for all common logging frameworks
### - Single dependency on `slf4-api`

---
# Logback please.
### - Native, zero-overhead implementation of Slf4j
### - Supports configuration via flexible Groovy DSL
### - Supports asynchonous logging via AsyncAppender
### - Supports {} to variables to avoid concatenation
### - log.isDebugEnabled() check is [almost] obsolete.
???
- Groovy can access your classpath. So you can do type-safe stuff.
- Consider log4j 2 - faster async via disruptor, custom log levels, custom formatters, lazy args.
- Lambda support in Slf4j is planned in the next release - 1.8.

---
# MDC (Mapped Diagnostic Context)
```java
MDC.put("userId", new LoggedUserId(user));
// userId is available to logger
MDC.remove("userId");
```
```java
MDC.MDCCloseable handle = MDC.putCloseable("userId", new LoggedUserId(user));
// userId is available to logger
handle.close();
```

```groovy
import ch.qos.logback.classic.encoder.PatternLayoutEncoder
import ch.qos.logback.core.ConsoleAppender
appender("STDOUT", ConsoleAppender) {
    encoder(PatternLayoutEncoder) {
      pattern = "[%thread] %mdc{userId:-UNKNOWN} - %msg%n"
    }
}
root DEBUG, ["STDOUT"]
```
???
- so you don't have to pass userId every time you log the message.
- every log message will contain a userId information.
- *putCloseable** is awkward. MDCItem.remove();

---
# Markers
```java
class Tx {

  static Marker CHATOPS = MarkerManager.getMarker("CHATOPS");

  void execute() {
    log.error(CHATOPS, "Oh sh%t, transaction failed", new Tx.Failed(cause));
  }
}
```
```groovy
appender("DEFAULT", ConsoleAppender) {
    encoder(PatternLayoutEncoder) {
        pattern = "%m%n"
    }
}
appender("CHATOPS", SlackAppender) {
    channel = "chatops"
    filter(EvaluatorFilter) {
        evaluator(OnMarkerEvaluator) { marker = "CHATOPS" }
        onMatch = "ACCEPT"
    }
}

root DEBUG, ["DEFAULT", "CHATOPS"]
```
???
- you also filter-out messages for a given marker (e.g. commands that do not need to be logged)

---
background-image:url(12factor.jpg)
???
- Software must write to sysout
- Fluentd

---
# Make implicit explicit
```java
class Command {

    String firstName;
    String lastName;

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("firstName", firstName)
                .add("lastName", lastName)
                .toString();
    }
}

log.info("Command received", new Command("Chuck", "Norris"));
```

---
# Make implicit explicit
```java
class Command implements Loggable {

    String firstName;
    String lastName;

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("firstName", firstName)
                .add("lastName", lastName)
                .toString();
    }

    @Override
    public String toLogString() {
      return Joiner.on(' ').join(firstName, lastName);
    }
}

log.info("Command received", new Command("Chuck", "Norris").toLogString());
```

---
# Log or rethrow. Never do both.
```java
  class Mailgun {
      void send(Email email) {
        try {
            // try to send email...
        } catch(IOException e) {
*           log.error("Mailgun is unavailable", e);
            throw new MailgunUnavailable("Mailgun is unavailable", e);
        }
      }
  }

  class SubscriptionReminder {
      Mailgun mailgun;
      void remind() {
          Email email = new Email(...);
          try {
            mailgun.send(email);
          } catch (MailgunUnavailable e) {
            log(e);
            reschedule();
          }
      }
  }
```
???
- MESS in log files. Same shit many times.
- VERY common and hard to make right.
- preserve exception cause hierarchy.

---
# Log or rethrow. Never do both.
```java
  class Mailgun {
      void send(Email email) {
        try {
            // try to send email...
        } catch(IOException e) {
            throw new MailgunUnavailable("Mailgun is unavailable", e);
        }
      }
  }

  class SubscriptionReminder {
      Mailgun mailgun;
      void remind() {
          Email email = new Email(...);
          try {
            mailgun.send(email);
          } catch (MailgunUnavailable e) {
            log(e);
            reschedule();
          }
      }
  }
```
???
- Hei, fucking handle me, calle!
- This why the idea of CHECKED exception is not THAT bad :-)
- log(e) and reschedule() level of abstraction!!!

---
# Use color-coding and indentation
```groovy
pattern = "%highlight(%-6(%level)) | %+20(%logger{20}) | %thread | %cyan(%mdc{tx}) | %m%n"
```
![](color-code.png)

---
```java
class Vault {

    private final Logger log;
    private final String accessToken;

    public Vault(String accessToken) {
        this(accessToken, LoggerFactory.getLogger(Vault.class));
    }

    @VisibleForTesting
    Vault(String accessToken, Logger log) {
        this.accessToken = accessToken;
        this.log = log;
    }

}

class VaultSpec {

    Logger logger = Mock(Logger.class);
    Vault vault = new Vault("someToken", logger);

    void doesSomeBlackMagic() {
        // ...
    }

}
```

---
```java
 @Rule
 public LogbackVerifier logbackVerifier = new LogbackVerifier();

    private MyTestedService service = new MyTestedService();

    @Test
    public void verifyGoodScenario() throws Exception {
        logbackVerifier.expectMessage(Level.INFO, "it worked");
    }
```

---
```java
public class LogbackVerifier implements TestRule {

    private Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    private Appender<ILoggingEvent> appender = ... // your Appender impl.

    @Override
    public Statement apply(final Statement base, Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                before();
                try {
                    base.evaluate();
                    verify();
                } finally {
                    after();
                }
            }
        };
    }

    private void before() {
        rootLogger.addAppender(appender);
    }

    private void after() {
        rootLogger.detachAppender(appender);
    }

    private void verify() { ... }

    public void expectMessage(Level level, String message) { ... }

}
```

---
### Case against Spring Data
### Case against JPA
### Go Hibernate or JDBC (or some better wrapper, like [Fluent JDBC](http://jdbc.jcabi.com/), [JDBI](http://www.jdbi.org/), [JdbcTemplate](https://docs.spring.io/spring/docs/2.0.x/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html))

```
jDBI provides a convenience interface for SQL operations in Java. **It is not intended as an abstraction layer, but rather a library** which makes the common things easy and the hard things possible, to paraphrase Larry Wall.
```

### no save();
### Redis no save() with IMMEDIATE changes, so RedisQuestionCount implements QuestionCount


---
background-image:url(javaslang.png)

---
```java
Arrays.asList(2, 3, 1)
  .stream()
  .sorted()
  .collect(Collectors.toList());
```

--

```java
List.of(2, 3, 1).sort();
```

--
```java
Try.of(() -> bunchOfWork()).getOrElse(other);
```

--
```java
String s = Match(i).of(
    Case(is(1), "one"),
    Case(is(2), "two"),
    Case($(), "?")
);
```

--
### Be careful, doesn't seem the right place for circuit breaking!
http://www.javaslang.io/javaslang-circuitbreaker/0.5.0/

---
background-image:url(immutables.png)

---
```java
import org.immutables.value.Value;

@Value.Immutable
public interface ValueObject {
  String name();
  List<Integer> counts();
  Optional<String> description();
}
```

--

```java
ValueObject valueObject =
    ImmutableValueObject.builder()
        .name("My value")
        .addCounts(1)
        .addCounts(2)
        .build();
```

--

```java
ValueObject newImmutable = valueObject.withName("New");
```

---
### More
- [curated list of great IT videos](https://github.com/latcraft/what2watch)
- [my goodreads](https://goodreads.com/eduardsi)

---
DevTernity


----

    </textarea>
    <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        slideNumberFormat: function (current, total) { return "" }
      });
      slideshow.on('afterShowSlide', function (slide) {

        var axs =  {
                  title: 'thoughput / responsiveness over time.',
                  xaxis: {
                    title: 'time (months)'
                  },
                  yaxis: {
                    title: 'throughput / responsiveness (RTF / sprint)'
                  }
                }

        var thr = [
                {
                  x: [2, 10, 14, 24, 40],
                  y: [30, 29, 28, 23, 10],
                  name: 'continuous degradation',
                  mode: 'lines',
                  line: {
                      color: 'rgb(219, 64, 82)',
                      width: 3
                    }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30, 30, 30, 30],
                  name: 'sustainable pace',
                  mode: 'lines',
                  line: {
                      color: 'rgb(169, 169, 169)'
                  }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30.5, 31, 31.5, 32],
                  name: 'continuous improvement',
                  mode: 'lines'
                },
          ];

          var dbt = thr.concat({
                  x: [28, 28],
                  y: [30, 20],
                  name: 'technical debt',
                  mode: 'lines',
                  line: {
                    dash: 'dot'
                  }
                } );

        if (slide.properties.name == "throughput") {
          Plotly.newPlot('throughput', thr, axs);
        }
        if (slide.properties.name == "debt") {
          Plotly.newPlot('debt', dbt, axs);
        }
      });

    var ktx = document.getElementsByClassName("ktx");
    for(var i = 0; i < ktx.length; i++) {
       katex.render(ktx.item(i).getAttribute('expr'), ktx.item(i));
      }
    </script>

  </body>
</html>
