<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }

      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Effective Coding Principles and Patterns in Java 8

---
class: center, middle
# Welcome.
???
Introduce myself and let others introduce themselves.
Setting expectations:
- Not Java 8 course.
- Learn principles, practices and patterns for writing readable, maintainable and effective code - CLEAN CODE. In modern Java.
- My goal is to make you feel that he rules will tell you to do things that are really weird or NOT to do something that you did. Be open minded.
- **HOMEWORK**

---
class: center, middle, invert
# Java 8 additions in 4 slides
---
###**java.time** (Clock, Instant, LocalDate, TemporalAdjuster)
???
No Joda anymore.
--

###**streams** (collections, arrays, chars, files etc.)

--

###**lambdas**

--

###**@FunctionalInterface** (Function, Predicate, Consumer, Supplier)

--

###**method references** (Class::new, instance::method)

--

###**default methods**

--

###**java.lang.reflect.Parameter** (--parameters compiler argument)

--

### **PermGen** replaced with out-of-heap **Metaspace**

---
### **implicit conversion**

--

```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
--
```java
Converter<String, Integer> converter = Integer::valueOf;
```
--
```java
class Person {

    private final String firstName, lastName;

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```
--
```java
interface PersonFactory {
    Person create(String firstName, String lastName);
}
```
--
```java
PersonFactory personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");
```

---
### **checked exception in lambdas**
.crap[
```java
Arrays.stream(dir.listFiles())
        .map(file -> {
            try {
                return file.getCanonicalPath();
            } catch (IOException e) {
                throw new RuntimeException(e);

            }
        })
        .forEach(System.out::println);
```
]
---

.nice[
```java
Arrays.stream(dir.listFiles())
        .map(Unchecked.function(File::getCanonicalPath))
        .forEach(System.out::println);
```
]

--

.nice[
```java
class Unchecked {
  public static <T, R> Function<T, R> function(CheckedFunction<T, R> function) {
    return t -> {
        try {
            return function.apply(t);
        }
        catch (Throwable e) {
          if (e instanceof Error) {
              throw (Error) e;
          }
          if (e instanceof RuntimeException) {
              throw (RuntimeException) e;
          }
          throw new RuntimeException(e);
        }
    };
  }

}
```
]

--

.nice[
```java
@FunctionalInterface
public interface CheckedFunction<T, R> {
    R apply(T t) throws Throwable;
}
```
]

---
class: center, middle, invert
# The economics of software design 101
???
Before HOW -> WHY

---
class: center, middle
# There is a strong correlation between quality of the codebase and developer productivity or **throughput**.
## (c) me
???
- The higher is quality, the higher is productivity. And vice versa.
- Everyone agrees?!
- Productivity - TIME we spend per CHANGE.

---
class: middle
# <span class="ktx" expr="Throughput = \dfrac{RTF}{TIME}"></span>
#### *RTF - Released Tested Features (c) [The Economics of Software Design](https://www.youtube.com/watch?v=7HecgbghFTk), J.B. Rainsberger *
???

---
class: center, middle
# Higher throughput = lower **cost per change**.
#### <span class="ktx" expr="cost\,per\,change = time\,spent\,on\,change\,\times salary"></span>

---
class: center, middle
# Why do these guys move so slow?!
???
Low throughput

---
class: center, middle
# Why are these guys so expensive?!
???
High CPC (low throghput; too low for given salary!!!)


---
class: center, middle
# By writing clean code, you enable **stable throughput / responsiveness over time**.
### (the time that is usually longer than your employment)
???
- The goal of design is to be able to ship as fast as we can now not only in the next 3 months, but in years etc.
- Unfortunately, we do not usually know see long-term consequences of our work, but we should.
- For example, my best friend is now maintaining a software that I wrote 6 years ago :-)


---
name: throughput
<div id="throughput" style="width: 100%; height: 100%;"></div>
???
- team is slow and becomes a bottleneck to make world a better place :-) New teams, rewrites etc.
- a nice thing about sustainable pace that I can estimate.
- Do you know the rule that makes throughput gradually grow? BS rule. That's how we escale from SHIT.
- Can someone explain why throughput drops that fast?

---
#  Reinforcing loops:
### low throughput -> pressure -> more corners cut -> lower throghput
### low throughput -> unmet deadlines -> more people to work on features -> lower throughput (Brook's Law)
### low quality tolerated -> lower quality (Broken window theory)
### low quality tolerated -> lower quality -> tolerated -> even bigger decline in quality -> ... (Drift to Low Performace)
### Graham's Law
???
- BWT - if there is mess, or rush, you don't be the first to make a mess.
- Graham's law - Shitty component remain a part of the system over time precisely because it's hard to take out. Conversely, a component that is easy to replace is one that we may replace.

---
![](donella.png)

---
name: debt
<div id="debt" style="width: 100%; height: 100%;"></div>
???
- TD - cumulative consequences of corners being cut.
- In this example, we pay TD in terms of throughput.

---
class: center, middle
# ?
???
- raise your hand who thinks technical debt is a bad thing?
- who thinks it's a good thing?
- is taking a loan a bad thing?
- is taking and loan and not returning it back for a long time - a bad thing?

---
class: center, middle
# Technical debt is a **tool** for gaining a **short-term** gain. **Causes addiction** and needs to be **managed**.
???
- Spike and Throwaway! (Dan North). E.g. TDDing at this level is kinda waste.
- Meeting deadline (critical problem, black swan events -> unexpected prospect)

---
class: conversation
### **Manager**: When will the new permission be done?
### **Dev**: Mmmm, I hope tomorrow, in the end of the day.
### **Manager**: We need it today. Can’t you find a “creative” way to do it?
### **Dev**: Let me think…
### **Manager**: We have 5 clients that really need this today. Else they will probably not sign the contract.
### **Dev**: But the…
### **Manager**: Look, it’s important that you understand the business value of it. Isn’t it just a new condition in the code? Just put it there, and we’ll “fix it” later.
### **Dev**: Ok.
### **Manager**: So we’ll be able to deploy today?
### **Dev**: Aham.
#### *— [Technical Debt 101](https://medium.com/@joaomilho/festina-lente-e29070811b84#.7d8asvofr)*

---
class: bottom, right
background-image:url(techDebtQuadrant.png)
#### *Technical debt quadrant: http://martinfowler.com/bliki/TechnicalDebtQuadrant.html*
???
- reckless - we focus on completing tasks fast instead of building HQ system. Boil like frogs.
- It's often the case that it can take a year of programming on a project before you understand what the best design approach should have be.

---
class: center, middle, bad
# The only way to go fast is to go well.
### (c) Uncle Bob
???
really?

---
class: center, middle, oki
# The only way to go fast [in a long run] is to go well.
### (c) Uncle Bob (edited)

---
class: center, middle
# Does writing clean code take more time than writing crap?
???
- takes time -> lower throghput -> higher cost per change. -> quality is expensive

---
class: center, middle
# Reading vs. writing ratio is 10:1.
???
we want reading to be easy if it makes writing harder. Making code easy to read, makes it easier to write.

---
class: center, middle
# There are people who write clean code blazingly fast.
???
I saw master at work. You can be that master. Skill acquisition graph (performance over time)

---
class: center, middle
# If something is not worth our time, consider not doing it.
![](stepsofmastery.png)
???
- Avoiding it - nice! less INHERENT COMPLEXITY. less code to maintain.
- Agile Manifesto principle. Simplicity — the art of maximizing the amount of work not done.
- First law of software quality: e = mc^2 ; errors = (more code)^2

---
class: center, middle
# It only takes one crappy class to harm your reputation.
???


---
class: center, middle
## If you think someone is an asshole, most people who are silently observing the situation think so, too.
#### *— Guy’s Theory of Perfect Knowledge of Assholes*

---
background-image:url(SonarQube-02.png)
background-size: 100%
???
- not used
- running on every push
- before every push (https://hub.docker.com/_/sonarqube)
- running on every code change

---
class: lint
background-image:url(sonarlint.png)
background-size: 100%

---
class: center, middle, invert
# Naming

---
### Astonishing / non-intention revealing Twilio API
```java
import com.twilio.sdk.TwilioRestClient;
import com.twilio.sdk.TwilioRestException;
import com.twilio.sdk.resource.factory.MessageFactory;
import com.twilio.sdk.resource.instance.Message;
import org.apache.http.NameValuePair;
import org.apache.http.message.BasicNameValuePair;

public class Example {

  // Find your Account Sid and Token at twilio.com/console
  public static final String ACCOUNT_SID = "{{ account_sid }}";
  public static final String AUTH_TOKEN = "{{ auth_token }}";

  public static void main(String[] args) throws TwilioRestException {
    TwilioRestClient client = new TwilioRestClient(ACCOUNT_SID, AUTH_TOKEN);

    // Build a filter for the MessageList
    List<NameValuePair> params = new ArrayList<NameValuePair>();
    params.add(new BasicNameValuePair("Body", "Hello from Java"));
    params.add(new BasicNameValuePair("To", "+12345678901"));
    params.add(new BasicNameValuePair("From", "+12345678901"));

    MessageFactory messageFactory = client.getAccount().getMessageFactory();
*   // this guy actually sends a message. Violates Least Astonishment Principle
*   Message message = messageFactory.create(params);
  }
}
```
???
The code is not HONEST.

---
.crap[
```java
void update(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
}
```
]

--

.nice[
```java
void update(Entity entity) {
  checkArgument(entity.isIdAssigned(), "Cannot update entity. Id is missing");
  ...
}
```
]

--

```java
void updateIfIdAssigned(Entity entity) {
  if (!entity.isIdAssigned()) {
    return;
  }
  ...
}
```
---
### Take scope into account
```java
interface Employee {
  String employeeAddress();
}

interface Employee {
  String address();
}
```

--

```java
class Transaction {
  enum TransactionScope { }
}

class Transaction {
  enum Scope { }
}
```

--

```java
// Packages are usually exception to the rule
package org.framework.batch

interface Reader { }         // :(
interface Operation { }      // :(

interface BatchReader { }    // :)
interface BatchOperation { } // :)
```

---
### Composite names usually indicate lack of a root object
```java
class AwsS3Bucket {

  private final String awsPassword;
  private final String awsLogin;
  private final String bucketName;

  public AwsS3Bucket(String awsLogin, String awsPassword, String bucketName) {
    this.awsLogin = awsLogin;
    this.awsPassword = awsPassword;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

--

```java
class AwsCredentials {

  public final String login;
  public final String password;

  public AwsCredentials(String login, String password) {
    this.login = login;
    this.password = password;
  }
}
```

---
```java
class AwsS3Bucket {

  private final AWSCredentials awsCredentials;
  private final String bucketName;

  public AwsS3Bucket(AwsCredentials awsCredentials, String bucketName) {
    this.awsCredentials = awsCredentials;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

--

```java
class AwsAccount {

  private final AwsCredentials credentials;

  public AwsAccount(AwsCredentials credentials) {
    this.credentials = credentials;
  }

}
```

---
```java
class AwsS3Bucket {

  private final AwsAccount account;
  private final String bucketName;

  public AwsS3Bucket(AwsAccount account, String bucketName) {
    this.account = account;
    this.bucketName = bucketName;
  }

  void create() {
    ...
  }

}
```

---
### Consider searchability
```java
class CancelTransaction { }

class CancelTransactionCommand { }

class CancelTransactionCommandHandler { }

class CancelTransactionHandler { }
```

--

```java
class NotifyOnApplicationCanceled
  implements DomainEventHandler<LoanApplicationCanceled> {
}

class NotifyOnLoanApplicationCanceled
  implements DomainEventHandler<LoanApplicationCanceled> {
}
```

--

### Avoid dumb suffixing
```java
class RegistrationFailure extends BusinessException { }

// vs.

class RegistrationFailureException extends BusinessException { }
```

--

---
class: center, middle
# Prefer creating objects that represent **what they are**, rather than what they do

---
.crap[
```java
class File { }

interface FileReader {
   Data read(File file) { }
}
```
]

--

.nice[
```java
interface DataFile {
   Data data();
}
```
]

--

.crap[
```java
interface EmailSender {
  void send(Email email);
}
```
]

--

.nice[
```java
interface EmailProvider {
  void send(Email email);
}
```]

--

.crap[
```java
interface ConditionChecker {
  boolean checkCondition()
}
```
]

--

.nice[```java
interface Condition {
  boolean isTrue();
}
```
]

---

.crap[
```java
interface MoneyFormatter {
  String format(Money money);
}
```]

--

.nice[
```java
interface PrettyMoney {

  String asText();

  class Humane implements PrettyMoney {
    @Override
    public String asText() { ... }
  }

  class ISO_1234 implements PrettyMoney {
    @Override
    public String asText() { ... }
  }

}
```
]

--

```java
public static void main(String[] args) {
    Money money = new Money(99.00);
    PrettyMoney prettyMoney = new PrettyMoney.Humane(money);
    println(prettyMoney.asText());
}
```
???
- makes our software more OO, composable from classes, not methods
- why not MoneyFormat?
- why not toString()

---
.crap[
```java
class FuckupProbabilityCalculator {
    BigDecimal calculate() { ... }
}
```]

--

.nice[
```java
class FuckupProbability implements DecimalNumber {
    BigDecimal decimal();
}
```]
???
why not bigdecimal?

--

```java
interface DecimalNumber {

    BigDecimal decimal();

    default DecimalNumber dividedBy(DecimalNumber divisor) {
        BigDecimal roundedDivision = decimal().divide(divisor.decimal(), RoundingMode.HALF_DOWN);
        return new Const(roundedDivision);
    }

}```
```java
class Const implements DecimalNumber {

    private final BigDecimal origin;

    public Const(int origin) { this(BigDecimal.valueOf(origin, 2)); }

    public Const(BigDecimal origin) { this.origin = origin; }

    @Override
    public BigDecimal decimal() { return origin; }
}
```
---
```java
public static void main(String[] args) {
    DecimalNumber minimal = new FuckupProbability(...);
    DecimalNumber maximal = new FuckupProbability(...);
    DecimalNumber average = minimal.plus(maximal).dividedBy(new Const(2));
}
```

--

```java
public static void main(String[] args) {
    DecimalNumber minimal = new FuckupProbability(...);
    DecimalNumber maximal = new FuckupProbability(...);
    DecimalNumber average = new Average(minimal, maximal)
}
```

--

```java
class Average implements DecimalNumber {

    private final DecimalNumber[] numbers;

    public Average(DecimalNumber... numbers) {
        this.numbers = numbers;
    }

    @Override
    public BigDecimal decimal() {
        DecimalNumber total = new Const(numbers.length);
        DecimalNumber sum = new Sum(numbers);
        DecimalNumber average = sum.dividedBy(total);
        return average.decimal();
    }

}
```
---
.crap[
```java
public final class BigDecimalUtils {

	public static final int AMOUNT_SCALE = 2;

	private BigDecimalUtils() {
	}

	public static BigDecimal amount(int value) {
		return amount(new BigDecimal(value));
	}

  public static BigDecimal amount(BigDecimal amount) {
		return amount.setScale(AMOUNT_SCALE, BigDecimal.ROUND_HALF_UP);
	}

  public static boolean isEqual(BigDecimal value1, BigDecimal value2) {
		boolean isEqual = value1.compareTo(value2) == 0;
		return isEqual;
	}

  public static boolean isInRange(BigDecimal amount, BigDecimal amountFrom, BigDecimal amountTo) {
    return isGe(amount, amountFrom) && isLe(amount, amountTo);
  }

  public static boolean isZero(BigDecimal value) {
    return isEqual(BigDecimal.ZERO, value);
  }

  ...

}
```
]
---
class: center, middle
# Methods are either **commands** or **queries**.
### Use commands (verbs) to tell an object what to do.
### With queries (nouns) you ask object a question.
— *[Command/Query Separation](http://martinfowler.com/bliki/CommandQuerySeparation.html)*
---

```java
interface Iterator<T> {
  T next(); // give next or return next? both! :-)
}
```

--

```java
interface Iterator<T> {
  void advance();
  T current();
}
```

--

```java
InputStream load(URL url);
```

--

```java
InputStream stream(URL url);
```

--

```java
String read(File file);
```

--

```java
String content(File file);
```

---
```java
class Document {
  int write(InputStream stream); // returns number of bytes written :(
}
```

--

```java
class Document {
   OutputPipe output();
}

class OutputPipe {

     void write(InputStream stream);

     int bytes();

     long time();
}
```

---
# Avoid getters
## Getters are verbs

--

## Get **may** have a side effect
### - get married
### - get money from the ATM
### - get from A to B...

---
```java
class Client {
  String fullName();
  String personalId();
}
```

--

```java
interface Iterator<T> {
  T current();
}
```

--

### Sometimes booleans are **adjectives**
```java
class Customer {
  boolean isSatisfiedBy(Specification); // satisfiedBy -> confusing
}
```

--

```java
enum Severity {
  boolean isMajor(); // major() -> confusing
}
```

--

```java
class ProductCatalog {
  boolean contains(Product);
}
```

--

```java
interface Input {
  boolean isValid(); // validate() -> verb! :(((
}
```

---
# Avoid setters in objects
## ...and don't confuse objects with **data structures**
???
- Pure OO design require encapsulation. Frameworks as for data. Conflict.

--

.crap[
```java
Client.setFirstName(firstName);
Client.setLastName(lastName);
```
]

--

.nice[
```java
Client.giveName(String firstName, String lastName);
```
]
???
grant permissions vs. set permissions

--

.crap[
```java
void setPreferredAgreementType(AgreementType preferredAgreementType) { }
```
]

--

.nice[
```java
void preferAgreement(AgreementType preferredAgreementType) { }
```
]

--

.crap[
```java
void setAgreementSigned(boolean agreementSigned) {}
```
]

--

.nice[
```java
void signAgreement() {} // agreement().sign() would be way better
```
]

--

.nice[
```java
void unsignAgreement() {}
```
]

---
# Data structures
## Do not have behaviour
## **Can** have getters and setters (if needed)
```java
@Immutable
interface UserRepresentation {

  String firstName();
  String lastName();
  Optional<String> middleName();
}
```

---
background-image:url(immutables.png)
background-size: 100%

---
# Package naming
## Name of the company has nothing to do with code
```java
package org.apache.spark;
```

```java
package spark;
```

## Plural or singular?
```java
package shipyard.maps; // contains different maps and nothing else
```
```java
package shipyard.map; // everything related to maps
```

--

```java
package shipyard.navigation;      // everything related to navigation
package shipyard.navigation.maps;
```

---
class: center, middle, invert
# Tony Hoare's billion dollar mistake

---
# In computing, a null pointer has a value reserved for indicating that the pointer does not refer to a valid object.
## - Do not pass nulls
## - Do not return nulls
---
```groovy
compile group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
```

### package-info.java
```java
@ParametersAreNonnullByDefault
package wombatizer;
```

```java
@Override
public boolean equals(@Nullable Object obj) { ... }
```
???
- otherwise I will have to null-check all arguments, to be defensive.

---
### may not contain a phone number that matches a given regex
```java
interface PhoneBook {
  PhoneNumber phoneNumber(String regex);
}
```
--
```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(String regex);
}
```
---
### regex is optional
```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(String regex);
}
```
--
```java
interface Mask {

  Mask ANY = phoneNumber -> true;

  boolean matches(PhoneNumber phoneNumber);
}
```
--
```java
class Regex implements Mask {

  private final Pattern regex;

  @Override
  public boolean matches(PhoneNumber phoneNumber) {
    return phoneNumber.matches(regex);
  }
}
```
--

```java
interface PhoneBook {
  Optional<PhoneNumber> phoneNumber(Mask mask);
}```

--
.corner[
```java
class PhoneNumber {
    boolean matches() {
        return regex.asPredicate().test(text());
    }
}
```
]

--
.corner[
```java
Pattern.compile(":")
  .splitAsStream("foobar:foo:bar")
  .filter(s -> s.contains("bar"))
  .sorted()
  .collect(Collectors.joining(":"));
```
]


---
```java
void ifPresent() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(new Regex(...));
  phoneNumber.ifPresent(paymentReminder::send);
}
```
--
```java
void orElse() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(new Regex(...))
      .orElse(PhoneNumber.USA_PRESIDENT);
}
```
--
```java
void orElseThrow() {
  Optional<PhoneNumber> phoneNumber = phoneBook.phoneNumber(new Regex(...))
      .orElseThrow(() -> new MissingPhoneNumberException(phoneNumber)
}
```
--
```java
void optionalIsAMonad() {
  phoneBook.phoneNumber(new Regex(...))
      .flatMap(no -> facebookProfile.byPhoneNumber(no))
      .flatMap(FacebookProfile::beloved)
      .ifPresent(Beloved::hijack);
}
```
???
You can build pipes w/o worrying about null checks.

---
```java
Outer outer = new Outer();
if (outer != null && outer.nested != null && outer.nested.inner != null) {
    System.out.println(outer.nested.inner.foo);
}
```
--
```java
Optional.of(new Outer())
    .flatMap(o -> Optional.ofNullable(o.nested))
    .flatMap(n -> Optional.ofNullable(n.inner))
    .flatMap(i -> Optional.ofNullable(i.foo))
    .ifPresent(System.out::println);
```

---
class: center, middle, invert
# General design principles

---
class: center, middle
# Maximizing reuse complicates use.
#### *— Kirk Knoernschild, [Java Application Architecture](https://www.amazon.com/Java-Application-Architecture-Modularity-Patterns/dp/0321247132)*
???
- Use/Reuse paradox: what is easy to use is often hard to reuse
- The ability to compose systems from reusable elements complicates the system.

---
class: center, middle
# Flexibility breeds complexity.
#### *— Kirk Knoernschild, [Java Application Architecture](https://www.amazon.com/Java-Application-Architecture-Modularity-Patterns/dp/0321247132)*
???
- implementation side of things

---
class: center, middle
# Fight temptation to write re-usable and flexible code upfront. Start with specific and direct code, and let reuse / flexibility points emerge from usage scenarios.
???
- Lean #4 principle (decide as late a possible - knowledge/time plot).
- YAGNI (XP principle)
- KISS (keep it simple and straightforward)

---
## It is a capital mistake to theorize before one has data. Insensibly one begins to twist facts to suit theories, instead of theories to suit facts.
— *Sherlock Holmes*

---
class: center, middle
# **Emergent design** depends on code that is **easy to change**.

---
class: center, middle
# Reuse increase coupling.
???
DRY has a side-effect.

---
class: center, middle
# Code must be kept at the same level of abstraction.
### (abstraction - trimming info on a subject to the absolute context relevant minimum)

---
```java
Map<Long, Map<Long, Long>> portfoliosByTraderId;
if (portfolioIdsByTraderId.get(trader.getId())
 .containsKey(portfolio.getId())) {...}
```

--

```java
if (trader.canView(portfolio)) {...}
```

---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
* def check = applicationCheckFactory.make(when, application, countryCode);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
* def check = makeCheck(application, when);
  if (log.isDebugEnabled()) {
    log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
  }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```

---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
* if (log.isDebugEnabled()) {
*   log.debug("ApplicationCheck instance is: {}", check.getClass().getName());
* }
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
  return checkResult;
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
* log(check); // logIfNeeded if conditional needs to be communicated
  def checkResult = check.run();
  persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
}
```
---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persistResults(checkResult, application);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
* persist(checkResult);
  if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
}
```

---
```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* if (runScorecard && LoanAgreementType.MAIN.equals(application.agreementType())) {
    runScorecard(application, checkResult);
  }
}
```

--

```groovy
@Override
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* if (shouldRunScorecard(application)) {
    runScorecard(application, checkResult);
  }
}
```

---
.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
*  return runScorecard && LoanAgreementType.MAIN.equals(application.agreementType());
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
*  return scoringEnabled && application.agreementType().equals(MAIN);
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
*  return scoringEnabled && application.isAgreementOfTypeMain()); // WTF is Type?
}
```
]

--

.crap[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
*  return scoringEnabled && application.isAgreementOfType(MAIN)); // WTF is Type?
}
```
]

--

.nice[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
*  return scoringEnabled && agreement.isMain();
}
```
]

--

.nice[
```groovy
private boolean shouldRunScorecard(LoanApplication application) {
   Agreement agreement = application.agreement();
   boolean agreementIsApplicableForScoring =
        agreement.isSatisfiedBy(new IsApplicableForScoring());
*  return scoringEnabled && agreementIsApplicableForScoring;
}
```
]

---
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* // smells like a missing application scoring concept
* if (shouldRunScorecard(application)) {
*    runScorecard(application, checkResult);
* }
}
```

--

```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
* def scoring = scoring(application);
* if (scoring.isNecessary()) { // NullObject can remove if, but should we?
*    scoring.score();
* }
}
```
---
```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
  def scoring = scoring(application);
* if (scoring.isNecessary()) {
    scoring.score();
  }
}
```

--

```groovy
public def checkApplication(LoanApplication application, Date when) {
  def check = makeCheck(application, when);
  log(check);
  def checkResult = check.run();
  persist(checkResult);
}
```

--

```groovy
public def scoreApplicationIfNecessary(LoanApplication application) {
  def scoring = scoring(application);
  if (scoring.isNecessary()) {
    scoring.score();
  }
}
```

---
.crap[
```java
public interface EShopService {
    Map<String, String> prepareNotificationParams(EShopSession session);
}
```
]

--

.nice[
```java
public interface EShopNotificationParams {
    NotifationParams prepare(EShopSession session);
}
```
]

--

#### ----
.crap[
```java
MultivaluedMap<String, String> formParams = new Form();
for (String key : params.keySet()) {
    formParams.add(key, params.get(key));
}
```
]

--

.nice[
```java
Form form = new Form(new Params(params));
```
]

--

#### ----

.crap[
```java
Map<String, Boolean> checkboxes = new HashMap<>();
```
]

--

.nice[
```java
Collection<Checkbox> checkboxes = ...
```
]

---
.crap[
```java
interface EquifaxFacade {
    public boolean validateAnswers(Map<String, String> questionToAnswerMap) {
      // we always get 4 questions from Equifax
      return MapUtils.isNotEmpty(questionToAnswerMap)
        && questionToAnswerMap.size() == 4;
    }
}
```
]

--

.nice[
```java
class Answer {
    String questionId;
    String answerId;
}
```
]

--

.nice[
```java
class UnvalidatedAnswers {

    private static final int ALWAYS_FIXED_NUMBER_OF_QUESTIONS = 4;
    private final Collection<Answer> answers;

    boolean areValid() {
        return answers.size() == ALWAYS_FIXED_NUMBER_OF_QUESTIONS;
    }
}
```
]

--

.nice[
```java
  UnvalidatedAnswers unvalidatedAnswers = new UnvalidatedAnswers(answers);
  if (!unvalidatedAnswers.areValid()) {
    ....
  }
```
]

---
class: center, middle
# Reification - a process of making something concrete (implicit -> explicit).
???
- with lambdas, you can write short expressions easily. Often, you must reify them.

---
class: center, middle
# The Stepdown Rule
#### **The code should read like a top-down narrative. Start with high-level, abstract paragraphs. Then dive into details. — Clean Code**


---
class: center, middle
# Comments

---
class: center, middle
# Commenting code is like explaining a bad joke.
— *Someone*

---
class: center, middle
# A common fallacy is to assume authors of incomprehensible code will somehow be able to express themselves lucidly and clearly in comments
— *Kevlin Henney*

---
class: center, middle
# What I like of comments is deleting them
— *Someone*

---
class: center, middle
![](cat.jpg)

---
background-image:url(yaml.png)
background-size: 100%

---
```java
@Component
class NoOpAuthenticationHandler implements AuthenticationHandler {

	@Override
	public void delegate(ModelAndView model) {
*		// do nothing
	}

}
```

--

```java
@RequestMapping(value = "", method = { RequestMethod.GET, RequestMethod.POST })
public String index() {
* // RequestMethod.POST protects from 405 "Method not supported" for clients
* // logging in before JS is loaded
  return loginService.isLoggedIn() ? "redirect:/profile" : "index";
}
```
![](butwhy.png)

---
.crap[
```java
class Jetty {
    /**
     * Port on which jetty would run. Defaults to 8082;
     */
    public void setPort(int port) {

    }
}
```
]

--

```java
class Jetty {

    private final int DEFAULT_PORT = 8082;

    public void run(int port) {

    public void run() {
      run(DEFAULT_PORT);
    }

    public int port() {
      return port;
    }
}
```

---
```java
interface Port {

  Port DEFAULT = () -> 8082;

  int number();
}
```

--

```java
class Jetty {

  public void run(Port port) { ... }

  public Port port() {
    return port;
  }
}
```

--

```java
class WebApplication {
  void start() {
      Jetty jetty = new Jetty();
      jetty.run(Port.DEFAULT);
  }
}
```



---
.crap[
```java
@Transactional
public Client getClient() {
  Client client = repository.getRequired(Client.class, clientId);
* // lazy init
  client.getEntityUuid();
  return client;
}
```
]

--

```java
@Transactional
<T> T clientProjection(Function<Client, T> fn) {
  Client client = repository.getRequired(Client.class, clientId);
  return fn.apply(client);
}
```

--

```java
class Screenshot {
  void take() {
*   // Base64 encoding is required by SauceLabs
    String base64Screenshot = webDriver.getScreenshotAs(OutputType.BASE64);
  }
}
```

--

```java
class SauceScreenshot {
  private static final OutputType SAUCELABS_ENCODING = OutputType.BASE64;

  void take() {
    String screenshot = webDriver.getScreenshotAs(SAUCELABS_ENCODING);
  }
}
```

---
```java
// "--web-security=false"     -> allows XHR,
// "--ssl-protocols=any"      -> enable support for all SSL protocol versions
// "--ignore-ssl-errors=true" -> ignores SSL errors
String[] args = new String[] {
    "--web-security=false",
    "--ssl-protocol=any",
    "--ignore-ssl-errors=true" });

DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(PHANTOMJS_CLI_ARGS, args);
WebDriver driver = new PhantomJSDriver(capabilities);
```

--
```java
String allowCrossOriginXhr = "--web-security=false";
String supportAllSslProtocolVersions = "--ssl-protocols=any";
String ignoreSslErrors = "--ignore-ssl-errors=true";

String[] args = new String[] {
    allowCrossOriginXhr,
    supportAllSslProtocolVersions,
    ignoreSslErrors
);

DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(PHANTOMJS_CLI_ARGS, args);
WebDriver driver = new PhantomJSDriver(capabilities);
```

---

```java
class PhantomJSCapabilities {

    private final Collection<String> args = new HashSet<>();

    public PhantomJSCapabilities allowCrossOriginXhr() {
      args.add("--web-security=false");
      return this;
    }

    public PhantomJSCapabilities supportAllSslProtocolVersions() {
      args.add("--ssl-protocol=any");
      return this;
    }

    public PhantomJSCapabilities ignoreSslErrors() {
      args.add("--ignore-ssl-errors=true");
      return this;
    }

    public DesiredCapabilities desired() {
      DesiredCapabilities capabilities = new DesiredCapabilities();
      capabilities.setCapability(PHANTOMJS_CLI_ARGS, args.toArray(String[]::new));
      return capabilities;
    }

}
```

--

```java
WebDriver driver = new PhantomJSDriver(
  new PhantomJSCapabilities()
    .allowCrossOriginXhr()
    .supportAllSslProtocolVersions()
    .ignoreSslErrors()
    .desired());
```

---
```java
private void processMsgImages(File parentDir, EmailMessage emailMessage) {
* // find all img tag src's
  String body = emailMessage.getBody();
  Pattern p = Pattern.compile("<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>");
  Matcher m = p.matcher(body);
  List<String> imageSrcList = new ArrayList<String>();
  if (m.find()) {
    String src = m.group(1);
    imageSrcList.add(src);
  }

  for (String imgSrc : imageSrcList) {
		File imgFile = new File(parentDir, imgSrc);
		if (imgFile.exists()) {
			addEmbeddedField(emailMessage, imgFile);
			emailMessage.setBody(emailMessage.getBody().replace(imgSrc, "cid:" + imgFile.getName()));
		}
	}
}
```

```java
private void processMsgImages(File parentDir, EmailMessage emailMessage) {
* List<String> imageLinks = collectImageLinks(emailMessage);

  for (String imgSrc : imageSrcList) {
  File imgFile = new File(parentDir, imgSrc);
  if (imgFile.exists()) {
    addEmbeddedField(emailMessage, imgFile);
    emailMessage.setBody(emailMessage.getBody().replace(imgSrc, "cid:" + imgFile.getName()));
  }
  }
}
```

---
```java
//
// Dear maintainer:
//
// Once you are done trying to 'optimize' this routine,
// and have realized what a terrible mistake that was,
// please increment the following counter as a warning
// to the next guy:
//
// total_hours_wasted_here = 16
//
```


---
### Express intent with code (meta-annotation is code)

--

### No FIXMEs

--

### No TODOs

--

### No commented out code

--

### JavaDocs are made for public APIs. Within a team, express use-cases with tests.

---
### JSR-305
```java
@Nonnegative
```
--
```java
@OverridingMethodsMustInvokeSuper
```
--
```java
@WillClose
```
--
```java
@WillNotClose
```
--
```java
@GuardedBy
```
--
```java
@ThreadSafe
```
--
```java
@NotThreadSafe
```
--
```java
@Immutable
```

---
### Guava
```java
@VisibleForTesting
```
--
```java
@Beta
```
--
### Custom
```java
@Seconds
```
--
```java
@VisibleForHibernate
```
--
```java
@LegacyApproach("http://our.wiki/best-practices#34")
```
--
```java
@Spike("http://trello.com/b/0V4Fn8Gm/integration-poc")
```
---
# Is Guava still a thing?

--

### Ranges
.corner.long[
```java
Range.closed(1, 3).contains(2);

Range.lessThan(5).contains(5);
```
]

--

### Multimaps
.corner.long[
```java
Multimap<String, String> gadgets = ...

gadgets.put("iPhone", "5S");
gadgets.put("iPhone", "6S");
gadgets.put("LG", "Nexus");
```
]

--

### Immutable Collections
.corner.long[
```java
Collection<User> users() {
  return ImmutableList.copyOf(users);
}
```
]

--

### Ordering
.corner.long[
```java
Ordering<Person> ordering = Ordering
  .natural()
  .nullsFirst()
  .onResultOf(Person::middleName);
```
]

--

### ComparisonChain
.corner.long[
```java
public int compareTo(Foo that) {
  return ComparisonChain.start()
    .compare(this.a, that.a)
    .compare(this.b, that.b)
    .compare(this.c, that.c, Ordering.natural())
    .result();
```
]

--

### CaseFormat
.corner.long[
```java
CaseFormat.UPPER_UNDERSCORE
  .to(CaseFormat.LOWER_CAMEL, "CONSTANT_NAME"));
```
]
--

### Hashing - BloomFilter - EventBus - EqualsTester
???
Briefly, Bloom filters are a probabilistic DS, definitely NOT containing, but if yes - MAYBE


---
class: middle, center, invert
# SOLID
#### [SOLID principles](https://vimeo.com/60193259) — *Eduards Sizovs*

---
class: middle, center
# Single Responsibility Principle
---
# How small the class should be?
???

--


### Mind-sized — *me*

--

### Small enough to lower coupling — *Marco Ceconni*
???
Marco Cecconi - Dev at StackOverflow

--

### Large enough to maximize cohesion — *Marco Ceconni*

--

### Small enough to be easy to understand, rewrite or replace  — *me*

--

### Small enough to be easy to test  — *me*

--

### Inside every large program, there is a small program trying to get out — *Tony Hoare*
???
TH - Quicksort

---
### Can you spot 2 interwoven concepts?
```java
class FtpClient {

  void transferFile(String filename, InputStream input)

  boolean fileExists(String filename);

  void makeDir(String parentDir, String dir);

  boolean folderExists(String folder);

}
```

--
### Does 1 thing well - processing

```java
class Trade {
  void process() {
    // 1000 LOC
  }
}
```

--
### Generic naming leads to obesity - Helpers, Utils, Managers, Services...

---
### Fighting feature bloat
```java
public class Tweet implements AggregateRoot<Tweet> {

    private LocalDate postedAt = LocalDate.now();

    private Collection<Like> likes = new LinkedList<>();

    public LocalDate postedAt() {
        return postedAt;
    }

*   public Collection<Like> likes() {
*       return ImmutableList.copyOf(likes);
*   }
*
*   public void like(Like like) {
*     likes.add(like);
*   }
*
*   public long totalLikes() {
*     return likes.size();
*   }
*
*   public long totalLikesBy(LikerId likerId) {
*     return likes.stream().filter(like -> like.isPutBy(likerId)).count();
*   }
```

---
```java
public class Tweet {

    private LocalDate postedAt = LocalDate.now();

    private Collection<Like> likes = new LinkedList<>();

    public LocalDate postedAt() {
        return postedAt;
    }

    public Likes likes() {
        return new Likes();
    }

    class Likes {

        public void put(Like like) {
            likes.add(like);
        }

        public long total() {
            return likes.size();
        }

        public long totalBy(LikerId likerId) {
            return likes.stream().filter(like -> like.isPutBy(likerId)).count();
        }

        public Collection<Like> all() {
            return ImmutableList.copyOf(likes);
        }
    }
}
```

---
### Total likes during Black Friday?

--

```java
class BlackFriday {

    public boolean fallsOn(LocalDate date) {
        return blackFridayAt().isEqual(date);
    }

    private LocalDate blackFridayAt() {
        return thanksGivingAt().plusDays(1);
    }

    private LocalDate thanksGivingAt() {
        return Year.now()
                .atMonth(Month.NOVEMBER)
                .atDay(1)
                .with(TemporalAdjusters.lastInMonth(DayOfWeek.THURSDAY));
    }

}
```

--

.crap[
```java
class Likes {
*   public long totalDuring(BlackFriday blackFriday) {
        return likes
            .stream()
            .filter(like -> blackFriday.fallsOn(like.when()))
            .count();
    }
}
```
]

---
```java
public interface Entity<T> {
    default <R> R collect(Function<T, R> fn) {
        return fn.apply((T) this);
    }
}
```

--

```java
class Likes implements Entity<Likes> {
  ...
}
```

--

```java
class TotalLikesDuringBlackFriday implements Function<Tweet.Likes, Long> {

    private final BlackFriday blackFriday = new BlackFriday();

    @Override
    public Long apply(Tweet.Likes likes) {
        return
          likes
            .all()
            .stream()
            .filter(like -> blackFriday.fallsOn(like.when()))
            .count();
    }
}
```

--

```java
Tweet tweet = ...
Tweet.Likes likes = tweet.likes();
long total = likes.collect(new TotalLikesDuringBlackFriday());
```
???
- must side effect free!
- btw, can be written inline, as lambdas


---
```java
public interface Entity<T> {
    default <R> R collect(Function<T, R> fn) {
        return fn.apply((T) this);
    }
*   default boolean isSatisfiedBy(Predicate<T> predicate) {
*       return predicate.test((T) this);
*   }
}
```

--

```java
class GotMillionLikesOnAPostingDay implements Predicate<Tweet> {

        @Override
        public boolean test(Tweet tweet) {
            long likesOnAPostingDay = tweet
                    .likes()
                    .all()
                    .stream()
                    .filter(like -> like.isPutAt(postedAt))
                    .count();
            return likesOnAPostingDay >= 10000000;
        }
    }
```

--
```java
Tweet tweet = ...
boolean yeahBabyYeah = tweet.isSatisfiedBy(new GotMillionLikesOnAPostingDay());
```

---
class: middle, center
# Open-Closed Principle

---
```java
class NotificationService {

  private final SmsNotifer viaSms;

  private final EmailNotifier viaEmail;

  @Autowired
  public NotificationService(SmsNotifier viaSms, EmailNotifier viaEmail) {
    this.viaSms = viaSms;
    this.viaEmail = emaviaEmailil
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        viaSms.send(notification);
      }

      viaEmail.send(notification);
  }
}

class SmsNotifier {
    void send(Notification notification);
}

class EmailNotifier {
    void send(Notification notification);
}
```

---
```java
class EveryNotificationChannel {

  private final SmsNotificationChannel viaSms;

  private final EmailNotificationChannel viaEmail;

  @Autowired
  public EveryNotificationChannel(SmsNotificationChannel viaSms, EmailNotificationChannel viaEmail) {
    this.viaSms = viaSms;
    this.viaEmail = emaviaEmailil
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        viaSms.send(notification);
      }

      viaEmail.send(notification);
  }
}

class SmsNotificationChannel {
    void send(Notification notification);
}

class EmailNotificationChannel {
    void send(Notification notification);
}
```
???
omni - every from latin.

---
```java
class EveryNotificationChannel {

  private final SmsNotificationChannel viaSms;

  private final EmailNotificationChannel viaEmail;

  @Autowired
  public EveryNotificationChannel(SmsNotificationChannel viaSms, EmailNotificationChannel viaEmail) {
    this.viaSms = viaSms;
    this.viaEmail = emaviaEmailil
  }

  void send(Notification notification) {
      if (notification.isNotTooLongForSms()) {
        viaSms.send(notification);
      }

      viaEmail.send(notification);
  }
}

class SmsNotificationChannel implements NotificationChannel {
    void send(Notification notification);
}

class EmailNotificationChannel implements NotificationChannel {
    void send(Notification notification);
}

interface NotificationChannel {
    void send(Notification notification);
}
```

---

```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  @Autowired
  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
     if (notification.isNotTooLongForSms()) {
       viaSms.send(notification);
     }

      viaEmail.send(notification);
  }
}

interface NotificationChannel {
    void send(Notification notification);
}
```

---

```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  @Autowired
  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
     if (notification.isNotTooLongForSms()) {
       viaSms.send(notification);
     }

      viaEmail.send(notification);
  }
}

interface NotificationChannel {
    void send(Notification notification);
    boolean accepts(Notification notification);
}
```

--
```java
class SmsNotificationChannel implements NotificationChannel {
    boolean accepts(Notification notification) {
        return notification.isSatisifiesBy(new FitsIntoSms());
    }
}

class EmailNotificationChannel implements NotificationChannel {
    boolean accepts(Notification notification) { return ALWAYS; }
}
```

---
```java
class EveryNotificationChannel {

  private final Collection<NotificationChannel> notificationChannels;

  @Autowired
  public EveryNotificationChannel(Collection<NotificationChannel> notificationChannels) {
    this.notificationChannels = notificationChannels;
  }

  void send(Notification notification) {
      notificationChannels.stream()
        .filter(channel -> channel.accepts(notification))
        .forEach(channel -> channel.send(notification));
  }
}
```

--

```java
class EveryNotificationChannel implements NotificationChannel {
  ...
}
```

---
class: center, middle
# Liskov Substitution Principle
???
indicators - instanceof checks, UnsupportedOperationException, funny restrictions (don't use this class if...)

---
background-image:url(toinstant.png)
background-size: 100%
???
java.sql.Date extends java.util.Date

---
.crap[
```java
class MapWithMandatoryValues implements Map<String, String> {
    @Override
    String get(Object key) {
        def value = map.get(key)
        if (!value) {
            throw new MissingParameter(key as String)
        }
        value
    }
}
```
]

--

```java
class TradeOrder {
  void cancel() {
    notifyRegulators();
  }
}
```

--
.crap[
```java
class SilentTradeOrder extends Trade {
  @Override
  void notifyRegulators() {
  }
}
```
]

---

```java
class Amount {
    private final BigDecimal origin;
    public Amount(BigDecimal origin) {
      Preconditions.checkArgument(origin.isPositive(), "Only positive amount is supported");
      this.origin = origin;
    }
}
```

--

```groovy
class AmountSpec extends Specification {
    def "does not support negative numbers"() {
      when:
        new Amount(-1.00)
      then:
         def e = thrown(IllegalArgumentException)
         e.message == "Only positive amount is supported"
    }
}
```

---

.crap[
```java
class Amount {
    BigDecimal origin;
    public Amount(BigDecimal origin) {
      Preconditions.checkArgument(origin.isPositive(), "Only positive amount is supported");
      this.origin = origin;
    }
    Amount() {

    }

}
```
]

--
.crap[
```java
class SignedAmount extends Amount {

    public SignedAmount(BigDecimal origin) {
      super();
      this.origin = origin;
    }
}
```
]


---
### Subclassing is evil because a subclass that breaks invariants may look completely logical in isolation.

--
### **Normalized hierarchy** is a hieararchy in which no class has more than one implementation of a method.

--
### Prefer composition over inheritance and, if not possible, stick to **NF**.
???
never reuse behaviour via inheritance.

---
class: center, middle
# The Interface Segregation Principle

---
class: center, middle
# Many client specific interfaces are better than one general purpose interface.
### — *Robert Martin, Agile Software Development*

---
# What's wrong with FAT interfaces?

--

### Suffer from low cohesion

--

### Suffer from high afferent/efferent coupling
???
afferent - in
efferent - out

--

### Make subclasses suffer from the same deseases

---
.crap[
```java
package shwitter.config;
interface ProductSettings {
    Attempts maxRegistrationAttempts();
    BonusAmount bonusAmount();
    Income minimalIncome();
    ...
}
```
]

--
.nice[
```java
package shwitter.registration;
interface RegistrationAttempts {
    Attempts max();
}
```
]

--

.nice[
```java
package shwitter.loyalty;
interface BonusAmount extends DecimalNumber {
}
```
]

--

.nice[
```java
package shwitter.lending.rules;
interface IncomeConstraints {
    Income minimal();
}
```
]

--

### Consider complexity of an implementor / test?
???
test double, decorator

--

### Impact of moving an interface?

---
```java
interface BacklogItem {
    Complexity complexity();
    void estimate(Duration duration);
}
```

--

### Murphy's Law hits the fan

--

.crap[
```java
class Forecast {
    private final BacklogItem backlogItem
    Duration duration() {
      Duration duration = forecast(backlogItem.complexity());
*     backlogItem.estimate(duration);
      return duration;
    }
}
```
]

--

```java
interface Forecastable {
  Complexity complexity();
}
```

--

```java
interface BacklogItem extends Forecastable {
    void estimate(Duration duration);
}
```

---
```java
interface BacklogItem {
    Complexity complexity();
    void estimate(Duration duration);
}
```

### Murphy's Law hits the fan

.nice[
```java
class Forecast {
    private final Forecastable forecastable;
    Duration duration() {
      Duration duration = forecast(forecastable.complexity());
*     backlogItem.estimate(duration); // compile error
      return duration;
    }
}
```
]

```java
interface Forecastable {
  Complexity complexity();
}
```

```java
interface BacklogItem extends Forecastable {
    void estimate(Duration duration);
}
```

---
class: center, middle
# Dependency Inversion Principle

---
class: center, middle
# High-level modules should not depend on low-level modules. Both should depend on abstractions.
### — *Robert Martin, Agile Software Development*
???
the goal is to increase reuse of a high-level modules.

---
```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

class ITextPdfDocument {

    private final Invoice invoice;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(invoice.stream(), canvas.stream());
    }
}
```

```java
package app.invoicing;

class Invoice {
    InputStream stream();
}
```


--
### **[infra.pdf]** is not reusable, because it depends on **[app.invoicing]**.

---
```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

class ITextPdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.stream(), canvas.stream());
    }
}
```

.l50[
```java
package app.invoicing;

class Invoice implements PdfSource {
    InputStream stream();
}
```
]
.r50[
```java
package app.invoicing;

interface PdfSource {
    InputStream stream();
}
```
]

### **[infra.pdf]** is still not reusable, but coupling decreased.

---
```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

class ITextPdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.stream(), canvas.stream());
    }
}
```

.l50[
```java
package app.invoicing;

class Invoice implements PdfSource {
    InputStream stream();
}
```
]
.r50[
```java
package infra.pdf;

interface PdfSource {
    InputStream stream();
}
```
]

### **[infra.pdf]** is now reusable, because of inverted dependency.

### Usage direction can be opposite to dependency direction.

---
### How to let **[app.invoicing]** plug any PDF implementation?

```java
package infra.pdf;

interface Canvas {
  OutputStream stream();
}

interface PdfSource {
    InputStream stream();
}

class ITextPdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = new IText(configuration);
        itext.enableBuffering();
        itext.render(source.stream(), canvas.stream());
    }
}
```

```java
package app.invoicing;

class Invoice implements PdfSource {
    InputStream stream();
}
```

---
### How to let **[app.invoicing]** plug any PDF implementation?

```java
package infra.pdf.api;

interface Canvas {
  OutputStream stream();
}

interface PdfSource {
    InputStream stream();
}

interface PdfDocument {
  void render(Canvas canvas);
}
```

```java
package infra.pdf.impl.itext;

class ITextPdfDocument implements PdfDocument {
    private final PdfSource source;

    public void render(Canvas canvas) {
        IText itext = ...
    }
}
```

```java
package infra.pdf.impl.pdfbox;

class BoxPdfDocument implements PdfDocument {

    private final PdfSource source;

    public void render(Canvas canvas) {
        PDFBox box = ...
    }
}
```

---
### But **[app.invoicing]** is instatiating concrete PdfDocument instance...
.crap[
```java
package app.invoicing;

@RestController
class InvoiceEndpoint {

  @GetMapping("/invoices/latest")
  void download(HttpServletResponse response) {
    Invoice invoice = invoices.latest();
*   PdfDocument document = new ITextPdfDocument(invoice); // or BoxPdfDocument
    Canvas canvas = new HttpOutCanvas(response);
    document.render(canvas);
  }
}
```
]

--

```java
package infra.pdf.api;

interface PdfDocumentFactory  {
    PdfDocument create(PdfSource source);
}
```

--

```java
package infra.pdf.impl.itext;

@Singleton
class ITextPdfDocumentFactory implements PdfDocumentFactory {

    public PdfDocument create(PdfSource source) {
        return new ITextPdfDocument(source);
    }
}
```

---
### Voila!
.nice[
```java
package app.invoicing;

@RestController
class InvoiceEndpoint {

  private final PdfDocumentFactory pdfDocumentFactory;

  @Autowired
  InvoiceEndpoint(PdfDocumentFactory pdfDocumentFactory) {
    this.pdfDocumentFactory = pdfDocumentFactory;
  }


  @GetMapping("/invoices/latest")
  void download(HttpServletResponse response) {
    Invoice invoice = invoices.latest();
*   PdfDocument document = pdfDocumentFactory.document(invoice);

    Canvas canvas = new HttpOutCanvas(response);
    document.render(canvas);
  }
}
```
]

---
### Consider **weight**
```java
package infra.pdf.impl.itext;
*@javax.inject.Singleton // javax.inject:javax.inject
class ITextPdfDocumentFactory implements PdfDocumentFactory {
    ...
}
```

### vs.

```java
package infra.pdf.impl.itext;
*@org.springframework.stereotype.Component // org.springframework:spring-context
class ITextPdfDocumentFactory implements PdfDocumentFactory {
    ...
}
```

---
background-image:url(repackage.png)
background-size: 100%

---
### Consider **granularity**
```groovy
configurations {
    compile.exclude module: "spring-boot-starter-tomcat"
}

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web:1.4.0.RELEASE")
    compile("org.springframework.boot:spring-boot-starter-jetty:1.4.0.RELEASE")
    // ...
}
```
???
but in general, Spring Boot is very fine grained.

---
class:libs
background-image:url(jetty.png)
background-size: 100%

---
background-image:url(aws.png)
background-size: 100%

---
# More on modularity
![](kirk.jpg)


---
class: nopadding
background-image:url(hibernate.png)
background-size: 100%
### .spanny[Hibernate Core v4.3.8.Final]
???
ok, you have nice physical modularity, but what about logical design?

---
class: nopadding
background-image:url(jdk7.png)
background-size: 100%
### .spanny[JDK v1.7.0_51]

---
class: nopadding
background-image:url(findbugs10.png)
background-size: 100%
### .spanny[Findbugs V1.0 - A great start]

---
class: nopadding
background-image:url(findbugs11.png)
background-size: 100%
### .spanny[Findbugs V1.1 – Imperfection creeps in]

---
class: nopadding
background-image:url(findbugs12.png)
background-size: 100%
### .spanny[Findbugs V1.2 – Imperfection takes hold]

---
class: nopadding
background-image:url(findbugs13.png)
background-size: 100%
### .spanny[Findbugs V1.3 – Chaos begins]

---
class: nopadding
background-image:url(findbugs14.png)
background-size: 100%
### .spanny[Findbugs V1.4 – Explosion]

---
class: nopadding
background-image:url(spring.png)
background-size: 100%
### .spanny[Spring v4.1.6]


---
class: right, middle
## **A JDK code base is deeply interconnected** at both the API and the implementation levels, having been built over many years primarily in the style of a monolithic software system. .fade[We’ve spent considerable effort eliminating or at least simplifying as many API and implementation dependences as possible, so that both the Platform and its implementations can be presented as a coherent set of interdependent modules, but some particularly thorny cases remain.]
### — *Mark Reinholds, Chief Architect of the Java Platform*


---
class: center, middle
## From assessing hundreds of software systems on three continents I know that about 90% of software systems are suffering from severe architectural erosion, i.e. there is not a lot of the original architectural structure left in them, and **coupling and dependencies are totally out of control**.
### — *Alexander von Zitzewitz*

---
# Hints
### Manage dependencies (Stan4j, Structure 101, VeriPacks)

--

### Avoid circular dependencies (merging, DI, demotion, escalation)
???
- you have seen escalation with a Black Friday

--

### Prefer smaller packages over large ones

--

### Provide slim interface and hide implementation details
???
@Component package-private.

--

### Group tightly-coupled classes together (Common Closure Principle)

--

### Reify! (e.g. String traderId vs TraderId traderId)


--

### [Architecting well-structured Java applications](https://www.youtube.com/watch?v=99VFdX1WS7o) — *Eduards Sizovs*

---
class:libs
background-image:url(layering_veripacks.png)

---
# VeriPacks Demo:
### 1.  **[application]** cannot be accessed by **[domain]** and **[infra]**

--

### 2. **[domain]** is accessible only by [**application**], never **[infra]**

--

### 3. **[infra.emailing]** **publishes** EmailProvider and Email interfaces. SmtpEmailProvider is only accessible by subpackages.

--

### 4. **[org.hibernate]** can only be used by **[infra.hibernate]**


    </textarea>
    <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        slideNumberFormat: function (current, total) { return "" }
      });
      slideshow.on('afterShowSlide', function (slide) {

        var axs =  {
                  title: 'thoughput / responsiveness over time.',
                  xaxis: {
                    title: 'time (months)'
                  },
                  yaxis: {
                    title: 'throughput / responsiveness (RTF / sprint)'
                  }
                }

        var thr = [
                {
                  x: [2, 10, 14, 24, 40],
                  y: [30, 29, 28, 23, 10],
                  name: 'continuous degradation',
                  mode: 'lines',
                  line: {
                      color: 'rgb(219, 64, 82)',
                      width: 3
                    }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30, 30, 30, 30],
                  name: 'sustainable pace',
                  mode: 'lines',
                  line: {
                      color: 'rgb(169, 169, 169)'
                  }
                },
                {
                  x: [2, 6, 12, 24, 48],
                  y: [30, 30.5, 31, 31.5, 32],
                  name: 'continuous improvement',
                  mode: 'lines'
                },
          ];

          var dbt = thr.concat({
                  x: [28, 28],
                  y: [30, 20],
                  name: 'technical debt',
                  mode: 'lines',
                  line: {
                    dash: 'dot'
                  }
                } );

        if (slide.properties.name == "throughput") {
          Plotly.newPlot('throughput', thr, axs);
        }
        if (slide.properties.name == "debt") {
          Plotly.newPlot('debt', dbt, axs);
        }
      });

    var ktx = document.getElementsByClassName("ktx");
    for(var i = 0; i < ktx.length; i++) {
       katex.render(ktx.item(i).getAttribute('expr'), ktx.item(i));
      }
    </script>

  </body>
</html>
