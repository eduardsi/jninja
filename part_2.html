<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="ocean.css" />
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3, h4 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }

      h4 {
        font-size: 1.3em;
        margin: 20px 0px;
      }      
      /* new */
      .example { background-color: #007ebc}
      .example h2 { color: #00394f; font-weight: bold; line-height: 0;}
      .example h1 { color: #fff; font-weight: bold; background-color: #00394f; padding: 10px }


      .codeonly h1, .codeonly h2, .codeonly h3, .codeonly h4 { color: white !important; }
      
      .codeonly { padding: 1em; background-color: #2b303b }
      .codeonly pre { margin: 0 }

      .remark-code-line-highlighted { background-color: #2d9967; color: white}
      .remark-code-line-highlighted * { color: white !important; }

      .remark-slide-scaler { -webkit-box-shadow: 0 !important; box-shadow: none !important; }
      .remark-slide-container {background-color: #2b303b}
      /* new end */
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }

      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Part II

---
class: center, middle, example
# Application aka Service layer

---
## - defines a use case, what the system does

--

## - defines a use case contract (input / output)

--

## - defines transaction boundary

--

## - never ever to be confused with a domain service

---
class: codeonly

.crap[
```java
interface MemberPermissionService {

  void grantPermission(String memberId, String permissionId);

  PermissionsDto listPermissions(String memberId);

}
```
]

--

.crap[
```java
@Transactional
class MemberPermissionServiceImpl implements MemberPermissionService {

  @Override
  public void grantPermission(String memberId, String permissionId) { ... }

  @Override
  public PermissionsDto listPermissions(String memberId) { ... }

}
```
]

---
class: bad

## - tend to grow like hell

---
class: codeonly
.nice[
```java
record GrantPermission(String memberId, permissionId) implements Command<Voidy> {
}
```
]

--
.nice[
```java
@Component
class GrantPermissionHandler implements Command.Handler<GrantPermission, Voidy> {

    private final MemberRepository members;
    private final PermissionRepository permissions;

    public GrantPermissionReaction(MemberRepository permissions, PermissionRepository members) { ... }

    @Override
    public Voidy handle(GrantPermission cmd) {
        var member = members.singleBy(cmd.memberId);
        var permission = permissions.singleBy(cmd.permissionId);

        member.grant(permission);
        return new Voidy();
    }
}
```
]

---
class: codeonly
.nice[
```java
@Configuration
class PipelinrConfiguration {

    @Bean
    Pipeline pipeline(ObjectProvider<Command.Handler> commandHandlers) {
        return new Pipelinr().with(commandHandlers::stream);
    }
}
```
]

--
class: codeonly
```java
@RestController
class GrantPermissionEndpoint {

    @Autowired
    Pipeline pipeline;

    @PostMapping("/users/{memberId}/permissions")
    Voidy accept(@PathVariable String memberId, @RequestParam String permissionId) {
        var grantPermission = new GrantPermission(memberId, permissionId);
        return grantPermission.execute(pipeline);
    }
```

---
class: bad

## - ~~tend to grow like hell~~

## - no dynamic routing



---
class: codeonly

```java
@Component
class LegacyBecomeAUserHandler implements Command.Handler<BecomeAUser, Voidy> {

    @Override
    public boolean matches(BecomeAUser command) {
        return command.user.registrationDate.isBefore(migrationDate) ||
               command.user.registrationDate.isEqual(migrationDate)
    }

    ...
}

@Component
class NewBecomeAUserHandler implements Command.Handler<BecomeAUser, Voidy> {
    
    @Override
    public boolean matches(BecomeAUser command) {
        return command.user.registrationDate.isAfter(migrationDate);
    } 

    ...
}
```

---
class: bad

## - ~~tend to grow like hell~~

## - ~~no dynamic routing~~

## - hard to plug-in without proxy magic


---
class: center, middle
## Logging?

---
class: codeonly
```java
@Component
@Order(2)
class CommandLogging implements Middleware {

    private final Logger log = LoggerFactory.getLogger(CommandLogging.class);

    @Override
    public <R, C extends Command<R>> R invoke(C command, Next<R> next) {
        log.info(">>> {}", command.toString());
        var response = next.invoke();
        log.info("<<< {} ", response.toString());
        return response;
    }

}
```

---
class: center, middle
## Correlation id?

---
class: codeonly

```java
@Component
class CorrelationId {

    private static final String MDC_KEY = "ccid";

    private final AtomicLong counter = new AtomicLong();

    public MDC.MDCCloseable storeForLogging() {
        return MDC.putCloseable(MDC_KEY, next());
    }

    private String next() {
        return String.valueOf(counter.incrementAndGet() % 1000);
    }

}
```

```java
@Component
@Order(1)
class Correlation implements Middleware {

    private final CorrelationId correlationId;

    Correlation(CorrelationId correlationId) {
        this.correlationId = correlationId;
    }

    @Override
    public <R, C extends Command<R>> R invoke(C command, Next<R> next) {
        try (var stashAutomatically = correlationId.storeForLogging()) {
            return next.invoke();
        }
    }
}
```

---
class: codeonly, invert
```
16:38:00.451 [main] INFO  CommandLogging   >>> BecomeAMember{name=Eduards} [1] 
16:38:00.453 [main] INFO  Validation       >>> Eduards has typed a strong password [1] 
16:38:00.454 [main] INFO  Registration     >>> Eduards has been registered [1] 
16:38:00.591 [main] INFO  CommandLogging   >>> GrantPermission{user=14523343,role=Superpowers} [2] 
16:38:00.692 [main] INFO  Permissions      >>> Alan has granted Superpowers permissions [2] 
16:38:00.694 [main] INFO  CommandLogging   <<< Voidy [2] 
16:38:01.322 [main] INFO  CommandLogging   <<< Voidy [1] 
```
---
class: center, middle
## Centralized Transaction management?

---
class: codeonly
```java
@Component
@Order(3)
class CommandTransaction implements Middleware {

    private final PlatformTransactionManager txManager;

    CommandTransaction(PlatformTransactionManager txManager) {
        this.txManager = txManager;
    }

    @Override
    public <R, C extends Command<R>> R invoke(C command, Next<R> next) {

        var tx = new TransactionTemplate(txManager);
        tx.setReadOnly(command instanceof ReadOnly);

        return tx.execute(txStatus -> next.invoke());
    }
}

public interface ReadOnly {
    ...
}

```

```java
class GetMobileNumbers implements Command<MobileNumbers>, ReadOnly {

    ...

}
```



---
class: bad

## - ~~tend to grow like hell~~

## - ~~no dynamic routing~~

## - ~~hard to plug-in without proxy magic~~

--

## - always blocking

---
class: codeonly

```java
class ActiveMq {
    void enqueue(Command command) {
        ...
    }
}
```

--

```java
class Kafka {
    void publish(Command command) {
        ...
    }
}
```

--

```java
class Async {
    CompletableFuture<R> schedule(Command<R> command) {
        ...
    }
}
```

--

```java
class RxJava {
    Observable<R> observe(Command<R> command) {
        ...
    }
}
```

---
class: bad

## - ~~tend to grow like hell~~

## - ~~no dynamic routing~~

## - ~~hard to plug-in without proxy magic~~

## - ~~always blocking~~

## - allows multiple handlers

---
class: codeonly

```java
class SendPaymentOverdueNotification implements Notification {
}
```

--

```java
@Component
class SendViaSms implements Notification.Handler<SendPaymentOverdueNotification> {
    // ...
```

```java
@Component
class SendViaEmail implements Notification.Handler<SendPaymentOverdueNotification> {
    // ...
```

--

```java
new Pipelinr()
      .with(commandHandlers::stream)
      .with(middlewares::orderedStream)
*     .with(notificationHandlers::stream)      
*     .with(new StopOnException());       
     
      // ContinueOnException
      // ParallelNoWait  (runs in thread pool, returns immediately)
      // ParallelWhenAll (runs in thread pool, returns when all return)
      // etc.

```

--

```java
var notification = new SendPaymentOverdueNotification(); 
notification.send(pipeline); // SendViaSms and SendViaEmail are called
```


---
class: center, middle
## 🚀 github.com/sizovs/PipelinR

---
class: codeonly
```java
org.name.application
├── RegisterCommand.java               
├── RegisterCommandHandler.java        
├── GetUserDetailsCommand.java         
├── GetUserDetailsCommandHandler.java
org.name.domain
├── User.java                          
├── UserAddress.java                   
├── UserRepository.java          
├── JpaUserRepository.java
```

--

```java
org.name.application
├── RegisterCommand.java               (public)
├── RegisterCommandHandler.java        (private) // can use Hibernate
├── GetUserDetailsCommand.java         (public)
├── GetUserDetailsCommandHandler.java  (private) // can use jOOQ and denormalization (cqrs)
org.name.domain
├── User.java                          (public)
├── UserAddress.java                   (public)
├── UserRepository.java                (public)
├── JpaUserRepository.java             (private)
```

---
background-size: contain
background-image:url(atdd.png)
# Testing

---
# Acceptance tests

--

#### - Tests system's behaviour (what vs. ~~how~~, uses external api, speaks domain language via DSL)

--

```groovy
def "new funding application confirmation"() {
  when:
    john.applyForFunding(amount: 1000.00, term: '1 year')

  and:
    kate.confirmApplicationFor(john)

  then:
    john.shouldBecomeADebitor(amount: 1000.00, term: '1 year')

  and:
    john.shouldReceiveAConfirmationEmail()
```


--

```groovy
def "regular payment overdue notification"() {
  when:
    john.applyForFunding(amount: 1000.00, term: '1 year')

  and:
    time.travelToFuture("32 days")
    night.sendOutReminders()

  then:
    john.shouldReceiveAnOverdueNotificationEmail()
```

---


# Good acceptance tests are: 

--

### isolated
#### - integrations (WireMock)
#### - postgres/redis/rabbitmq/smtp (TestContainers)
#### - filesystem (Docker)
#### - local time (test or thread-local scope)

--

### reproducible 
#### - run on local workstation before pushing a change
#### - same suite runs on CI

--

### fast 
#### - suite takes 3-5 mins to finish

---
# Unit tests

--

#### - Tests parts of the system in isolation (mocks, stubs, thread singletons, no spring)
#### - When TDD is used, naturally become part of the codebase. If no TDD – seems like a waste

--

### Some tests require special treatment: 
#### - Repository tests (talk to H2, should be marked @H2Test)
#### - File system tests (talk to Jimfs, should be marked @JimfsTest)
#### - Tests that require Spring (should be marked @SpringTest)


---
# More:
### **Growing Object-Oriented Software, Guided By Tests**
### **Mid-Sized Bulding Blocks**: dev.tube/video/sND1AR7Q_T0
### **TDD, Where Did It All Go Wrong**: dev.tube/video/EZ05e7EMOLM

---
class: center, middle, example
# Validation

---
class: codeonly

### 1. For data class validation, use Hibernate Validator. 

--

### 2. If you need more control, use github.com/neoremind/fluent-validator

--

### 3. Objects must be secure by design 

--

### 🍿 demo time!


---
class: center, middle, example
# Persistence

---
# DAO aka Data Access Object (2001)

--

### - Encapsulates access to data behind a well-defined interface

--

### - Makes client code persistence agnostic (db, ldap, rest...)

--

### - Don't do this at home:

---
class: codeonly
.crap[
```java
interface CustomerDAO {

  UUID insert(Customer customer);

  UUID insert(CustomerDTO customer);

  Customer insert(String personalId, String fullName);

  boolean saveOrUpdate(Customer customer);

  boolean updateFullname(Customer customer, String newFullName);

  boolean delete(Customer customer);

  boolean deleteByPersonalId(String personalId);

  Customer findByPersonalId(String personalId);

  Collection<Customer> findAll();

  Collection<PhoneNumber> findMobileNumbers(String personalId);

  void merge(Customer detached);

  ...
}
```
]

---
class: center, middle
# **Repository** mediates between the domain and data mapping layers using a **collection-like interface** for accessing domain objects.
### — *Fowler, PoEAA*

---
class: codeonly
.crap[
```java
interface CustomerDAO {
  UUID insert(Customer customer);
  UUID insert(CustomerDTO customer);
  Customer insert(String personalId, String fullName);
  boolean saveOrUpdate(Customer customer);
  boolean updateFullname(Customer customer, String newFullName);
  boolean delete(Customer customer);
  boolean deleteByPersonalId(String personalId);
  Customer findByPersonalId(String personalId);
  Collection<Customer> findAll();
  Collection<PhoneNumber> findMobileNumbers(String personalId);
  void merge(Customer detached);
  ...
}
```
]

--

```java
interface Customers {
  void add(Customer customer);
  void delete(Customer customer);
  Collection<Customer> all();
}
```

--

```java
interface Customers {
  void add(Customer customer);
  Customer singleBy(Criteria criteria);
  Collection<Customer> allBy(Criteria criteria);
  void deleteBy(Criteria criteria);
}
```
--

### 💡 Repositories heavily rely on Unit of Work pattern.

---
# IDs, equality and hash code
### 💡 Unless you use `merge()` or put entities in hash structures, you can rely on default `hashCode()` and `equals()` implementation.

--

### 💡 For embeddable value objects, include all fields in `equals()` and `hashCode()` calculation.

--

### 💡 Use salted Hashids, when exposing PKs to the outside world.

`> implementation("org.hashids:hashids:1.0.3")`


--

### 💡 Or UUIDs.

---
class: right, middle
### .fade[For each type of object that needs global access, create an object that can] provide the illusion of an in-memory collection .fade[ of all objects of that type. Set up access through a well-known global interface. Provide methods to add and remove objects, which will encapsulate the actual insertion of removal of data in the data store. Provide methods that select objects based on some criteria and return fully instantiated objects or collections of objects whose attribute values meet the criteria, thereby encapsulating the actual storage and query technology. ]Provide repositories only for aggregate roots .fade[that actually need direct access. Keep the client focused on the model, delegating all object storage and access to the Repositories.]
### — *Evans, DDD*

---
class: center, middle
# An aggregate is a cluster of domain objects that can be treated as a single unit. Aggregate root ensures consistency of the whole aggregate.
### — *Fowler, Bliki*


---
class: codeonly
```java
@Entity
class BankAccount {

    @Id
    @GeneratedValue
    private Long id;

    @Enumerated(EnumType.STRING)
    private Status status = Status.OPEN;

    @Embedded
    private WithdrawalLimit withdrawalLimit = WithdrawalLimit.DEFAULT;

    @ElementCollection
    @CollectionTable(name = "BANK_ACCOUNT_TX")
    @OrderColumn(name = "INDEX")
    private List<Transaction> transactions = new ArrayList<>();

    @Version
    private long version;

    ...

```

---
class: codeonly

```java
@Embeddable
class Transaction {

    enum Type {
        DEPOSIT {
          @Override
          BigDecimal apply(BigDecimal amount, BigDecimal balance) {
            return balance.add(amount);
          }
        },

        WITHDRAW {
          @Override
          BigDecimal apply(BigDecimal amount, BigDecimal balance) {
            return balance.subtract(amount);
          }
        };
    
        abstract BigDecimal apply(BigDecimal amount, BigDecimal balance);
    }

    private BigDecimal amount;

    private LocalDateTime bookingTime = LocalDateTime.now();

    @Enumerated(EnumType.STRING)
    private Type type;

    BigDecimal apply(BigDecimal balance) {
        return type.apply(amount, balance);
    }

    ...
}
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private List<Transaction> transactions = new ArrayList<>();

```

--

```java
    public BigDecimal balance() {
      return transactions.stream().foldRight(BigDecimal.ZERO, Transaction::apply); // StreamEx
    }
```

--

```java
    public Transaction deposit(BigDecimal amount) {
      Domain.ensure(!isClosed(), "Cannot deposit funds to closed account.");

      var depositTx = new Transaction(DEPOSIT, amount);
      transactions.add(depositTx);

      return depositTx;
    }
```

--

```java
    private boolean isClosed() {
      return status.equals(Status.CLOSED);
    }

    public void close(UnsatisfiedObligations unsatisfiedObligations) {
      Domain.ensure(unsatisfiedObligations.notExist(), 
        "Cannot close bank account. Unsatisfied obligations exist: %", unsatisfiedObligations);
      status = Status.CLOSED;
    }
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    public Transaction withdraw(BigDecimal amount) {
        Domain.ensure(!isClosed(), "Cannot withdraw funds from closed account.");

        var withdrawalTx = new Transaction(WITHDRAWAL, amount);
        transactions.add(withdrawalTx);

        ensurePositiveBalance();
        ensureDailyWithdrawalLimitIsNotExceeded();

        return withdrawalTx;
    }

    private void ensurePositiveBalance() {
        Domain.ensure(balance().compareTo(BigDecimal.ZERO) >= 0,
          "Cannot withdraw more funds than available on your account.");
    }

```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private void ensureDailyWithdrawalLimitIsNotExceeded() {
        var withdrawnToday = totalWithdrawn(now());
        var dailyLimit = withdrawalLimit.dailyLimit();
        var withinDailyLimit = withdrawnToday.compareTo(dailyLimit) <= 0;
        Domain.ensure(withinDailyLimit,
          "Cannot withdraw funds. Daily withdrawal limit (%s) reached.", dailyLimit);
    }

    private BigDecimal totalWithdrawn(LocalDate someDay) {
        return transactions.stream()
                .filter(tx -> tx.type().equals(WITHDRAW))
                .filter(tx -> tx.bookingTime().toLocalDate().isEqual(someDay))
                .foldRight(BigDecimal.ZERO, Transaction::apply);
    }
}
```

---
class: codeonly
```java
var account = new BankAccount();
var tx = account.withdraw(new BigDecimal(100));
```

--

### BankAccount gives the following guarantees:

--
### - all transactios fulfil rules imposed by the bank account (aggregate root)

--
### - all transactions are within business rule limits (❌ create 1,000,000$ tx)

--

### - when creating a Tx, cannot "forget" to ask if the bank account is open

--

### - no race conditions in concurrent environment (thanks to optimistic locking)

---
class: codeonly

```java
BankAccount bankAccount = new BankAccount();

executeInTx(() -> entityManager.persist(bankAccount));

CyclicBarrier coordinator = new CyclicBarrier(2);

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(BankAccount.class, bankAccount.id())
          .close());
        coordinator.await();
    })
).start();

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(BankAccount.class, bankAccount.id())
          .deposit(new BigDecimal(1000.00));
        coordinator.await();
    })
).start();
```

--

### 💡 To avoid data corruption, protect aggregate roots with an optimistic lock.

---
class: center, middle
### Even though our industry has been working with this stuff for 20 years or more, there are not many people who can explain off-the-cuff the difference between, say, **read committed** and **repeatable read** isolation. This is a problem, because if you don't know what guarantees you can expect from your database, you cannot know whether your code has concurrency bugs and race conditions.
#### — github.com/ept/hermitage

---
class: center
# Why weak isolation works?

--

### To have a race condition, you need concurrency. For low-traffic and low-contention applications, it’s possible that anomalies don’t arise.

--

### When anomalies do arise, it’s possible that the read-write anomalies don’t translate into application data corruption. Just because a read/write race occurs doesn’t mean all outcomes are necessarily wrong (e.g., two writers might perform the exact same read-modify-write operations with the same outcome regardless of order).

--

### It’s possible data is actually **occasionally** corrupted, and nobody cares. Or, when they do, they manually issue the customer an IOU and/or send them an overdraft notice.

#### — bailis.org/blog/understanding-weak-isolation-is-a-serious-problem/

---
class: center, middle
## Map aggregates by identity/embedding, not by reference to avoid risk of modifying more than one aggregate per transaction.
### ... concurrency exceptions can reach the point where the system becomes unusable.

---
class: codeonly
```java
@Entity
class UserAuditLog extends DomainEntity {

    @ElementCollection
    @CollectionTable(name = "USER_AUDIT_ENTRIES")
    private Collection<LogEntry> entries = new ArrayList<>();

    private LocalDateTime archivingTime;

    public void write(LogEntry entry) {
      this.entries.add(entry);
    }

    public void archive() {
        this.archivingTime = LocalDateTime.now();
    }
}
```

--

```java
@Entity
class User extends DomainEntity {

    @ManyToOne
    private UserAuditLog auditLog;

    public void change(Email newEmail) {
        Email oldEmail = this.email;
        auditLog.write(new LogEntry.EmailChanged(oldEmail, newEmail));
    }
}
```

---
class: codeonly
```java
User user = new User();
UserAuditLog userAuditLog = new UserAuditLog();

executeInTx(() ->
  persist(user, userAuditLog);
);

CyclicBarrier coordinator = new CyclicBarrier(2);

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(User.class, user.id())
          .change(new Email("new@email.com"));
        coordinator.await();
    })
).start();

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(UserAuditLog.class, userAuditLog.id())
          .archive();
        coordinator.await();
    })
).start();
```

--
#### 💥 Conflict: both transactions modified the audit log. The last rolls back (if optimistic locked is on).

--

#### ⚠️ Danger: can try disabling optimistic locking for certain entities/fields.

--

#### 💡 Alternative: map aggregates by identity/embedding and use eventual consistency.

---
class: codeonly

```java
@Entity
class User extends DomainEntity {

    @ManyToOne
    private UserAuditLog auditLog;

    public void change(Email newEmail) {
        Email oldEmail = this.email;
        auditLog.write(new LogEntry.EmailChanged(oldEmail, newEmail));
    }
}
```

--

```java
@Entity
class User extends DomainEntity {

    @Embedded
*   private UserAuditLogId auditLogId;

    public void change(Email newEmail) {
        Email oldEmail = this.email;
        later.schedule(new WriteNewLogEntry(
              new EmailChanged(oldEmail, newEmail)
        ));
    }
}
```

--

#### 💡 Principle: conflicting or heavy work should run in a separate transaction.
#### 💡 Principle: use Transactional Outbox pattern not to lose the work.

---
class: center, middle, example
# Fault Tolerance Patterns

---
class: center, middle
## Throttling and Bulkheads

---
class: codeonly

```java
class RateLimiter {

    private final Semaphore limiter;
  
    RateLimiter(int limiter) {
      this.limiter = new Semaphore(limiter);
    }
 ```
 
--

 ```java
    <R> R limit(Supplier<R> unlimited) {
      if (!limiter.tryAcquire()) {
        throw new ThrottlingException(limiter.availablePermits());
      }
      try {
        return unlimited.get();
      } finally {
        limiter.release();
      }
    }
```

--

```java
    @ResponseStatus(code = HttpStatus.TOO_MANY_REQUESTS)
    private static class ThrottlingException extends RuntimeException {
      private ThrottlingException(int maxPermits) {
        super(format("Reached the maximum number of permitted requests (%s)", maxPermits));
      }
    }
  }
```

---
class: codeonly
```java
@Component
@Order(1)
class Throttling implements Middleware {

  private final ConcurrentHashMap<Type, RateLimiter> rateLimiters;
  private final Collection<RateLimit> rateLimits;

  public Throttling(Collection<RateLimit> rateLimits) {
    this.rateLimits = rateLimits;
    this.rateLimiters = new ConcurrentHashMap<>();
  }
```

--

```java
  @SuppressWarnings("unchecked")
  @Override
  public <R, C extends Command<R>> R invoke(C command, Next<R> next) {

    var rateLimit = rateLimits
        .stream()
        .filter(limit -> limit.matches(command))
        .findFirst();
```

--

```java
    return rateLimit
*       .map(limit -> limiter(command, limit))
        .map(limiter -> limiter.limit(next::invoke))
        .orElseGet(next::invoke);
  }

  private <R, C extends Command<R>> RateLimiter limiter(C command, RateLimit limit) {
    var commandClass = command.getClass();
    return rateLimiters.computeIfAbsent(commandClass, type -> new RateLimiter(limit.rateLimit()));
  }


}
```

---
class: center, middle
## `Failsafe`

---

class: codeonly
### Retries

```java
RetryPolicy<Connection> retry = new RetryPolicy<>()
    .withDelay(Duration.ofSeconds(1))
    .withMaxAttempts(3);
}
```

--

```java
Connection connection = Failsafe.with(retry).get(() -> connect());
```

--

### Timeouts 

```java
Timeout<Connection> timeout = Timeout.of(Duration.ofSeconds(10));
```

--

```java
Connection connection = Failsafe.with(timeout).get(() -> connect());
```

--

### Mix 

```java
// retry N times -> timeout if took too long
Connection connection = Failsafe.with(timeout, retry).get(() -> connect());

// execute and timeout if took too long -> retry N times
Connection connection = Failsafe.with(retry, timeout).get(() -> connect());
```

---

class: codeonly

### Fallbacks

```java
Fallback<Connection> fallback = Fallback.of(Slave::connect);
```

--

```java
Connection connection = Failsafe.with(fallback).get(() -> connect());
```

--

### Circuit Breaker

```java
CircuitBreaker<Connection> breaker = new CircuitBreaker<>()
    .withFailureThreshold(10, Duration.ofMinutes(1))
    .withDelay(Duration.ofMinutes(10));
}
```

--

```java
Connection connection = Failsafe.with(breaker).get(() -> connect());
```

---
# Patterns
### Fallback
### Timeout
### Circuit breaker
### Retries
### Bulkheads
### Throttling

---
class: center, middle
# You made it! 

---
# Awesome frameworks
.l50[
### Caffeine
### Selenide
### Testcontainers
### WireMock
### Jimfs
### Awaitility
### ea-async
]
.r50[
### Restassured
### AssertJ
### Faker
### jOOR
### ByteBuddy
### ArchUnit
### Spock
]

---

# Awesome Java people
.l50[
### Jakub Nabrdalik
### Jakub Pilimon
### J.B. Rainsberger
### Victor Rentea
]
.r50[
### Venkat Subramaniam
### Lukas Eder
### Yegor Bugayenko
### Robert Martin (Uncle Bob)
]

---
class: center, middle
# DevTernity

---
class: center, middle
# Final words

---
class: center, middle
# Thank you!



    </textarea>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/remark/0.14.0/remark.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true
      });
    </script>

  </body>
</html>
