<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="ocean.css" />
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      /* new */
      .example { background-color: #007ebc}
      .example h2 { color: #00394f; font-weight: bold; line-height: 0;}
      .example h1 { color: #fff; font-weight: bold; background-color: #00394f; padding: 10px }

      .codeonly { padding: 1em; background-color: #2b303b }
      .codeonly pre { margin: 0 }

      .remark-code-line-highlighted { background-color: #2d9967; color: white}
      .remark-code-line-highlighted * { color: white !important; }

      .remark-slide-scaler { -webkit-box-shadow: 0 !important; box-shadow: none !important; }
      .remark-slide-container {background-color: #2b303b}
      /* new end */
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }

      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Part II

---
class: center, middle, example
# Application aka Service layer

---
## - defines a use case, what the system does

--

## - defines a use case contract (input / output)

--

## - defines transaction boundary

--

## - never ever to be confused with a domain service

---
class: codeonly

.crap[
```java
interface MemberPermissionService {

  void grantPermission(String memberId, String permissionId);

  PermissionsDto listPermissions(String memberId);

}
```
]

--

.crap[
```java
@Transactional
class MemberPermissionServiceImpl implements MemberPermissionService {

  @Override
  public void grantPermission(String memberId, String permissionId) { ... }

  @Override
  public PermissionsDto listPermissions(String memberId) { ... }

}
```
]

---
class: bad

## - tend to grow like hell

--

## - no single entry point

--

## - always blocking

--

## - hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...

---
class: codeonly
.nice[
```java
interface Command<T extends Command.R> {
    interface R {
      class Void implements Command.R {
      }
    }
}
```
]

--

.nice[
```java
interface Reaction<C extends Command<R>, R extends Command.R> {
    R react(C $);
}
```
]

--
.nice[
```java
interface Now {
    <C extends Command<R>, R extends Command.R> R execute(C command);
}
```
]
???
a funnel finds and executes appropriate impl for a command using generics

--

.nice[
```java
interface Future {
    <C extends Command<R>, R ...> CompletableFuture<R> schedule(C command);
}```
]

--

.nice[
```java
interface Rx {
    <C extends Command<R>, R ...> Observable<R> observe(C command);
}
```
]

--

.nice[
```java
interface Durable {
    <C extends Command> void enqueue(C command);
}
```
]

---
class: codeonly
.nice[
```java
class GrantPermission implements Command<Command.R.Void> {

    private final String memberId, permissionId;

    public GrantPermission(String memberId, String permissionId) { ... }

    public String memberId() {
        return memberId;
    }

    public String permissionId() {
        return permissionId;
    }
}
```
]

--
.nice[
```java
class GrantPermissionReaction implements Reaction<GrantPermission, Command.R.Void> {

    private final Members members;
    private final Permissions permissions;

    public GrantPermissionReaction(Permissions permissions, Members members) { ... }

    @Override
    public Command.R.Void react(GrantPermissionCommand $) {
        MemberId memberId = new MemberId($.memberId());
        Member member = members.singleBy(memberId);

        PermissionId permissionId = new PermissionId($.permissionId());
        Permission permission = permissions.singleBy(permissionId);

        member.grant(permission);
        return new Command.R.Void();
    }
}
```
]

---
class: codeonly
```java
@RestController
class GrantPermissionEndpoint {

    @Autowired
    Now now;

    @PostMapping("/users/{memberId}/permissions")
    Command.R.Void accept(@PathVariable String memberId, @RequestParam String permissionId) {
        GrantPermission grantPermission = new GrantPermission(memberId, permissionId);
        return now.execute(grantPermission);
    }
```

--

```java
    ...

    @Autowired
    Future future;

    future.schedule(grantPermission)
      .thenAccept(System.out::println)
      .thenAccept(...)
```

--

```java
    ...

    @Autowired
    Rx rx;

    rx.observe(grantPermission).subscribe(System.out::println);
```

--

```java
    ...

    @Autowired
    Durable durable;

    durable.enqueue(grantPermission);
```

---
class: codeonly
```java
interface Command<T extends Command.R> {

    default T execute(Now now) {
        return now.execute(this);
    }

    default CompletableFuture<T> schedule(Future future) {
        return future.schedule(this);
    }

    default Observable<T> observe(Rx rx) {
        return rx.observe(this);
    }

    default void enqueue(Durable durable) {
        durable.enqueue(this);
    }
}
```

--
```java
GrantPermission grantPermission = new GrantPermission("memba", "permission");

grantPermission.execute(now);
```

--

```java
grantPermission.schedule(future);
```

--

```java
grantPermission.observe(rx);
```

--

```java
grantPermission.enqueue(durable);
```

---
class: codeonly
```java
class Try<C extends Command<R>, R extends Command.R> implements Command<R> {

    private final C origin;

    private long times = 3;

    public Try(C origin) {
        this.origin = origin;
    }

    public Command<R> origin() {
        return origin;
    }


    public Try<C, R> times(long times) {
        this.times = times;
        return this;
    }

    public long times() {
        return times;
    }
}
```

---
class: codeonly
```java
class TryReaction<C extends Command<R>, R extends Command.R>
                                          implements Reaction<Try<C, R>, R> {

    private final Router router;

    @Override
    public R react(Try<R> $) {

        RetryPolicy retryPolicy = new RetryPolicy()
                .withDelay(500, TimeUnit.MILLISECONDS)
                .withMaxRetries($.times());

        return Failsafe.with(retryPolicy).get(() -> {
            Command<R> origin = $.origin();
            Reaction<Command<R>, R> reaction = router.route(origin);
            return reaction.react(origin);
        });
    }
}
```

--

```java
new Try<>(
        new GrantPermission(...))
    .times(5)
    .execute(now);
```

---
class: codeonly
```java
@Component
class Router {

    private final LoadingCache<Type, Reaction> reactions;

    @Autowired
    public Router(ListableBeanFactory beanFactory) {
        this.reactions = Caffeine.newBuilder()
            .build(commandType -> reactions(beanFactory)
                .stream()
                .filter(reaction -> reaction.commandType().isSupertypeOf(commandType))
                .findFirst()
                .orElseThrow(() -> new NoReactionFound(commandType)));
    }

    private Collection<Reaction> reactions(ListableBeanFactory beanFactory) {
        return beanFactory.getBeansOfType(Reaction.class).values();
    }

    public <C extends Command<R>, R extends Command.R> Reaction<C, R> route(C command) {
        return reactions.get(command.type());
    }
}
```

--

```java


interface Reaction<C extends Command<R>, R extends Command.R> {

    R react(C $);

    default TypeToken<C> commandType() {
        return new TypeToken<C>(getClass()) {
        };
    }
}
```

---
class: center, middle
## Bundle advanced functionality into separate objects. Functionality is hidden unless such objects are requested.
### â€” *Scott Meyers*

---

## .strike[Tend to grow like hell]

--

## .strike[No single entry point]

--

## .strike[Always blocking]

--

## .strike[Hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...]

---
class: center, middle
## Centralized Transaction management?

---
class: codeonly
```java
interface Command<T extends Command.R> {

    interface R {
        class Void implements R {

        }
    }

    interface TxFlag {

        TxFlag READ_ONLY = tx -> tx.setReadOnly(true);

        void apply(TransactionTemplate tx);
    }

    default Collection<TxFlag> txFlags() {
        return Collections.emptyList();
    }
}
```

--

```java
class GetMobileNumbers implements Command<MobileNumbers> {

    @Override
    public Collection<TxFlag> txFlags() {
        return ImmutableList.of(TxFlag.READ_ONLY);
    }

}
```

---
class: codeonly
```java
@Component
class TransactionalNow implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = router.route(command);

*       TransactionTemplate tx = new TransactionTemplate(txManager);
*       command.txFlags().forEach(flag -> flag.apply(tx));

        R response = tx.execute(txStatus -> reaction.react(command));

        return response;
    }
}
```

---
class: center, middle
## Logging?

---
class: codeonly
```java
@Component
class TransactionalAndLoggingNow implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = router.route(command);

        TransactionTemplate tx = new TransactionTemplate(txManager);
        command.txFlags().forEach(flag -> flag.apply(tx));

*       log.info(">>> {}", command.toLogString());
        R response = tx.execute(txStatus -> reaction.react(command));
*       log.info("<<< {}", response.toLogString());

        return response;
    }
}
```

---
class: center, middle
## Logging correlation?

---
class: codeonly
```java
@Component
class CommandCorrelationId {

    private static final String MDC_KEY = "ccid";

    private final AtomicLong counter = new AtomicLong();

    @Value("${unique.node.id}")
    private String node;


    public void storeForLogging() {
        MDC.put(MDC_KEY, next());
    }

    public void stashFromLogging() {
        MDC.remove(MDC_KEY);
    }

    private String next() {
        return node + counter.incrementAndGet() % 1000;
    }
}
```

---
class: codeonly
```java
@Component
class GrowingNow implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    private final CommandCorrelationId correlationId;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = rounter.route(command);

*       correlationId.storeForLogging();

        TransactionTemplate tx = new TransactionTemplate(txManager);
        command.txFlags().forEach(flag -> flag.apply(tx));

        log.info(">>> {}", command.toLogString());
        R response = tx.execute(txStatus -> reaction.react(command));
        log.info("<<< {}", response.toLogString());

*       correlationId.stashFromLogging();

        return response;
    }
}
```

---
class: center, middle
## Refactoring to decorators

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    private final CommandCorrelationId correlationId;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Now pipe = new Correlable(
                      new Loggable(
                         new Transactional(
                            new Reacting())));

        return pipe.execute(command);
    }
```

--
```java
    private class Correlable implements Now {

        private final Now origin;

        public Correlable(Now origin) {
            this.origin = origin;
        }

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            correlationId.storeForLogging();
            R response = origin.execute(command);
            correlationId.stashFromLogging();
            return response;
        }
    }
```

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    ...

    private class Loggable implements Now {

        private final Logger log = LoggerFactory.getLogger(Loggable.class);

        private final Now origin;

        public Loggable(Now origin) {
            this.origin = origin;
        }

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            log.info(">>> {}", command.toLogString());
            R response = origin.execute(command);
            log.info("<<< {}", command.toLogString());
            return response;
        }
    }

```

--

```java
    private class Transactional implements Now {

        private final Now origin;

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            TransactionTemplate tx = new TransactionTemplate(txManager);
            command.txFlags().forEach(flag -> flag.apply(tx));
            return tx.execute(txStatus -> origin.execute(command));
        }
    }
```

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    ...

    private class Reacting implements Now {

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            Reaction<C, R> reaction = router.route(command);
            return reaction.react(command);
        }
    }

}
```

---
# Commands are also great, because:

--

### - new info can be passed downstream w/o changing the interface

--

### - funnels can read command @Annotations

--

### - flexible composition at command, reaction and funnel side

--

### - favours composion over jdk/javassist/bytebuddy proxying

---
class: center, middle
## Fixing callback hell with CompletableFutures

---
class: codeonly
.crap[
```java
Firebase firebase = new Firebase("https://your-app.firebaseio.com");
Firebase expenses = firebase.child("expenses");

CountDownLatch firebaseWait = new CountDownLatch(1);

AtomicReference<DataSnapshot> snapshot = new AtomicReference<>();
AtomicReference<FirebaseError> exception = new AtomicReference<>();

expenses.addListenerForSingleValueEvent(new ValueEventListener() {
   @Override
   public void onDataChange(DataSnapshot dataSnapshot) {
       snapshot.set(dataSnapshot);
       firebaseWait.countDown();
   }

   @Override
   public void onCancelled(FirebaseError firebaseError) {
       exception.set(firebaseError);
       firebaseWait.countDown();
   }
});

firebaseWait.await(5, TimeUnit.SECONDS);

System.out.println(snapshot.get());
```
]

---
class: codeonly
```java
class RxFirebase {

  private final Firebase root;

  public RxFirebase(Firebase root) {
      this.root = root;
  }
```

--

```java
  public CompletableFuture<DataSnapshot> snapshot(String path) {
      Firebase children = root.child(path);
      CompletableFuture<DataSnapshot> completableFuture = new CompletableFuture<>();
      children.addListenerForSingleValueEvent(new Notify(completableFuture));
      return completableFuture;
  }
```

--

```java
  private class Notify implements ValueEventListener {

      private final CompletableFuture<DataSnapshot> completableFuture;

      public Notify(CompletableFuture<DataSnapshot> completableFuture) {
          this.completableFuture = completableFuture;
      }

      @Override
      public void onDataChange(DataSnapshot dataSnapshot) {
          completableFuture.complete(dataSnapshot);
      }

      @Override
      public void onCancelled(FirebaseError firebaseError) {
          completableFuture.completeExceptionally(firebaseError.toException());
      }
  }
}
```

---
class: codeonly
.nice[
```java
Firebase firebase = new Firebase("https://your-app.firebaseio.com");
```
]

--

.nice[
```java
RxFirebase rxFirebase = new RxFirebase(firebase);
```
]

--

.nice[
```java
CompletableFuture<DataSnapshot> expenses = rxFirebase.snapshot("expenses");
```
]

--

.nice[
```java
DataSnapshot snapshot = expenses.get(5, TimeUnit.SECONDS);
```
]

--

.nice[
```java
System.out.println(snapshot);
```
]

---
# vs.
### - RxJava
### - Spring Reactor
### - Reactive Streams -> java.util.concurrent.Flow

---
class: center, middle, example
# Validation (live-show)

---
class: center, middle, example
# Persistence

---
# DAO aka Data Access Object (2001)

--

### - Encapsulates access to data behind a well-defined interface

--

### - Makes client code persistence agnostic (db, ldap, rest...)

--

### - Don't do this at home:

---
class: codeonly
.crap[
```java
interface CustomerDAO {

  UUID insert(Customer customer);

  UUID insert(CustomerDTO customer);

  Customer insert(String personalId, String fullName);

  boolean saveOrUpdate(Customer customer);

  boolean updateFullname(Customer customer, String newFullName);

  boolean delete(Customer customer);

  boolean deleteByPersonalId(String personalId);

  Customer findByPersonalId(String personalId);

  Collection<Customer> findAll();

  Collection<PhoneNumber> findMobileNumbers(String personalId);

  void merge(Customer detached);

  ...
}
```
]

---
class: center, middle
# **Repository** mediates between the domain and data mapping layers using a **collection-like interface** for accessing domain objects.
### â€” *Fowler, PoEAA*

---
class: codeonly
.crap[
```java
interface CustomerDAO {
  UUID insert(Customer customer);
  UUID insert(CustomerDTO customer);
  Customer insert(String personalId, String fullName);
  boolean saveOrUpdate(Customer customer);
  boolean updateFullname(Customer customer, String newFullName);
  boolean delete(Customer customer);
  boolean deleteByPersonalId(String personalId);
  Customer findByPersonalId(String personalId);
  Collection<Customer> findAll();
  Collection<PhoneNumber> findMobileNumbers(String personalId);
  void merge(Customer detached);
  ...
}
```
]

--

```java
@VanillaImplementation
interface Customers {
  void add(Customer customer);
  void delete(Customer customer);
  Collection<Customer> all();
}
```

--

```java
@InRealWorldWeAlsoNeedCriteria
interface Customers {
  void add(Customer customer);
  void delete(Customer customer);
  Customer singleBy(Criteria criteria);  
  Collection<Customer> allBy(Criteria criteria);
}
```

---
class: center, middle
# Equality for Value Objects

---
class: center, middle
# Equality for Entities

---
class: codeonly
.crap[
```java
class Account {

    @GeneratedValue(strategy= GenerationType.AUTO)
    private Long id;

    private String iban;

    public Account(String iban) {
        this.iban = iban;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Account)) return false;
        Account account = (Account) o;
        return Objects.equals(getId(), account.getId());
    }    

    @Override
    public int hashCode() {
        return Objects.hash(getId());
    }    
}
```
]

---
class: codeonly

```java
Account offshore = new Account("DZ4000400174401001050486");
```

--

```java
Collection<Account> accounts = new HashSet<>();
accounts.add(offshore);
```

--

```java
entityManager.persits(offshore);
```

--
```java
accounts.contains(offshore);
```

--

class: codeonly
.nice[
```java
class Account {

    @GeneratedValue(strategy= GenerationType.AUTO)
    private Long id;

*   private UUID uuid = UUID.randomUUID();

    private String iban;

    public Account(String iban) {
        this.iban = iban;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Account)) return false;
        Account account = (Account) o;
*       return Objects.equals(uuid, account.uuid);
    }    

    @Override
    public int hashCode() {
*      return Objects.hashCode(uuid);
    }    
}
```
]
???
Benefits? Drawbacks?

---
class: right, middle
### .fade[For each type of object that needs global access, create an object that can] provide the illusion of an in-memory collection .fade[ of all objects of that type. Set up access through a well-known global interface. Provide methods to add and remove objects, which will encapsulate the actual insertion of removal of data in the data store. Provide methods that select objects based on some criteria and return fully instantiated objects or collections of objects whose attribute values meet the criteria, thereby encapsulating the actual storage and query technology. ]Provide repositories only for aggregate roots .fade[that actually need direct access. Keep the client focused on the model, delegating all object storage and access to the Repositories.]
### â€” *Evans, DDD*

---
class: center, middle
# An aggregate is a cluster of domain objects that can be treated as a single unit. Any references from outside the aggregate should only go to the aggregate root.
### â€” *Fowler, Bliki*

---
class: center, middle
# Aggregate root ensures consistency of an aggregate.

---
class: codeonly
```java
@Entity
class BankAccount {

    @Id
    private UUID id = UUID.randomUUID();

    @Enumerated(EnumType.STRING)
    private Status status = Status.OPEN;

    @Embedded
    private WithdrawalLimit withdrawalLimit = WithdrawalLimit.DEFAULT;

    @ElementCollection
    @CollectionTable(name = "BANK_ACCOUNT_TX")
    @OrderColumn("INDEX")
    private List<Transaction> transactions = new ArrayList<>();

    @Version
    private long version;

    ...

```

```java
@Embeddable
class Transaction {

    private DecimalNumber amount;

    private LocalDateTime bookedAt = LocalDateTime.now();

    @Enumerated(EnumType.STRING)
    private TransactionType type;

    ...
}
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private List<Transaction> transactions = new ArrayList<>();

```

--

```java
    public DecimalNumber balance() {
        DecimalNumber totalDeposited = transactions.stream()
                .filter(tx -> tx.type().equals(DEPOSIT))
                .map(Transaction::amount)
                .reduce(new Const(0), DecimalNumber::plus);

        return transactions.stream()
                .filter(tx -> tx.type().equals(WITHDRAWAL))
                .map(Transaction::amount)
                .reduce(totalDeposited, DecimalNumber::minus);
    }
```

--

```java
    public Transaction deposit(DecimalNumber amount) {
        Domain.ensure(!isClosed(), "Cannot deposit funds to closed account.");

        Transaction depositTx = new Transaction(DEPOSIT, amount);
        transactions.add(depositTx);

        return depositTx;
    }
```

--

```java
    private boolean isClosed() {
        return status.equals(Status.CLOSED);
    }

    public void close() {
        status = Status.CLOSED;
    }
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    public Transaction withdraw(DecimalNumber amount) {
        Domain.ensure(!isClosed(), "Cannot withdraw funds from closed account.");

        Transaction withdrawalTx = new Transaction(WITHDRAWAL, amount);
        transactions.add(withdrawalTx);

        ensurePositiveBalance();
        ensureDailyWithdrawalLimitIsNotExceeded();

        return withdrawalTx;
    }

    private void ensurePositiveBalance() {
        Domain.ensure(balance().isPositive(),
          "Cannot withdraw more funds than available on your account.");
    }

```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private void ensureDailyWithdrawalLimitIsNotExceeded() {
        DecimalNumber dailyLimit = withdrawalLimit.dailyLimit();
        DecimalNumber withdrawnToday = totalWithdrawn(now());
        boolean dailyLimitExceeded = withdrawnToday.isGreaterThan(dailyLimit);
        Domain.ensure(!dailyLimitExceeded,
          "Cannot withdraw funds. Daily withdrawal limit (%s) reached.", dailyLimit);
    }

    private DecimalNumber totalWithdrawn(LocalDate bookedOn) {
        return transactions.stream()
                .filter(tx -> tx.type().equals(WITHDRAWAL))
                .filter(tx -> tx.bookedAt().toLocalDate().isEqual(bookedOn))
                .map(Transaction::amount)
                .reduce(new Const(0), DecimalNumber::plus);
    }
}
```

---
## BankAccount gives the following guarantees:

--

### - cannot create/store 1 million EUR transaction

--

### - cannot create/store tx when account is closed

--
### - cannot create/store tx that violates limits

--

### - no data corruption thanks to optimistic locking

---
class: bottom, middle
background-image:url(thrones_aggregate.jpg)
background-size: 50%
???
Effective Aggregate Design by Vaughn Vernon (https://vaughnvernon.co/?p=838)

---
class: center, middle
# Aggregate root defines transactional boundaries.
### ...and can only be designed after careful transactional analysis.

---
class: codeonly
```java
@Entity
public class Customer extends DomainEntity {

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "EMAIL_ADDRESS"))
    private Email emailAddress;

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "PASSWORD"))
    private Password password;

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "ADDRESS"))
    private Address address;

    public Customer(Email emailAddress, Password password) {
        this.emailAddress = emailAddress;
        this.password = password;
    }

    private Customer() {
    }

    public void relocateTo(Address address) {
        this.address = address;
    }

    public void changePassword(Password newPassword) {
        this.password = newPassword;
    }

}
```

---
class: codeonly

```java
Customer customer = new Customer(
  new Email("hello@devchampions.com"),
  new Password("qwerty123"));

executeInTx(() -> entityManager.persist(customer));

CyclicBarrier coordinator = new CyclicBarrier(2);

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(Customer.class, customer.id())
          .relocateTo(new Address("New York, Central Park"));
        coordinator.await();
    })
).start();

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(Customer.class, customer.id())
          .changePassword(new Password("whatever"));
        coordinator.await();
    })
).start();
```

---
class: center, middle
# Map aggregates by identity, not by pointer to avoid risk of modifying more than one aggregate per transaction.
### (concurrency exceptions can reach the point where the system becomes unusable)

---
class: codeonly
```java
@Entity
class TravisLog extends DomainEntity {

    @ElementCollection
    @CollectionTable(name = "TRAVIS_LOG_ENTRIES")
    private Collection<Entry> entries = new ArrayList<>();

    private LocalDateTime archivedAt;

    public void write(Entry entry) {
      this.entries.add(entry);
    }

    public void archive() {
        this.archivedAt = LocalDateTime.now();
    }
}
```

--

```java
@Entity
class Travis extends DomainEntity {

    @ManyToOne
    private TravisLog log;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
        log.write(new NewRepositoryLogEntry(repository.id()))
    }
```

---
class: codeonly
```java
Travis travis = new Travis();
TravisLog travisLog = new TravisLog();
GitHubRepository gitHubRepository = new GitHubRepository();

executeInTx(() ->
  persist(travis, travisLog, gitHubRepository);
);

CyclicBarrier coordinator = new CyclicBarrier(2);

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(Travis.class, travis.id())
          .manage(gitHubRepository);
        coordinator.await();
    })
).start();

new Thread(() ->
    executeInTx(() ->
        entityManager
          .find(TravisLog.class, travisLog.id())
          .archive();
        coordinator.await();
    })
).start();
```

---
class: codeonly

```java
@Entity
class Travis extends DomainEntity {

    @ManyToOne
    private TravisLog log;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
        log.write(new NewRepositoryLogEntry(repository.id()));
    }
```

--

```java
@Entity
class Travis extends DomainEntity {

*   @Embedded
*   private TravisLogId logId;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
*       log.write(new NewRepositoryLogEntry(repository.id())); // woohoo, it's impossible now.
    }
```

---
background-image:url(eventual.jpg)
background-size: 50%

---
class: codeonly
```java
@Entity
class Travis extends DomainEntity {

    @Embedded
    private TravisLogId logId;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
*       DomainEvents.durable().publish(new NewRepositoryAdded(logId, repository.id()));
    }
```

--

```java
@RunInASeparateTransaction
@RetryBeforePanic(times = 3)
class WriteNewRepositryLogEntry implements SideEffect<NewRepositoryAdded> {
    @Override
    public void occur(NewRepositoryAdded $) {
        TravisLog log = logs.byId($.logId());
        log.write(new NewRepositoryLogEntry($.newRepositoryId()));
    }
}
```

---
class: center, middle, example
## an example of
# ephemeral domain events

---
class: codeonly

```java
interface DomainEvent {

    default Type type() {
        return this.getClass();
    }
}
```

--

```java
interface SideEffect<E extends DomainEvent> {

    void occur(E $);

    default TypeToken<E> eventType() {
        return new TypeToken<E>(getClass()) {
        };
    }
}
```

--

```java
interface DomainEvents {

    void publish(DomainEvent event);

    static DomainEvents ephemeral() {
        return EphemeralDomainEvents.instance();
    }

    static DomainEvents durable() {
        return DurableDomainEvents.instance();
    }
}
```

---
class: codeonly
```java
class EphemeralDomainEvents implements DomainEvents {

    private static DomainEvents instance;

    @WhyWorkStealing("http://bit.ly/forkjoinj8")
    private final ExecutorService executor = Executors.newWorkStealingPool();

    private final TransactionTemplate tx;

    private final SideEffects sideEffects;

    public EphemeralDomainEvents(SideEffects sideEffects, TransactionTemplate tx) {
        EphemeralDomainEvents.instance = this;
        ...
    }
```

--

```java
    public void publish(DomainEvent event) {
        sideEffects.byEvent(event)
                .forEach(sideEffect -> inFuture(inTx(txStatus -> sideEffect.occur(event))));
    }

    private CompletableFuture<Void> inFuture(Runnable runnable) {
        return CompletableFuture.runAsync(runnable, executor);
    }

    private Runnable inTx(Consumer<TransactionStatus> consumer) {
        return () -> tx.execute(status -> { consumer.accept(status); return empty(); });
    }
```

--

```java
    public static DomainEvents instance() {
        return checkNotNull(instance, "Ephemeral domain events have not been initialized yet.");
    }
}
```

---
class: codeonly
```java
class SideEffects {

    private final LoadingCache<Type, Collection<SideEffect>> cachedSideEffects;

    public SideEffects(ListableBeanFactory beanFactory) {
        this.cachedSideEffects = Caffeine.newBuilder()
                .build(eventType -> sideEffects(beanFactory)
                        .stream()
                        .filter(sideEffect -> sideEffect.eventType().isSupertypeOf(eventType))
                        .collect(toList()));

    }

    private Collection<SideEffect> sideEffects(ListableBeanFactory beanFactory) {
        return beanFactory
                .getBeansOfType(SideEffect.class)
                .values();
    }

    public Collection<SideEffect> byEvent(DomainEvent event) {
        return cachedSideEffects.get(event.type());
    }
}
```

---
class: center, middle, example
# Stability Patterns
## Shed Load, Bulkheads, Timeouts and Circuit Breakers

---
class: center, middle
## Load Shedding and Bulkheads with Hystrix

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    ...

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Now pipe =
*               new ConcurrencyLimited(
                        new Correlable(
                                new Loggable(
                                        new Transactional(
                                                new Reacting())))));

        return pipe.execute(command);
    }
```

---
class: codeonly
```java
private class ConcurrencyLimited implements Now {

       private final Now origin;

       Hystrix(Now origin) {
           this.origin = origin;
       }

       @Override
       public <C extends Command<R>, R extends Command.R> R execute(C command) {

         HystrixCommand.Setter commandOptions = hystrixOptions(command);
         HystrixCommand<R> hystrixCommand = new HystrixCommand<R>(commandOptions) {
               @Override
               protected R run() throws Exception {
                   return origin.execute(command);
               }
         };
         return hystrixCommand.execute();
       }
```
--

```java
       private HystrixCommand.Setter hystrixOptions(Command command) {
          int concurrencyLimit = command.concurrencyLimit().orElse(10);
          return HystrixCommand.Setter
                .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
                .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                      .withExecutionIsolationStrategy(SEMAPHORE)
                      .withExecutionIsolationSemaphoreMaxConcurrentRequests(concurrencyLimit));
        }
}
```

---
class: codeonly
```java
IntStream.range(1, 10).parallel().forEach(i -> {
      logOnError(()-> new Foo().execute(now));
      logOnError(()-> new Bar().execute(now));
});
```

--
```java
@TwoOutOfTenCommandsWillEndWith
com.netflix.hystrix.exception.HystrixRuntimeException:
  Foo could not acquire a semaphore for execution and no fallback available.
```

--

```java
public interface Reaction<C extends Command<R>, R extends Command.R> {

    R react(C $);

    default R fallback(C $) {
        throw new UnsupportedOperationException("No fallback available.");
    }

    ...
}
```

--

```java
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes fallback(GetTotalLikes $) {
        return new TotalLikes(10000000);
    }
```

---
class: codeonly
```java
private class HystrixGuarded implements Now {
    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Reaction<C, R> reaction = router.route(command);

        HystrixCommand.Setter commandOptions = hystrixOptions(command);
        HystrixCommand<R> hystrixCommand = new HystrixCommand<R>(commandOptions) {
            @Override
            protected R run() throws Exception {
                return reaction.react(command);
            }

            @Override
            protected R getFallback() {
                return reaction.fallback(command);
            }

        };

        return hystrixCommand.execute();
    }
}
```

--
```java
@Override
public <C extends Command<R>, R extends Command.R> R execute(C command) {
    Now pipe =
            new Correlable(
                    new Loggable(
                            new Transactional(
                                    new HystrixGuarded())));

    return pipe.execute(command);
}
```

---

class: codeonly
```java
IntStream.range(1, 10).parallel().forEach(i -> {
      logOnError(()-> new GetTotalLikes().execute(now));
      logOnError(()-> new GetTotalShares().execute(now));
});
```

--
```java
@GetTotalLikesWillAlwaysSucceed
@TwoOutOfTenCommandsWillEndWith
@AllExceptionLeadToFallbackExcept(HystrixBadRequestException.class)
com.netflix.hystrix.exception.HystrixRuntimeException:
  GetTotalShares could not acquire a semaphore for execution and no fallback available.
```

---
class: center, middle
# Timeouts


---
class: codeonly
```java
@AllCommandsRunInTheCallingThread
@AllCallingThreadsWillBlockSoon
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes react(GetTotalLikesReaction $) {
      try {
          TimeUnit.SECONDS.sleep(30);
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
      }
    }

```

--
```java
@NowAllCommandsRunInASeparateThreadPool
@BulkheadsOnSteroids
private HystrixCommand.Setter hystrixOptions(Command command) {
    int concurrencyLimit = command.concurrencyLimit().orElse(10);
    return HystrixCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
            .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                    .withExecutionIsolationStrategy(THREAD)
                    .withExecutionTimeoutInMilliseconds(1000))
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(concurrencyLimit));
}
```
???
runs in a separate thread, because Hystrix must interrupt thread. You don't want to interrupt the whole request.

---
class: center, middle
# Circuit Breaking


---
class: codeonly
```java
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes react(GetTotalLikesReaction $) {
      try {
          TimeUnit.SECONDS.sleep(30);
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
      }
    }

```

--
```java
@FallsBackImmediatelyAfterThirdAttempt
private HystrixCommand.Setter hystrixOptions(Command command) {
    int concurrencyLimit = command.concurrencyLimit().orElse(10);
    return HystrixCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
            .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
*                   .withCircuitBreakerSleepWindowInMilliseconds(30000)
*                   .withCircuitBreakerRequestVolumeThreshold(2)
                    .withExecutionIsolationStrategy(THREAD)
                    .withExecutionTimeoutInMilliseconds(1000))
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(concurrencyLimit));
}
```

---
class: center, middle
# You made it! Now books...

---
background-image:url(goodreads.png)
background-size: 100%

---
background-image:url(twitter.png)
background-size: 100%

---
background-image:url(books1.png)
background-size: 100%

---
background-image:url(books2.png)
background-size: 100%

---
background-image:url(wtw.png)
background-size: 100%

---
class: center, middle
# Final words

---
class: center, middle
# Thank you!



    </textarea>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/remark/0.14.0/remark.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        slideNumberFormat: function (current, total) { return "" }
      });
    </script>

  </body>
</html>
